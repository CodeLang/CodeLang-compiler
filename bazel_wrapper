#!/usr/bin/env bash
# This is the front-end script that bootstraps and calls bazel
# any build commands will go through this script.
# it is expected to behave the same as the bazel command itself (with bootstraping capability / extra features).
# We may also consider bazelisk, but bazelisk would likely need bootstrapped as well.  
# Regardless, we'll always want some kind of bare bones shell script to get/call other build tools.

set -euo pipefail

# the version of bazel we are using
#url=https://github.com/bazelbuild/bazel/releases/download/1.0.0/bazel-1.0.0-linux-x86_64
#sha256=d338fbdc5dd849582914a2411fb34f85b08303f6bfd36e7ca120eec0c27eda52
url=https://github.com/bazelbuild/bazel/releases/download/1.1.0/bazel-1.1.0-linux-x86_64
sha256=f54ab5f31b8d7c6a0ce9dee387af45b1d6577ff9625ef6c535896b59cdf8828a

# paths to place bazel related artifacts
# CONSIDER(thickey): should we really install bazel in the user's home directory?  
# Are we sure they will even have a home repo?  Would it be better to install it inside the repo itself?
# I think this is fine for now.  We'll see if any problems arise.
# It may be recomended to have bazel write its cache to the home directory anyway.
cache_root="${HOME}/.cache"
install_dir="${cache_root}/bazel/${sha256}"
bazel="${install_dir}/bazel"

function ensure_barebone_binaries() {

    # Check for some bootstraping necessities
    # If these bare-bone requirements don't exist, I considered installing them for the user automatically,
    # but that seems hard to figure out due to the different systems and package managers.  
    # One of the online CIs, does not have wget when it spins up.
    # For now, we can handle these kinds of dependencies prior to running this script.
    # For example, most CI services have some kind of pre-install phase.  where you can install system packages.
    command -v mkdir >/dev/null 2>&1 || { echo >&2 "I require mkdir but it's not installed.  Aborting."; exit 1; }
    command -v rm >/dev/null 2>&1 || { echo >&2 "I require rm but it's not installed.  Aborting."; exit 1; }
    command -v chmod >/dev/null 2>&1 || { echo >&2 "I require chmod but it's not installed.  Aborting."; exit 1; }
    command -v trap >/dev/null 2>&1 || { echo >&2 "I require trap but it's not installed.  Aborting."; exit 1; }
    command -v tty >/dev/null 2>&1 || { echo >&2 "I require tty but it's not installed.  Aborting."; exit 1; }
    command -v wget >/dev/null 2>&1 || { echo >&2 "I require wget but it's not installed.  Aborting."; exit 1; }
    command -v sha256sum >/dev/null 2>&1 || { echo >&2 "I require sha256sum but it's not installed.  Aborting."; exit 1; }
    # CONSIDER(thickey): Do you need some kind of Java tooling installed for bazel first?  If so, add it here!
    # I think sfortson mentioned that he had to install bazel first.  The CIs seem to be fine, but sam was on arch linux
    # I'm not sure if bazel's thing is truely stand-alone or what.  you might need the jvm first.
}

function pre_bazel_download_setup_env() {

    # Say that we are missing bazel, and will install it
    echo "INFO: Required bazel version not found."
    echo "downloading to ${bazel}..." >&2

    # Setup install directory & delete it on failure
    mkdir -p "${install_dir}"
    trap 'rm -rf "${install_dir}"' ERR INT TERM
}

function download_bazel() {

    # Download bazel
    # Make more robust in case server is temporarily down
    in_progress_download="${install_dir}/in_progress_download"
    if tty -s; then
        wget "${url}" -O "${in_progress_download}"
    else
        wget "${url}" -O "${in_progress_download}" --no-verbose
    fi
}

function post_bazel_download_verify() {

    # Check that our download is valid
    echo "${sha256}  ${in_progress_download}" | sha256sum --check >&2
    chmod +x "${in_progress_download}"
    mv "${in_progress_download}" "${bazel}"
    trap - ERR INT TERM
}

if [[ ! -f "${bazel}" ]]; then

    ensure_barebone_binaries
    pre_bazel_download_setup_env
    download_bazel
    post_bazel_download_verify

fi

# If Inside Emacs Bazel tries to be helpful say it's "entering a
# directory" but that actually confuses emacs because then it starts
# looking for files inside the runfiles tree.
unset INSIDE_EMACS

# Run the real bazel that we boostrapped
cd source;
"${bazel}" "$@"
