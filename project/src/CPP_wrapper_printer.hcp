class
❪"systems"❫
❪"utilities"❫
❪"CodeLang_structure"❫
⚯
❪"header_printer"❫
❪"methods_printer"❫
⚞⚟


◀public: static▶ void ☀Print_Wrapper_Class(CodeLang_Structure const& structure)❰
    Print_Wrapper_Header(structure);
    Print_Wrapper_Source(structure);
❱

◀public: static▶ void ☀Print_Wrapper_Header(CodeLang_Structure const& structure)❰
    std::wofstream out(As_Capital_And_Pushed_Together(structure.name) + "Wrapper.hpp");
    Print_To_Stream_With_Newline(out,"//Wrapper struct for better testing");
    Print_To_Stream_With_Newline(out,"#pragma once");
    Header_Printer::Print_Object_Interface_Headers(structure.name,out,structure.imports.interface_dependencies);
    auto object_we_are_wrapping = As_Capital_And_Pushed_Together(structure.name) + ".h";
    Print_To_Stream_With_Newline(out,"#include \"" + object_we_are_wrapping + "\"");
    Print_To_Stream_With_Newline(out,"");
    Print_To_Stream(out,"class " + As_Capital_And_Pushed_Together(structure.name));
    Print_To_Stream_With_Newline(out," {");
    Print_To_Stream_With_Newline(out,"");
    Print_To_Stream_With_Newline(out,"//the component we are wrapping in order to make testing easier");
    Print_To_Stream_With_Newline(out,As_Capital_And_Pushed_Together(structure.name) + "OutputsT o;");
    Print_To_Stream_With_Newline(out,"");
    Print_Declerations(out,structure);
    Print_To_Stream_With_Newline(out,"};");
    
    
    
    
❱
◀public: static▶ void ☀Print_Wrapper_Source(CodeLang_Structure const& structure)❰
    std::wofstream out(As_Capital_And_Pushed_Together(structure.name) + "Wrapper.cpp");
    Print_To_Stream_With_Newline(out,"//Wrapper file for testing");
    auto object_we_are_wrapping = As_Capital_And_Pushed_Together(structure.name);
    Print_To_Stream(out, "#include \"");
    Print_To_Stream(out,object_we_are_wrapping + "Wrapper.hpp");
    Print_To_Stream_With_Newline(out, "\"");
    Print_To_Stream_With_Newline(out, "");
    auto method_count = Number_Of_Non_Constructing_Methods(structure.name,structure.methods.methods);
    Methods_Printer::Print_Wrapper_Definition_Methods(structure.name,out,structure.methods.methods,method_count);
❱

◀public: static▶ void ☀Print_Declerations(std::wofstream & out, CodeLang_Structure const& structure)❰
    Print_To_Stream_With_Newline(out,"public:");
    Methods_Printer::Print_Wrapper_Decleration_Methods(structure.name,out,structure.methods.methods);
❱

◀private: static▶ unsigned int ☀Number_Of_Non_Constructing_Methods(std::string file_name, std::vector<Method_Item> methods)❰
    //first get the number of callable methods
    unsigned int number_of_methods_not_counting_constructor = 0;
    for (auto it: methods){
        if (!Is_Constructor(file_name,it)){
            ++number_of_methods_not_counting_constructor;
        }
    }
    return number_of_methods_not_counting_constructor;
❱

◀private: static▶ bool ☀Is_Constructor(std::string file_name, Method_Item const& m)❰
        if (As_Capital_And_Pushed_Together(file_name) == As_Capital_And_Pushed_Together(as_string(m.function_name))){
            return true;
        }
        return false;
❱


