class
❪"systems"❫
❪"utilities"❫
❪"CodeLang_structure"❫
⚯

❪"export_spawner"❫

❪"CodeLang_trevor_exporter"❫
❪"CodeLang_f2si_exporter"❫
⚞⚟

//c language standards to support: 
//‘c90’
//‘c89’
//‘iso9899:1990’
//‘iso9899:199409’
//‘c99’
//‘iso9899:1999’
//‘c11’
//‘iso9899:2011’
//‘gnu90’
//‘gnu89’
//‘gnu99’
//‘gnu11’

//c++ language standards to support
//‘c++98’
//‘c++03’
//‘gnu++98’
//‘gnu++03’
//‘c++11’
//‘gnu++11’
//‘c++14’
//‘gnu++14’
//‘c++1z’
//‘gnu++1z’

//other languages and language standards...

//exporter = often a company or a person of interest.
//*it's a collection of configurations on how the code should be exported.

//language = what language the exporter should export to
//this doesn't just imply other language code.  Maybe you want to print to UML, maybe you want to print user docs.
//language options are decided and supported by the exporter.  The exporter has no obligation to support anything it doesn't want to

//style = variations to take on the exported language.  For example,
//f2si has a really bad "component design".  However, they are slowly starting to realize how bad it is, and I've been allowed to turn other
//code into our "data structure design".  (Data structure design is bad name for it; it's a normal C design).  
//So these are both styles that I can apply on the same object code.
//Hopefully I can start transitioning the code from the bad design to the good design assuming we stay in business.

◀public: static▶ void ☀Compile(CodeLang_Structure structure, std::string const& exporter, std::string const& language, std::string const& style)❰

    Export_Spawner spawner("UniLang");
    spawner.Add("trevor",CodeLang_Trevor_Exporter::Export);
    spawner.Add("f2si",CodeLang_F2si_Exporter::Export);
    //spawner.Add("New Company",CodeLang_Company_Exporter::Export);
    
    spawner.Spawn_Exporter(exporter,structure,language,style);
❱
