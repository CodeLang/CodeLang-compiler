class
❪"systems"❫
❪"utilities"❫
❪"CodeLang_structure"❫
⚯
❪"meta_block_printer"❫
❪"type_to_hungarian_notation_converter"❫
⚞⚟

//options:
//align / don't align header comments
//put a comment at the end of the include guards
//include guards format styles

//header comment related:
//put header comment even if none was provided
//headers do block comment or headers to line comment
//space after line comment or spaces between block comment
//do comments hug header files, or is there a space between?


◀public: static▶ void ☀Export(CodeLang_Structure const& structure)❰
    
    Create_Path_If_It_Doesnt_Already_Exist_And_Step_Into_It(As_Capital_And_Pushed_Together(structure.name));
    
    if (structure.meta.code_type == L"global"){
        Create_Global_Files(structure);
    }
    else if(structure.meta.code_type == L"object"){
        Create_Object_Files(structure);
    }
    else if(structure.meta.code_type == L"enum"){
        Create_Enum_Files(structure);
    }
    
    Step_Out_Of_Folder();
❱

◀private: static▶ void ☀Create_Global_Files(CodeLang_Structure const& structure)❰
    
    Print_Global_Interface_File(structure);
    Print_Global_Implementation_File(structure);
❱
◀private: static▶ void ☀Create_Object_Files(CodeLang_Structure const& structure)❰

    //create all the files
    Print_Object_Interface_File(structure);
    Print_Object_Implementation_File(structure);
    Print_Object_Data_File(structure);
❱
◀private: static▶ void ☀Create_Enum_Files(CodeLang_Structure const& structure)❰
    Print_Enum_Interface_File(structure);
    Print_Enum_Implementation_File(structure);
❱
◀private: static▶ void ☀Print_Enum_Interface_File(CodeLang_Structure const& structure)❰
❱
◀private: static▶ void ☀Print_Enum_Implementation_File(CodeLang_Structure const& structure)❰
❱


◀private: static▶ void ☀Print_Object_Interface_File(CodeLang_Structure const& structure)❰

    std::wofstream out(As_Capital_And_Pushed_Together(structure.name) + ".h");
    Meta_Block_Printer::Print(structure.name,out,"Interface",structure.meta);
    Print_Beginning_Of_Header_Include_Gaurd(structure.name,out);
    Print_Object_Interface_Headers(structure.name,out,structure.imports.interface_dependencies);
    Possibly_Print_Close_Markers(out,structure.name,structure.meta,true);
❱
◀private: static▶ void ☀Print_Object_Implementation_File(CodeLang_Structure const& structure)❰

    std::wofstream out(As_Capital_And_Pushed_Together(structure.name) + ".c");
    Meta_Block_Printer::Print(structure.name,out,"Implementation",structure.meta);
    Print_Object_Implementation_Headers(structure.name,out,structure.imports.implementation_dependencies);
    Possibly_Print_Close_Markers(out,structure.name,structure.meta,false);
❱
◀private: static▶ void ☀Print_Object_Data_File(CodeLang_Structure const& structure)❰

    std::wofstream out(As_Capital_And_Pushed_Together(structure.name) + "Data.h");
    Meta_Block_Printer::Print(structure.name,out,"Data",structure.meta);
    Print_Beginning_Of_Header_Include_Gaurd(structure.name,out);
    Print_Object_Data_Headers(structure.name,out,structure.imports.interface_dependencies);
    Possibly_Print_Close_Markers(out,structure.name,structure.meta,true);
❱

◀private: static▶ void ☀Print_Global_Interface_File(CodeLang_Structure const& structure)❰

    std::wofstream out(As_Capital_And_Pushed_Together(structure.name) + ".h");
    Meta_Block_Printer::Print(structure.name,out,"Interface",structure.meta);
    Print_Beginning_Of_Header_Include_Gaurd(structure.name,out);
    Print_Global_Interface_Headers(structure.name,out,structure.imports.interface_dependencies);
    Print_Global_Interface_Methods(out,structure.methods.methods);
    Possibly_Print_Close_Markers(out,structure.name,structure.meta,true);
❱
◀private: static▶ void ☀Print_Global_Implementation_File(CodeLang_Structure const& structure)❰

    std::wofstream out(As_Capital_And_Pushed_Together(structure.name) + ".c");
    Meta_Block_Printer::Print(structure.name,out,"Implementation",structure.meta);
    Print_Global_Implementation_Headers(structure.name,out,structure.imports.implementation_dependencies);
    Print_Global_Implementation_Methods(out,structure.methods.methods);
    Possibly_Print_Close_Markers(out,structure.name,structure.meta,false);
❱

//header related
◀private: static▶ void ☀Print_Beginning_Of_Header_Include_Gaurd(std::string file_name,std::wofstream & out)❰
        Print_To_Stream_With_Newline(out,"#ifndef " + As_Capital_And_Pushed_Together(file_name) + "H");
        Print_To_Stream_With_Newline(out,"#define " + As_Capital_And_Pushed_Together(file_name) + "H");
        Print_To_Stream_With_Newline(out,"");
❱
◀private: static▶ void ☀Print_Object_Interface_Headers(std::string file_name,std::wofstream & out, std::vector<Import_Item> const& imports)❰
    Print_To_Stream(out,"#include \"" + As_Capital_And_Pushed_Together(file_name) + "Data.h\"");
    Print_To_Stream_With_Newline(out," //USES: " + As_Capital_And_Pushed_Together(file_name) + "InputsT " + As_Capital_And_Pushed_Together(file_name) + "OutputsT");
❱
◀private: static▶ void ☀Print_Object_Implementation_Headers(std::string file_name,std::wofstream & out, std::vector<Import_Item> const& imports)❰
        auto max_length = Max_Header_File_Length(imports);
        
        //adjust for the obligatory header needed
        auto needed_header = As_Capital_And_Pushed_Together(file_name) + ".h";
        if (needed_header.length() > max_length){ max_length = needed_header.length();}
        
        Print_To_Stream(out,"#include \"" + needed_header + "\"");
        Print_To_Stream_N_Times(out," ",max_length+1-needed_header.length());
        Print_To_Stream_With_Newline(out," //USES: " + As_Capital_And_Pushed_Together(file_name) + "InputsT " + As_Capital_And_Pushed_Together(file_name) + "OutputsT");
        Print_Each_Include_Line(out,imports,max_length);
❱
◀private: static▶ void ☀Print_Object_Data_Headers(std::string file_name,std::wofstream & out, std::vector<Import_Item> const& imports)❰
        auto max_length = Max_Header_File_Length(imports);
        Print_Each_Include_Line(out,imports,max_length);
❱
◀private: static▶ void ☀Print_Global_Interface_Headers(std::string file_name,std::wofstream & out, std::vector<Import_Item> const& imports)❰
    if (!imports.empty()){
        auto max_length = Max_Header_File_Length(imports);
        Print_Each_Include_Line(out,imports,max_length);
        Print_To_Stream_With_Newline(out,"");
    }
❱
◀private: static▶ void ☀Print_Global_Implementation_Headers(std::string file_name,std::wofstream & out, std::vector<Import_Item> const& imports)❰

        auto max_length = Max_Header_File_Length(imports);
        
        //adjust for the obligatory header needed
        auto needed_header = file_name + ".h";
        if (needed_header.length() > max_length){ max_length = needed_header.length();}
        
        Print_To_Stream(out,"#include \"" + needed_header + "\"");
        Print_To_Stream_N_Times(out," ",max_length+1-needed_header.length());
        Print_To_Stream_With_Newline(out," //header");
        Print_Each_Include_Line(out,imports,max_length);
        Print_To_Stream_With_Newline(out,"");
❱
◀private: static▶ size_t ☀Max_Header_File_Length(std::vector<Import_Item> const& imports)❰

    //get max length of the imports so we can align the comments
    size_t max_length = 0;
    for (auto it: imports){
        if (it.name.size() > max_length){
            max_length = it.name.size();
        }
    }
    return max_length;
❱
◀private: static▶ void ☀Print_Each_Include_Line(std::wofstream & out, std::vector<Import_Item> const& imports, size_t const& max_length)❰
    
    for (auto it: imports){
        Print_To_Stream(out,"#include ");
        if (it.system){
            Print_To_Stream(out,L"<" + it.name + L">");
            Print_To_Stream_N_Times(out," ",max_length+1-it.name.length());
            Print_To_Stream(out," //");
            Print_To_Stream_With_Newline(out,it.comment);
            
        }
        else{
            Print_To_Stream(out,L"\"" + it.name + L"\"");
            Print_To_Stream_N_Times(out," ",max_length+1-it.name.length());
            Print_To_Stream(out," //");
            Print_To_Stream_With_Newline(out,it.comment);
        }
    }
❱



//method related
◀private: static▶ void ☀Print_Global_Interface_Methods(std::wofstream & out, std::vector<Method_Item> const& methods)❰

    for (auto it: methods){
        Print_Method_Interface(out,it);
    }
❱
◀private: static▶ void ☀Print_Global_Implementation_Methods(std::wofstream & out, std::vector<Method_Item> const& methods)❰
    for (auto it: methods){
        Print_Method_Definition(out,it);
    }
❱
◀private: static▶ void ☀Print_Method_Interface(std::wofstream & out, Method_Item const& method)❰
    Print_Doxygen_Method_Comment(out,method);
❱
◀private: static▶ void ☀Print_Method_Definition(std::wofstream & out, Method_Item const& method)❰
    Print_Doxygen_Method_Comment(out,method);
❱

◀private: static▶ void ☀Print_Doxygen_Method_Comment(std::wofstream & out, Method_Item const& method)❰
    Print_To_Stream_With_Newline(out,"/**");
    Print_Multiline_Tag(out,"brief",method.brief_description);
    Print_Multiline_Tag(out,"details",method.detailed_description);
    Print_Doxygen_Template_Arguments(out,method.template_arguments);
    Print_Doxygen_Function_Arguments(out,method.function_arguments);
    Print_Doxygen_Return_Results(out,method.return_results);
    Print_To_Stream_With_Newline(out,"");
    
❱

◀public: static▶ void ☀Print_Doxygen_Template_Arguments(std::wofstream & out, std::vector<Template_Argument> const& template_arguments)❰

    for (auto it: template_arguments){
        auto identifier = as_string(it.identifier);
        auto type       = as_string(it.type);
        bool is_pointer = Begins_Or_Ends_With(type,"&") || Ends_With(type,"*const") || Ends_With(type,"*");
        Print_Multiline_Tag(out,"tparam",it.comment);
    }
❱
◀public: static▶ void ☀Print_Doxygen_Function_Arguments(std::wofstream & out, std::vector<Function_Argument> const& function_arguments)❰
    for (auto it: function_arguments){
        auto identifier = as_string(it.identifier);
        auto type       = as_string(it.type);
        std::cout << type << std::endl;
        std::cout << identifier << std::endl;
        bool is_pointer = Begins_Or_Ends_With(type,"&") || Ends_With(type,"*const") || Ends_With(type,"*");
        auto prefix     = Type_To_Hungarian_Notation_Converter::Get_Hungarian_Notation_Prefix(type,is_pointer,false,false,false,false);
        auto new_identifier = prefix + As_Capital_And_Pushed_Together(identifier);
        auto new_description = as_wstring(new_identifier) + L" " + it.comment;
        Print_Multiline_Tag(out,"param",new_description);
    }
❱
◀public: static▶ void ☀Print_Doxygen_Return_Results(std::wofstream & out, std::vector<Function_Result> const& return_results)❰
❱


◀public: static▶ void ☀Print_Multiline_Tag(std::wofstream & out, std::string tag, std::wstring content)❰

    std::string start_tag_line = " * @" + as_string(tag) + " ";
    if (!content.empty()){
        Print_To_Stream(out,start_tag_line);
        auto new_content = as_string(content);
        trim(new_content);
        auto lines = Split_Into_Parts_From_Delimiter(new_content,'\n');
        
        Call_Function_On_First_Element_And_Then_Function_On_The_Rest_Of_The_Elements(lines
        ,[&](std::string s){Print_To_Stream_With_Newline(out,s);}
        ,[&](std::string s){
            Print_To_Stream(out,"*");
            Print_To_Stream_N_Times(out," ",start_tag_line.size()-1);
            Print_To_Stream_With_Newline(out,s);
        }
        );
        
        
        //Print_To_Stream_With_Newline(out," *");
    }
❱









◀private: static▶ void ☀Possibly_Print_Close_Markers(std::wofstream & out, std::string file_name,Meta_Section const& meta, bool is_header)❰

    if (is_header){
        Print_To_Stream_With_Newline(out,"#endif /* " + As_Capital_And_Pushed_Together(file_name) + "H */");
    }
    if (!meta.group_names.empty()){
        Print_To_Stream_With_Newline(out,"///@}");
    }
    Print_To_Stream_With_Newline(out,"");
    
❱


