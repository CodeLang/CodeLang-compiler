class
❪"systems"❫
❪"utilities"❫
❪"CodeLang_structure"❫
❪"parser_token"❫

//sections
❪"meta_section"❫
❪"import_section"❫
❪"namespace_section"❫
❪"inheritance_section"❫
❪"method_section"❫
❪"data_member_section"❫

//items of sections
❪"import_item"❫
❪"namespace_item"❫
❪"inheritance_item"❫
❪"method_item"❫
❪"data_member_item"❫
❪"token_group"❫
❪"template_argument"❫
❪"function_result"❫
❪"function_argument"❫
⚯

⚞⚟

//turn the entire stream of tokens into a CodeLang data structure
◀public: static▶ CodeLang_Structure ☀Create_Code_Object_From_Token_Stream(std::vector<Parser_Token> const& tokens, std::string const& path_to_file)❰
    CodeLang_Structure code;
    //the overall structure of any CodeLang file
    code.meta         = Parse_Out_Meta_Section(tokens);
    code.imports      = Parse_Out_Import_Section(tokens);
    code.macros       = Parse_Out_Macro_Section(tokens);
    code.namespaces   = Parse_Out_Namespace_Section(tokens);
    code.inheritance  = Parse_Out_Inheritance_Section(tokens);
    code.methods      = Parse_Out_Method_Section(tokens);
    code.data_members = Parse_Out_Data_Member_Section(tokens);
    code.enums        = Parse_Out_Enum_Section(tokens);
    
    //set the file name that the code structure was derived from
    code.name = As_Removed_Suffix(Get_File_Name_From_File_Path(path_to_file));
    return code;
❱

//root setters
◀public: static▶ Meta_Section ☀Parse_Out_Meta_Section(std::vector<Parser_Token> const& tokens)❰
    Meta_Section section;
    
    //singles
    section.code_type            = Get_Value_Of_Token_Name(tokens, Token_Name::META_DATA_CODE_TYPE);
    section.brief_description    = Get_Value_Of_Token_Name(tokens, Token_Name::META_DATA_BRIEF_DESCRIPTION);
    section.detailed_description = Get_Value_Of_Token_Name(tokens, Token_Name::META_DATA_DETAILED_DESCRIPTION);
    
    //multiple instances
    section.group_names = Get_Values_Of_Token_Name(tokens, Token_Name::META_DATA_GROUP_NAME);
    section.authors     = Get_Values_Of_Token_Name(tokens, Token_Name::META_DATA_AUTHOR);
    section.bugs        = Get_Values_Of_Token_Name(tokens, Token_Name::META_DATA_BUG);
    section.warnings    = Get_Values_Of_Token_Name(tokens, Token_Name::META_DATA_WARNING);
    
    return section;
❱
◀public: static▶ Import_Section ☀Parse_Out_Import_Section(std::vector<Parser_Token> const& tokens)❰
    Import_Section section;
    
    section.interface_dependencies      = Strip_Out_Interface_Imports(tokens);
    section.implementation_dependencies = Strip_Out_Implementation_Imports(tokens);
    
    return section;
❱
◀public: static▶ Macro_Section ☀Parse_Out_Macro_Section(std::vector<Parser_Token> const& tokens)❰
    Macro_Section section;
    
    section.macros = Strip_Out_Macros(tokens);
    
    return section;
❱

◀public: static▶ Namespace_Section ☀Parse_Out_Namespace_Section(std::vector<Parser_Token> const& tokens)❰
    Namespace_Section section;
    
    section.namespaces = Strip_Out_Namespaces(tokens);
    
    return section;
❱
◀public: static▶ Inheritance_Section ☀Parse_Out_Inheritance_Section(std::vector<Parser_Token> const& tokens)❰
    Inheritance_Section section;
    
    //section.inherited_objects = Strip_Out_Inheritances(tokens);
    
    return section;
❱
◀public: static▶ Method_Section ☀Parse_Out_Method_Section(std::vector<Parser_Token> const& tokens)❰
    Method_Section section;
    
    section.methods = Strip_Out_Methods(tokens);
    
    return section;
❱
◀public: static▶ Data_Member_Section ☀Parse_Out_Data_Member_Section(std::vector<Parser_Token> const& tokens)❰
    Data_Member_Section section;
    
    section.data_members = Strip_Out_Data_Members(tokens);
    
    return section;
❱
◀public: static▶ Enum_Section ☀Parse_Out_Enum_Section(std::vector<Parser_Token> const& tokens)❰
    Enum_Section section;
    
    section.enumerated_types = Strip_Out_Enumerated_Types(tokens);
    
    return section;
❱


//sub strippers
◀public: static▶ std::vector<Import_Item> ☀Strip_Out_Interface_Imports(std::vector<Parser_Token> const& tokens)❰
    return Strip_Out_Import_Type(tokens,Token_Name::IMPORT_INTERFACE);
❱
◀public: static▶ std::vector<Import_Item> ☀Strip_Out_Implementation_Imports(std::vector<Parser_Token> const& tokens)❰
    return Strip_Out_Import_Type(tokens,Token_Name::IMPORT_IMPLEMENTATION);
❱
◀public: static▶ std::vector<Import_Item> ☀Strip_Out_Import_Type(std::vector<Parser_Token> const& tokens, Token_Name const& import_type)❰

    auto import_related = Filter_Out_Tokens_By_Group_Name(tokens,Token_Group::IMPORT);
    
    std::vector<Import_Item> return_items;
    Import_Item item;
    bool last_saw = false;
    
    for (it: import_related){
        
        //import line
        if(it.token.name == Token_Name::IMPORT_IMPLEMENTATION || it.token.name == Token_Name::IMPORT_INTERFACE){
            
            if (last_saw){
                Add_Import_Item_To_List(return_items,item);
                item.comment.clear();
            }
            
            if (it.token.name != import_type){
                last_saw = false;
            }
            else{
                last_saw = true;
                item.name = it.content;
            }
        }
        
        //comment line
        else if(it.token.name == Token_Name::IMPORT_COMMENT){
            if (last_saw){
                item.comment = it.content;
                Add_Import_Item_To_List(return_items,item);
                item.comment.clear();
                last_saw = false;
            }
        }
    }
    
    if (last_saw){
        Add_Import_Item_To_List(return_items,item);
    }
    
    return return_items;
❱
◀public: static▶ void ☀Add_Import_Item_To_List(std::vector<Import_Item> & imports, Import_Item item)❰


    //decide if its a system or a local header
    if (item.name.front() == L'/'){
        item.system = true;
        item.name.erase(0,1);
    }
    else{
        item.system = false;
    }
    
    imports.push_back(item);
❱
◀public: static▶ std::vector<Namespace_Item> ☀Strip_Out_Namespaces(std::vector<Parser_Token> const& tokens)❰
    std::vector<Namespace_Item> items;
    //not important right now..
    return items;
❱
◀public: static▶ std::vector<Macro_Item> ☀Strip_Out_Macros(std::vector<Parser_Token> const& tokens)❰
    std::vector<Macro_Item> items;
    auto new_tokens = Filter_Out_Tokens_By_Group_Name(tokens,Token_Group::MACRO);
    items = Get_Macro_Items(new_tokens);
    return items;
❱

◀public: static▶ std::vector<Enum_Item> ☀Strip_Out_Enumerated_Types(std::vector<Parser_Token> const& tokens)❰
    std::vector<Enum_Item> items;
    auto new_tokens = Filter_Out_Tokens_By_Group_Name(tokens,Token_Group::ENUM);
    auto split = Filter_Enum_Chunks(new_tokens);
    for (auto it: split){
        items.push_back(Build_Enum_Item(it));
    }
    return items;
❱
◀public: static▶ std::vector<Method_Item> ☀Strip_Out_Methods(std::vector<Parser_Token> const& tokens)❰
    std::vector<Method_Item> items;
    
    auto new_tokens = Filter_Out_Tokens_By_Group_Name(tokens,Token_Group::FUNCTION);
    auto split =  Filter_Method_Chunks(new_tokens);
    for(auto it: split){
        items.push_back(Build_Method_Item(it));
    }
    
    return items;
❱




//builders
◀public: static▶ Enum_Item ☀Build_Enum_Item(std::vector<Parser_Token> const& tokens)❰
    Enum_Item item;
    
    //get out singles
    auto name = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::ENUM_NAME);
    auto brief = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::ENUM_BRIEF);
    auto detail = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::ENUM_DETAIL);
    
    //get out multiples
    auto args = Get_Enum_Args(Filter_Out_Tokens_By_Group(tokens,Token_Group::ENUM_ARG));
    
    //set them all
    item.args = args;
    
    for (auto it: name){item.name = it.content;}
    for (auto it: brief){item.brief = it.content;}
    for (auto it: detail){item.detail = it.content;}
        
    return item;
❱

◀public: static▶ Method_Item ☀Build_Method_Item(std::vector<Parser_Token> const& tokens)❰
    Method_Item item;
    
    //get out singles
    auto class_specifiers = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::FUNCTION_CLASS_SPECIFIERS);
    auto attributes = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::FUNCTION_ATTRIBUTES);
    auto categories = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::FUNCTION_OPERATION_CATEGORY);
    auto name = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::FUNCTION_NAME);
    auto brief = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::FUNCTION_BRIEF_DESCRIPTION);
    auto detailed = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::FUNCTION_DETAILED_DESCRIPTION);
    auto exception = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::EXCEPT_EXPRESSION);
    auto exception_comment = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::EXCEPT_COMMENT);
    auto function_body = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::FUNCTION_BODY);
    
    //get out multiples
    auto template_args = Get_Template_Args(Filter_Out_Tokens_By_Group(tokens,Token_Group::FUNCTION_TEMPLATE_ARGUMENT));
    auto function_args = Get_Function_Args(Filter_Out_Tokens_By_Group(tokens,Token_Group::FUNCTION_ARGUMENT));
    auto return_results = Get_Return_Results(Filter_Out_Tokens_By_Group(tokens,Token_Group::FUNCTION_RESULT));
    
    //set them all
    item.template_arguments = template_args;
    item.function_arguments = function_args;
    item.return_results     = return_results;
    
    
    for (auto it: class_specifiers){
        
        //set value lvalue / rvalue overload
             if (Contains(it.content,L'l')){item.value_overload = Value_Overload::LVALUE;}
        else if (Contains(it.content,L'r')){item.value_overload = Value_Overload::RVALUE;}
        else {item.value_overload = Value_Overload::NONE;}
        
        //set the class accessor
             if (Contains(it.content,L'+')){item.class_access = Class_Access::PUBLIC;}
        else if (Contains(it.content,L'#')){item.class_access = Class_Access::PROTECTED;}
        else if (Contains(it.content,L'-')){item.class_access = Class_Access::PRIVATE;}
        
        //set other specific things related to methods
        if (Contains(it.content,L's')){item.is_static = true;}else{item.is_static = false;}
        if (Contains(it.content,L'c')){item.is_const = true;}else{item.is_const = false;}
        if (Contains(it.content,L'v')){item.is_virtual = true;}else{item.is_virtual = false;}
    }
    
    
    for (auto it: attributes){item.attributes.push_back(it.content);}
    //for (auto it: categories){item.categories = it.content;}
    for (auto it: name)      {item.function_name = it.content;}
    for (auto it: brief){item.brief_description = it.content;}
    for (auto it: detailed){item.detailed_description = it.content;}
    for (auto it: exception){item.exception_expression = it.content;}
    for (auto it: exception_comment){item.exception_comment = it.content;}
    for (auto it: function_body){item.body = it.content;}
    
    
    
    return item;
❱
◀public: static▶ std::vector<Macro_Item> ☀Get_Macro_Items(std::vector<Parser_Token> const& tokens)❰
    std::vector<Macro_Item> all;
    Macro_Item t;
    auto splits = Filter_By_Data_Member_Uniqueness(tokens);
    for (auto x : splits){
        t = Macro_Item{};
        for (auto y : x){
            if      (y.token.name == Token_Name::MACRO_NAME)      {t.name = y.content;}
            else if (y.token.name == Token_Name::MACRO_BRIEF)     {t.brief = y.content;}
            else if (y.token.name == Token_Name::MACRO_DETAIL)    {t.detail = y.content;}
            else if (y.token.name == Token_Name::MACRO_VALUE)     {t.value = y.content;}
        }
        all.push_back(t);
    }
    
    
    return all;
❱





◀public: static▶ std::vector<Template_Argument> ☀Get_Template_Args(std::vector<Parser_Token> const& tokens)❰
    std::vector<Template_Argument> all;
    Template_Argument t;
    auto splits = Filter_By_Data_Member_Uniqueness(tokens);
    for (auto x : splits){
        t = Template_Argument{};
        for (auto y : x){
            if      (y.token.name == Token_Name::FUNCTION_TEMPLATE_ARGUMENT_TYPE)      {t.type = y.content;}
            else if (y.token.name == Token_Name::FUNCTION_TEMPLATE_ARGUMENT_IDENTIFIER){t.identifier = y.content;}
            else if (y.token.name == Token_Name::FUNCTION_TEMPLATE_ARGUMENT_DEFAULT)   {t.default_value = y.content;}
            else if (y.token.name == Token_Name::FUNCTION_TEMPLATE_ARGUMENT_COMMENT)   {t.comment = y.content;}
        }
        all.push_back(t);
    }
    
    
    return all;
❱
◀public: static▶ std::vector<Function_Argument> ☀Get_Function_Args(std::vector<Parser_Token> const& tokens)❰
    std::vector<Function_Argument> all;
    Function_Argument t;
    auto splits = Filter_By_Data_Member_Uniqueness(tokens);
    for (auto x : splits){
        t = Function_Argument{};
        for (auto y : x){
            if      (y.token.name == Token_Name::FUNCTION_ARGUMENT_TYPE_QUALIFIERS) {
                t.is_const = Contains(y.content,L'c');
            }
            else if (y.token.name == Token_Name::FUNCTION_ARGUMENT_TYPE)            {t.type = y.content;}
            else if (y.token.name == Token_Name::FUNCTION_ARGUMENT_IDENTIFIER)      {t.identifier = y.content;}
            else if (y.token.name == Token_Name::FUNCTION_ARGUMENT_DEFAULT)         {t.default_value = y.content;}
            else if (y.token.name == Token_Name::FUNCTION_ARGUMENT_COMMENT)         {t.comment = y.content;}
        }

        all.push_back(t);
    }
    
    return all;
❱
◀public: static▶ std::vector<Function_Result>    ☀Get_Return_Results(std::vector<Parser_Token> const& tokens)❰
    std::vector<Function_Result> all;
    Function_Result t;
    auto splits = Filter_By_Data_Member_Uniqueness(tokens);
    for (auto x : splits){
        t = Function_Result{};
        for (auto y : x){
            if      (y.token.name == Token_Name::FUNCTION_RESULT_TYPE_QUALIFIERS) {
                t.is_const = Contains(y.content,L'c');
            }
            else if (y.token.name == Token_Name::FUNCTION_RESULT_TYPE)            {t.type = y.content;}
            else if (y.token.name == Token_Name::FUNCTION_RESULT_IDENTIFIER)      {t.identifier = y.content;}
            else if (y.token.name == Token_Name::FUNCTION_RESULT_COMMENT)         {t.comment = y.content;}
        }
        all.push_back(t);
    }
    
    return all;
❱
◀public: static▶ std::vector<Enum_Arg>    ☀Get_Enum_Args(std::vector<Parser_Token> const& tokens)❰
    std::vector<Enum_Arg> all;
    Enum_Arg t;
    auto splits = Filter_By_Data_Member_Uniqueness(tokens);
    for (auto x : splits){
        t = Enum_Arg{};
        for (auto y : x){
            if      (y.token.name == Token_Name::ENUM_ARG_NAME)      {t.name = y.content;}
            else if (y.token.name == Token_Name::ENUM_ARG_VALUE)     {t.value = y.content;}
            else if (y.token.name == Token_Name::ENUM_ARG_COMMENT)   {t.comment = y.content;}
        }
        all.push_back(t);
    }
    
    
    return all;
❱


◀public: static▶ std::vector<std::vector<Parser_Token>> ☀Filter_Method_Chunks(std::vector<Parser_Token> const& tokens)❰
    std::vector<std::vector<Parser_Token>> all;
    std::vector<Parser_Token> some;
    
    for (it: tokens){
        some.push_back(it);
        if (In_Vector(it.token.groups,Token_Group::FUNCTION_BODY)){
            all.push_back(some);
            some.clear();
        }
    }
    
    return all;
❱
◀public: static▶ std::vector<std::vector<Parser_Token>> ☀Filter_Enum_Chunks(std::vector<Parser_Token> const& tokens)❰
    //for now, assume only one enum per file
    std::vector<std::vector<Parser_Token>> all;
    if (!tokens.empty()){
        all.push_back(tokens);
    }
    return all;
❱

◀public: static▶ std::vector<std::vector<Parser_Token>> ☀Filter_Macro_Chunks(std::vector<Parser_Token> const& tokens)❰
    std::vector<std::vector<Parser_Token>> all;
    std::vector<Parser_Token> some;
    
    return all;
❱







◀public: static▶ std::vector<Data_Member_Item> ☀Strip_Out_Data_Members(std::vector<Parser_Token> const& tokens)❰
    std::vector<Data_Member_Item> all;
    
    auto new_tokens = Filter_Out_Tokens_By_Group_Name(tokens,Token_Group::DATA_MEMBER);
    auto split =  Filter_By_Data_Member_Uniqueness(new_tokens);
    for(auto it: split){
        all.push_back(Build_Data_Member_Item(it));
    }
    
    return all;
❱

◀public: static▶ Data_Member_Item ☀Build_Data_Member_Item(std::vector<Parser_Token> const& tokens)❰
    
    Data_Member_Item item;
    for (auto it: tokens){
        
        //handle class accessors
        if(it.token.name == Token_Name::DATA_MEMBER_CLASS_SPECIFIERS) {
                 if (Contains(it.content,L'+')){item.class_access = Class_Access::PUBLIC;}
            else if (Contains(it.content,L'#')){item.class_access = Class_Access::PROTECTED;}
            else if (Contains(it.content,L'-')){item.class_access = Class_Access::PRIVATE;}
        }
        
        //handle other qualifiers
        else if (it.token.name == Token_Name::DATA_MEMBER_TYPE_QUALIFIERS)  {
            
            if (Contains(it.content,L's')){item.storage = Storage_Specifier::STATIC;}
            else if (Contains(it.content,L'e')){item.storage = Storage_Specifier::EXTERN;}
            else {item.storage = Storage_Specifier::NONE;}
            if (Contains(it.content,L'c')){item.is_const = true;}else{item.is_const = false;}
        }
        
        //handle singles
        else if (it.token.name == Token_Name::DATA_MEMBER_TYPE)             {item.type = it.content;}
        else if (it.token.name == Token_Name::DATA_MEMBER_IDENTIFIER)       {item.name = it.content;}
        else if (it.token.name == Token_Name::DATA_MEMBER_DEFAULT_VALUE)    {item.default_value = it.content;}
        else if (it.token.name == Token_Name::DATA_MEMBER_BRIEF)            {item.brief = it.content;}
        else if (it.token.name == Token_Name::DATA_MEMBER_DETAILED)         {item.detail = it.content;}
        else if (it.token.name == Token_Name::DATA_MEMBER_STATE_SPECIFIER)  {
            auto str = as_string(it.content);
            if (str == "observe"){ item.is_observable = true;}
            if (str == "inject"){ item.is_injectable = true;}
            if (str == "obtain"){ item.is_obtainable = true;}
        }

    }
    
    
    return item;
❱




//filtering stream of parse tokens
◀public: static▶ std::vector<Parser_Token> ☀Filter_Out_Tokens_By_Token_Name(std::vector<Parser_Token> const& tokens, Token_Name name)❰
    std::vector<Parser_Token> new_tokens;
    for (it: tokens){
        if(it.token.name == name) {new_tokens.push_back(it);}
    }
    return new_tokens;
❱
◀public: static▶ std::vector<Parser_Token> ☀Filter_Out_Tokens_By_Group_Name(std::vector<Parser_Token> const& tokens, Token_Group group_name)❰
    std::vector<Parser_Token> new_tokens;
    for (it: tokens){
        if(In_Vector(it.token.groups,group_name)){new_tokens.push_back(it);}
    }
    return new_tokens;
❱







◀public: static▶ std::vector<Parser_Token> ☀Filter_Out_Tokens_By_Group(std::vector<Parser_Token> const& tokens, Token_Group name)❰

    //filter
    std::vector<Parser_Token> new_tokens;
    for (it: tokens){
        for (y: it.token.groups){
            if(y == name) {new_tokens.push_back(it);}
        }
    }
    return new_tokens;
❱


◀public: static▶ std::vector<std::vector<Parser_Token>> ☀Filter_By_Data_Member_Uniqueness(std::vector<Parser_Token> const& tokens)❰
    std::vector<std::vector<Parser_Token>> all;
    std::vector<Parser_Token> some;
    std::set<Token_Name> s;
    
    for (auto const& it: tokens){
        if (Exists_In_Set(s,it.token.name)){
          all.push_back(some);
          some.clear();
          s.clear();
          
          //then add the one we just found
          some.push_back(it);
          Add_To_Set(s,it.token.name);
        }
        else{
          some.push_back(it);
          Add_To_Set(s,it.token.name);
        }
    }
    
  if (!some.empty()){
    all.push_back(some);
  }
    
    return all;
❱





















//utilities for stream of parser tokens
◀public: static▶ std::wstring ☀Get_Value_Of_Token_Name(std::vector<Parser_Token> const& tokens, Token_Name token_name)❰
    std::wstring content;
    
    for (auto i: tokens){
        if (i.token.name == token_name){
            content = i.content;
            break;
        }
    }
    
    return content;
❱
◀public: static▶ std::vector<std::wstring> ☀Get_Values_Of_Token_Name(std::vector<Parser_Token> const& tokens, Token_Name token_name)❰
    std::vector<std::wstring> contents;
    
    for (auto i: tokens){
        if (i.token.name == token_name){
            contents.push_back(i.content);
        }
    }
    
    return contents;
❱



