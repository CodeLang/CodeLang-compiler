class
❪"systems"❫
❪"utilities"❫
❪"CodeLang_structure"❫
❪"parser_token"❫

//sections
❪"meta_section"❫
❪"import_section"❫
❪"namespace_section"❫
❪"inheritance_section"❫
❪"method_section"❫
❪"data_member_section"❫

//items of sections
❪"import_item"❫
❪"namespace_item"❫
❪"inheritance_item"❫
❪"method_item"❫
❪"data_member_item"❫
⚯

//state specifiers

⚞⚟

//turn the entire stream of tokens into a CodeLang data structure
◀public: static▶ CodeLang_Structure ☀Create_Code_Object_From_Token_Stream(std::vector<Parser_Token> const& tokens, std::string const& path_to_file)❰
    CodeLang_Structure code;
    
    //the overall structure of any CodeLang file
    code.meta         = Parse_Out_Meta_Section(tokens);
    code.imports      = Parse_Out_Import_Section(tokens);
    code.namespaces   = Parse_Out_Namespace_Section(tokens);
    code.inheritance  = Parse_Out_Inheritance_Section(tokens);
    code.methods      = Parse_Out_Method_Section(tokens);
    code.data_members = Parse_Out_Data_Member_Section(tokens);
    
    //set the file name that the code structure was derived from
    code.name = As_Removed_Suffix(Get_File_Name_From_File_Path(path_to_file));
    
    return code;
❱

//root setters
◀public: static▶ Meta_Section ☀Parse_Out_Meta_Section(std::vector<Parser_Token> const& tokens)❰
    Meta_Section section;
    
    //singles
    section.code_type            = Get_Value_Of_Token_Name(tokens, "meta-data-code-type");
    section.brief_description    = Get_Value_Of_Token_Name(tokens, "meta-data-brief-description");
    section.detailed_description = Get_Value_Of_Token_Name(tokens, "meta-data-detailed-description");
    
    //multiple instances
    section.group_names = Get_Values_Of_Token_Name(tokens, "meta-data-group-name");
    section.authors     = Get_Values_Of_Token_Name(tokens, "meta-data-author");
    section.bugs        = Get_Values_Of_Token_Name(tokens, "meta-data-bug");
    section.warnings    = Get_Values_Of_Token_Name(tokens, "meta-data-warning");
    
    return section;
❱
◀public: static▶ Import_Section ☀Parse_Out_Import_Section(std::vector<Parser_Token> const& tokens)❰
    Import_Section section;
    
    section.interface_dependencies      = Strip_Out_Interface_Imports(tokens);
    section.implementation_dependencies = Strip_Out_Implementation_Imports(tokens);
    
    return section;
❱
◀public: static▶ Namespace_Section ☀Parse_Out_Namespace_Section(std::vector<Parser_Token> const& tokens)❰
    Namespace_Section section;
    
    section.namespaces = Strip_Out_Namespaces(tokens);
    
    return section;
❱
◀public: static▶ Inheritance_Section ☀Parse_Out_Inheritance_Section(std::vector<Parser_Token> const& tokens)❰
    Inheritance_Section section;
    
    section.inherited_objects = Strip_Out_Inheritances(tokens);
    
    return section;
❱
◀public: static▶ Method_Section ☀Parse_Out_Method_Section(std::vector<Parser_Token> const& tokens)❰
    Method_Section section;
    
    section.methods = Strip_Out_Methods(tokens);
    
    return section;
❱
◀public: static▶ Data_Member_Section ☀Parse_Out_Data_Member_Section(std::vector<Parser_Token> const& tokens)❰
    Data_Member_Section section;
    
    section.data_members = Strip_Out_Data_Members(tokens);
    
    return section;
❱


//sub strippers
◀public: static▶ std::vector<Import_Item> ☀Strip_Out_Interface_Imports(std::vector<Parser_Token> const& tokens)❰
    return Strip_Out_Import_Type(tokens,"import-interface");
❱
◀public: static▶ std::vector<Import_Item> ☀Strip_Out_Implementation_Imports(std::vector<Parser_Token> const& tokens)❰
    return Strip_Out_Import_Type(tokens,"import-implementation");
❱

◀public: static▶ std::vector<Import_Item> ☀Strip_Out_Import_Type(std::vector<Parser_Token> const& tokens, std::string const& import_type)❰

    auto import_related = Filter_Out_Just_Import_Related_Tokens(tokens);
    
    std::vector<Import_Item> return_items;
    Import_Item item;
    bool last_saw = false;
    
    for (it: import_related){
        
        //import line
        if(it.token.name == "import-implementation" || it.token.name == "import-interface"){
            
            if (last_saw){
                Add_Import_Item_To_List(return_items,item);
                item.comment.clear();
            }
            
            if (it.token.name != import_type){
                last_saw = false;
            }
            else{
                last_saw = true;
                item.name = it.content;
            }
        }
        
        //comment line
        else if(it.token.name == "import-comment"){
            if (last_saw){
                item.comment = it.content;
                Add_Import_Item_To_List(return_items,item);
                item.comment.clear();
                last_saw = false;
            }
        }
    }
    
    if (last_saw){
        Add_Import_Item_To_List(return_items,item);
    }
    
    return return_items;
❱

◀public: static▶ void ☀Add_Import_Item_To_List(std::vector<Import_Item> & imports, Import_Item item)❰
    if (item.name.front() == L'"' && item.name.back() == L'"'){
        item.system = false;
        
        //remove the quotes
        item.name.pop_back();
        if (item.name.size() > 0){
            item.name.erase(0,1);
        }
    }
    imports.push_back(item);
    
❱



◀public: static▶ std::vector<Namespace_Item> ☀Strip_Out_Namespaces(std::vector<Parser_Token> const& tokens)❰
    std::vector<Namespace_Item> items;
    //not important right now..
    return items;
❱
◀public: static▶ std::vector<Inheritance_Item> ☀Strip_Out_Inheritances(std::vector<Parser_Token> const& tokens)❰
    std::vector<Inheritance_Item> items;
    //not important right now..
    return items;
❱
◀public: static▶ std::vector<Method_Item> ☀Strip_Out_Methods(std::vector<Parser_Token> const& tokens)❰
    std::vector<Method_Item> items;
    
    auto new_tokens = Filter_Out_Method_Related_Tokens(tokens);
    
    return items;
❱
◀public: static▶ std::vector<Data_Member_Item> ☀Strip_Out_Data_Members(std::vector<Parser_Token> const& tokens)❰
    std::vector<Data_Member_Item> items;
    
    auto new_tokens = Filter_Out_Just_Data_Member_Related_Tokens(tokens);
    
    return items;
❱




//parser token filters
◀public: static▶ std::vector<Parser_Token> ☀Filter_Out_Just_Import_Related_Tokens(std::vector<Parser_Token> const& tokens)❰

    //filter
    std::vector<Parser_Token> new_tokens;
    for (it: tokens){
        if (it.token.name == "import-interface"){
            new_tokens.push_back(it);
        }
        else if(it.token.name == "import-implementation"){
            new_tokens.push_back(it);
        }
        else if(it.token.name == "import-comment"){
            new_tokens.push_back(it);
        }
    }
    return new_tokens;
❱

◀public: static▶ std::vector<Parser_Token> ☀Filter_Out_Method_Related_Tokens(std::vector<Parser_Token> const& tokens)❰

    //filter
    std::vector<Parser_Token> new_tokens;
    for (it: tokens){
        if     (it.token.name == "function-class-specifiers")             {new_tokens.push_back(it);}
        else if(it.token.name == "function-attributes")                   {new_tokens.push_back(it);}
        else if(it.token.name == "function-operation-category")           {new_tokens.push_back(it);}
        else if(it.token.name == "function-name")                         {new_tokens.push_back(it);}
        else if(it.token.name == "function-brief-description")            {new_tokens.push_back(it);}
        else if(it.token.name == "function-detailed-description")         {new_tokens.push_back(it);}
        else if(it.token.name == "function-template-argument-type")       {new_tokens.push_back(it);}
        else if(it.token.name == "function-template-argument-identifier") {new_tokens.push_back(it);}
        else if(it.token.name == "function-template-argument-default")    {new_tokens.push_back(it);}
        else if(it.token.name == "function-template-argument-comment")    {new_tokens.push_back(it);}
        else if(it.token.name == "function-argument-type-qualifiers")     {new_tokens.push_back(it);}
        else if(it.token.name == "function-argument-type")                {new_tokens.push_back(it);}
        else if(it.token.name == "function-argument-identifier")          {new_tokens.push_back(it);}
        else if(it.token.name == "function-argument-default")             {new_tokens.push_back(it);}
        else if(it.token.name == "function-argument-comment")             {new_tokens.push_back(it);}
        else if(it.token.name == "function-result-type-qualifiers")       {new_tokens.push_back(it);}
        else if(it.token.name == "function-result-type")                  {new_tokens.push_back(it);}
        else if(it.token.name == "function-result-identifier")            {new_tokens.push_back(it);}
        else if(it.token.name == "function-result-comment")               {new_tokens.push_back(it);}
        else if(it.token.name == "except-expression")                     {new_tokens.push_back(it);}
        else if(it.token.name == "except-comment")                        {new_tokens.push_back(it);}
        else if(it.token.name == "function-body")                         {new_tokens.push_back(it);}
    }
    return new_tokens;
❱

◀public: static▶ std::vector<Parser_Token> ☀Filter_Out_Just_Data_Member_Related_Tokens(std::vector<Parser_Token> const& tokens)❰

    //filter
    std::vector<Parser_Token> new_tokens;
    for (it: tokens){
        if     (it.token.name == "data-member-class-specifiers") {new_tokens.push_back(it);}
        else if(it.token.name == "data-member-type-qualifiers")  {new_tokens.push_back(it);}
        else if(it.token.name == "data-member-type")             {new_tokens.push_back(it);}
        else if(it.token.name == "data-member-identifier")       {new_tokens.push_back(it);}
        else if(it.token.name == "data-member-default-value")    {new_tokens.push_back(it);}
        else if(it.token.name == "data-member-brief")            {new_tokens.push_back(it);}
        else if(it.token.name == "data-member-detailed")         {new_tokens.push_back(it);}
        else if(it.token.name == "data-state-specifier")         {new_tokens.push_back(it);}
    }
    return new_tokens;
❱


//utilities for stream of parser tokens
◀public: static▶ std::wstring ☀Get_Value_Of_Token_Name(std::vector<Parser_Token> const& tokens, std::string token_name)❰
    std::wstring content;
    
    for (auto i: tokens){
        if (i.token.name == token_name){
            content = i.content;
            break;
        }
    }
    
    return content;
❱
◀public: static▶ std::vector<std::wstring> ☀Get_Values_Of_Token_Name(std::vector<Parser_Token> const& tokens, std::string token_name)❰
    std::vector<std::wstring> contents;
    
    for (auto i: tokens){
        if (i.token.name == token_name){
            contents.push_back(i.content);
        }
    }
    
    return contents;
❱



