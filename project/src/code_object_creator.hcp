class
❪"systems"❫
❪"utilities"❫
❪"CodeLang_structure"❫
❪"parser_token"❫

//sections
❪"meta_section"❫
❪"import_section"❫
❪"namespace_section"❫
❪"inheritance_section"❫
❪"method_section"❫
❪"data_member_section"❫

//items of sections
❪"import_item"❫
❪"namespace_item"❫
❪"inheritance_item"❫
❪"method_item"❫
❪"data_member_item"❫
❪"token_group"❫
❪"template_argument"❫
❪"function_result"❫
❪"function_argument"❫

❪"token_value"❫

❪"body_token_parser"❫
⚯

⚞⚟

//turn the entire stream of tokens into a CodeLang data structure
◀public: static▶ CodeLang_Structure ☀Create_Code_Object_From_Token_Stream(std::vector<Parser_Token> const& tokens, std::string const& path_to_file)❰
    CodeLang_Structure code;
    
    //the overall structure of any CodeLang file
    
    //meta section
    
        //singles
        code.meta.code_type            = Get_Token_Value_Of_Token_Name(tokens, Token_Name::META_DATA_CODE_TYPE);
        code.meta.brief_description    = Get_Token_Value_Of_Token_Name(tokens, Token_Name::META_DATA_BRIEF_DESCRIPTION);
        code.meta.detailed_description = Get_Token_Value_Of_Token_Name(tokens, Token_Name::META_DATA_DETAILED_DESCRIPTION);
        
        //multiple instances
        code.meta.group_names = Get_Token_Values_Of_Token_Name(tokens, Token_Name::META_DATA_GROUP_NAME);
        code.meta.authors     = Get_Token_Values_Of_Token_Name(tokens, Token_Name::META_DATA_AUTHOR);
        code.meta.bugs        = Get_Token_Values_Of_Token_Name(tokens, Token_Name::META_DATA_BUG);
        code.meta.warnings    = Get_Token_Values_Of_Token_Name(tokens, Token_Name::META_DATA_WARNING);

    //import section
    code.imports.interface_dependencies      = Strip_Out_Import_Type(tokens,Token_Name::IMPORT_INTERFACE);
    code.imports.implementation_dependencies = Strip_Out_Import_Type(tokens,Token_Name::IMPORT_IMPLEMENTATION);
    
    //other sections
    code.macros.macros       = Strip_Out_Macros(tokens);
    code.namespaces.namespaces   = Strip_Out_Namespaces(tokens);
    code.inheritance.inherited_objects  = Strip_Out_Inheritance_Section(tokens);
    code.methods.methods      = Strip_Out_Methods(tokens);
    code.data_members.data_members = Strip_Out_Data_Members(tokens);
    code.enums.enumerated_types        = Strip_Out_Enumerated_Types(tokens);
    
    //set the file name that the code structure was derived from
    code.name = As_Removed_Suffix(Get_File_Name_From_File_Path(path_to_file));
    return code;
❱

//sub strippers
◀public: static▶ std::vector<Import_Item> ☀Strip_Out_Import_Type(std::vector<Parser_Token> const& tokens, Token_Name const& import_type)❰

    auto import_related = Filter_Out_Tokens_By_Group_Name(tokens,Token_Group::IMPORT);
    
    std::vector<Import_Item> return_items;
    Import_Item item;
    bool last_saw = false;
    
    for (it: import_related){
        
        //import line
        if(it.token.name == Token_Name::IMPORT_IMPLEMENTATION || it.token.name == Token_Name::IMPORT_INTERFACE){
            
            if (last_saw){
                item.name.location = it.location;
                Add_Import_Item_To_List(return_items,item);
                item.comment.value.clear();
            }
            
            if (it.token.name != import_type){
                last_saw = false;
            }
            else{
                last_saw = true;
                item.name.value = it.content;
            }
        }
        
        //comment line
        else if(it.token.name == Token_Name::IMPORT_COMMENT){
            if (last_saw){
                item.comment.value = it.content;
                item.comment.location = it.location;
                Add_Import_Item_To_List(return_items,item);
                item.comment.value.clear();
                last_saw = false;
            }
        }
    }
    
    if (last_saw){
        Add_Import_Item_To_List(return_items,item);
    }
    
    return return_items;
❱
◀public: static▶ void ☀Add_Import_Item_To_List(std::vector<Import_Item> & imports, Import_Item item)❰


    //decide if its a system or a local header
    if (item.name.value.front() == L'/'){
        item.system = true;
        item.name.value.erase(0,1);
    }
    else{
        item.system = false;
    }
    
    imports.push_back(item);
❱
◀public: static▶ std::vector<Namespace_Item> ☀Strip_Out_Namespaces(std::vector<Parser_Token> const& tokens)❰
    std::vector<Namespace_Item> items;
    //not important right now..
    return items;
❱
◀public: static▶ std::vector<Macro_Item> ☀Strip_Out_Macros(std::vector<Parser_Token> const& tokens)❰
    std::vector<Macro_Item> items;
    auto new_tokens = Filter_Out_Tokens_By_Group_Name(tokens,Token_Group::MACRO);
    items = Get_Macro_Items(new_tokens);
    return items;
❱
◀public: static▶ std::vector<Inheritance_Item> ☀Strip_Out_Inheritance_Section(std::vector<Parser_Token> const& tokens)❰
    std::vector<Inheritance_Item> section;
    
    return section;
❱

◀public: static▶ std::vector<Enum_Item> ☀Strip_Out_Enumerated_Types(std::vector<Parser_Token> const& tokens)❰
    std::vector<Enum_Item> items;
    auto new_tokens = Filter_Out_Tokens_By_Group_Name(tokens,Token_Group::ENUM);
    auto split = Filter_Enum_Chunks(new_tokens);
    for (auto it: split){
        items.push_back(Build_Enum_Item(it));
    }
    return items;
❱
◀public: static▶ std::vector<Method_Item> ☀Strip_Out_Methods(std::vector<Parser_Token> const& tokens)❰
    std::vector<Method_Item> items;
    
    auto new_tokens = Filter_Out_Tokens_By_Group_Name(tokens,Token_Group::FUNCTION);
    auto split =  Filter_Method_Chunks(new_tokens);
    for(auto it: split){
        items.push_back(Build_Method_Item(it));
    }
    
    return items;
❱




//builders
◀public: static▶ Enum_Item ☀Build_Enum_Item(std::vector<Parser_Token> const& tokens)❰
    Enum_Item item;
    
    //get out singles
    auto name = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::ENUM_NAME);
    for (auto it: name){ Set_Token_Value_From_Parser_Token(item.name,it);}
        
    auto brief = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::ENUM_BRIEF);
    for (auto it: brief){Set_Token_Value_From_Parser_Token(item.brief,it);}
    
    auto detail = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::ENUM_DETAIL);
    for (auto it: detail){Set_Token_Value_From_Parser_Token(item.detail,it);}
        
    auto base_type = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::ENUM_BASE_TYPE);
    for (auto it: base_type){Set_Token_Value_From_Parser_Token(item.base_type,it);}
        
    auto specifiers = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::ENUM_SPECIFIERS);
    for (auto it: specifiers){
        
        //apply specifiers
        if (Contains(it.content,L'i')){item.is_iterable = true;}
    }
    
    
    
    //get out multiples
    auto args = Get_Enum_Args(Filter_Out_Tokens_By_Group(tokens,Token_Group::ENUM_ARG));
    
    //set them all
    item.args = args;
    
    
        
    return item;
❱

◀public: static▶ Method_Item ☀Build_Method_Item(std::vector<Parser_Token> const& tokens)❰
    Method_Item item;
    
    //get out singles
    auto class_specifiers = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::FUNCTION_CLASS_SPECIFIERS);
    auto attributes = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::FUNCTION_ATTRIBUTES);
    auto categories = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::FUNCTION_OPERATION_CATEGORY);
    auto name = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::FUNCTION_NAME);
    auto brief = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::FUNCTION_BRIEF_DESCRIPTION);
    auto detailed = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::FUNCTION_DETAILED_DESCRIPTION);
    auto exception = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::EXCEPT_EXPRESSION);
    auto exception_comment = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::EXCEPT_COMMENT);
    auto function_body = Filter_Out_Tokens_By_Token_Name(tokens,Token_Name::FUNCTION_BODY);
    
    //get out multiples
    auto template_args = Get_Template_Args(Filter_Out_Tokens_By_Group(tokens,Token_Group::FUNCTION_TEMPLATE_ARGUMENT));
    auto function_args = Get_Function_Args(Filter_Out_Tokens_By_Group(tokens,Token_Group::FUNCTION_ARGUMENT));
    auto return_results = Get_Return_Results(Filter_Out_Tokens_By_Group(tokens,Token_Group::FUNCTION_RESULT));
    
    //set them all
    item.template_arguments = template_args;
    item.function_arguments = function_args;
    item.return_results     = return_results;
    
    
    for (auto it: class_specifiers){
        
        //set value lvalue / rvalue overload
             if (Contains(it.content,L'l')){item.value_overload = Value_Overload::LVALUE;}
        else if (Contains(it.content,L'r')){item.value_overload = Value_Overload::RVALUE;}
        else {item.value_overload = Value_Overload::NONE;}
        
        //set the class accessor
             if (Contains(it.content,L'+')){item.class_access = Class_Access::PUBLIC;}
        else if (Contains(it.content,L'#')){item.class_access = Class_Access::PROTECTED;}
        else if (Contains(it.content,L'-')){item.class_access = Class_Access::PRIVATE;}
        
        //set other specific things related to methods
        if (Contains(it.content,L's')){item.is_static = true;}else{item.is_static = false;}
        if (Contains(it.content,L'c')){item.is_const = true;}else{item.is_const = false;}
        if (Contains(it.content,L'v')){item.is_virtual = true;}else{item.is_virtual = false;}
    }
    
    
    for (auto it: attributes){
        Token_Value t;
        Set_Token_Value_From_Parser_Token(t,it);
        item.attributes.push_back(t);
    }
    for (auto it: name)      {
        Set_Token_Value_From_Parser_Token(item.function_name,it);
    }
    for (auto it: brief){
        Set_Token_Value_From_Parser_Token(item.brief_description,it);
    }
    for (auto it: detailed){
        Set_Token_Value_From_Parser_Token(item.detailed_description,it);
    }
    for (auto it: exception){
        Set_Token_Value_From_Parser_Token(item.exception_expression,it);
    }
    for (auto it: exception_comment){
        Set_Token_Value_From_Parser_Token(item.exception_comment,it);
    }
    for (auto it: function_body){
        item.body = Body_Token_Parser::Parse_Method_Body_Into_Stream_Of_Tokens(it.content);
    }
    
    
    
    return item;
❱
◀public: static▶ std::vector<Macro_Item> ☀Get_Macro_Items(std::vector<Parser_Token> const& tokens)❰
    std::vector<Macro_Item> all;
    Macro_Item t;
    auto splits = Filter_By_Data_Member_Uniqueness(tokens);
    for (auto x : splits){
        t = Macro_Item{};
        for (auto y : x){
            if      (y.token.name == Token_Name::MACRO_NAME)      {
                t.name.value = y.content;
                t.name.location = y.location;
            }
            else if (y.token.name == Token_Name::MACRO_BRIEF)     {
                t.brief.value = y.content;
                t.brief.location = y.location;
            }
            else if (y.token.name == Token_Name::MACRO_DETAIL)    {
                t.detail.value = y.content;
                t.detail.location = y.location;
            }
            else if (y.token.name == Token_Name::MACRO_VALUE)     {
                t.value.value = y.content;
                t.value.location = y.location;
            }
        }
        all.push_back(t);
    }
    
    
    return all;
❱


◀public: static▶ void ☀Set_Token_Value_From_Parser_Token(Token_Value & token_value, Parser_Token const& parser_token)❰
    token_value.value = parser_token.content;
    token_value.location = parser_token.location;
    token_value.name = parser_token.token.name;
❱



◀public: static▶ std::vector<Template_Argument> ☀Get_Template_Args(std::vector<Parser_Token> const& tokens)❰
    std::vector<Template_Argument> all;
    Template_Argument t;
    auto splits = Filter_By_Data_Member_Uniqueness(tokens);
    for (auto x : splits){
        t = Template_Argument{};
        for (auto y : x){
            if (y.token.name == Token_Name::FUNCTION_TEMPLATE_ARGUMENT_TYPE)      {
                Set_Token_Value_From_Parser_Token(t.type,y);
            }
            else if (y.token.name == Token_Name::FUNCTION_TEMPLATE_ARGUMENT_IDENTIFIER){
                Set_Token_Value_From_Parser_Token(t.identifier,y);
            }
            else if (y.token.name == Token_Name::FUNCTION_TEMPLATE_ARGUMENT_DEFAULT)   {
                Set_Token_Value_From_Parser_Token(t.default_value,y);
            }
            else if (y.token.name == Token_Name::FUNCTION_TEMPLATE_ARGUMENT_COMMENT)   {
                Set_Token_Value_From_Parser_Token(t.comment,y);
            }
        }
        all.push_back(t);
    }
    
    
    return all;
❱
◀public: static▶ std::vector<Function_Argument> ☀Get_Function_Args(std::vector<Parser_Token> const& tokens)❰
    std::vector<Function_Argument> all;
    Function_Argument t;
    auto splits = Filter_By_Data_Member_Uniqueness(tokens);
    for (auto x : splits){
        t = Function_Argument{};
        for (auto y : x){
            if      (y.token.name == Token_Name::FUNCTION_ARGUMENT_TYPE_QUALIFIERS) {
                t.is_const = Contains(y.content,L'c');
            }
            else if (y.token.name == Token_Name::FUNCTION_ARGUMENT_TYPE)            {
                Set_Token_Value_From_Parser_Token(t.type,y);
            }
            else if (y.token.name == Token_Name::FUNCTION_ARGUMENT_IDENTIFIER)      {
                Set_Token_Value_From_Parser_Token(t.identifier,y);
            }
            else if (y.token.name == Token_Name::FUNCTION_ARGUMENT_DEFAULT)         {
                Set_Token_Value_From_Parser_Token(t.default_value,y);
            }
            else if (y.token.name == Token_Name::FUNCTION_ARGUMENT_COMMENT)         {
                Set_Token_Value_From_Parser_Token(t.comment,y);
            }
        }

        all.push_back(t);
    }
    
    return all;
❱
◀public: static▶ std::vector<Function_Result>    ☀Get_Return_Results(std::vector<Parser_Token> const& tokens)❰
    std::vector<Function_Result> all;
    Function_Result t;
    auto splits = Filter_By_Data_Member_Uniqueness(tokens);
    for (auto x : splits){
        t = Function_Result{};
        for (auto y : x){
            if      (y.token.name == Token_Name::FUNCTION_RESULT_TYPE_QUALIFIERS) {
                t.is_const = Contains(y.content,L'c');
            }
            else if (y.token.name == Token_Name::FUNCTION_RESULT_TYPE)            {
                Set_Token_Value_From_Parser_Token(t.type,y);
            }
            else if (y.token.name == Token_Name::FUNCTION_RESULT_IDENTIFIER)      {
                Set_Token_Value_From_Parser_Token(t.identifier,y);
            }
            else if (y.token.name == Token_Name::FUNCTION_RESULT_COMMENT)         {
                Set_Token_Value_From_Parser_Token(t.comment,y);
            }
        }
        all.push_back(t);
    }
    
    return all;
❱
◀public: static▶ std::vector<Enum_Arg>    ☀Get_Enum_Args(std::vector<Parser_Token> const& tokens)❰
    std::vector<Enum_Arg> all;
    Enum_Arg t;
    auto splits = Filter_By_Data_Member_Uniqueness(tokens);
    for (auto x : splits){
        t = Enum_Arg{};
        for (auto y : x){
            if      (y.token.name == Token_Name::ENUM_ARG_NAME)      {
                t.name.value = y.content;
                t.name.location = y.location;
            }
            else if (y.token.name == Token_Name::ENUM_ARG_VALUE)     {
                t.value.value = y.content;
                t.value.location = y.location;
            }
            else if (y.token.name == Token_Name::ENUM_ARG_COMMENT)   {
                t.comment.value = y.content;
                t.comment.location = y.location;
            }
        }
        all.push_back(t);
    }
    
    
    return all;
❱


◀public: static▶ std::vector<std::vector<Parser_Token>> ☀Filter_Method_Chunks(std::vector<Parser_Token> const& tokens)❰
    std::vector<std::vector<Parser_Token>> all;
    std::vector<Parser_Token> some;
    
    for (it: tokens){
        some.push_back(it);
        if (In_Vector(it.token.groups,Token_Group::FUNCTION_BODY)){
            all.push_back(some);
            some.clear();
        }
    }
    
    return all;
❱
◀public: static▶ std::vector<std::vector<Parser_Token>> ☀Filter_Enum_Chunks(std::vector<Parser_Token> const& tokens)❰
    
    //for now, assume only one enum per file
    std::vector<std::vector<Parser_Token>> all;
    std::vector<Parser_Token> some;
    std::set<Token_Name> seen;
    
    for (auto it: tokens){
        
        //one of the base enum tokens
        if (!Contains(it.token.groups,Token_Group::ENUM_ARG)){
            
            //new value found
            if (!Exists_In_Set(seen,it.token.name)){
                Add_To_Set(seen,it.token.name);
            }
            
            //non-new value send.
            else{
                seen.clear();
                Add_To_Set(seen,it.token.name);
                all.push_back(some);
                some.clear();
            }
            some.push_back(it);
        }
        
        
        //one of the enum value types
        else{
            some.push_back(it);
        }
        
    }
    
    
    
    if (!some.empty()){
        all.push_back(some);
    }
    
    return all;
❱

◀public: static▶ std::vector<std::vector<Parser_Token>> ☀Filter_Macro_Chunks(std::vector<Parser_Token> const& tokens)❰
    std::vector<std::vector<Parser_Token>> all;
    std::vector<Parser_Token> some;
    
    return all;
❱







◀public: static▶ std::vector<Data_Member_Item> ☀Strip_Out_Data_Members(std::vector<Parser_Token> const& tokens)❰
    std::vector<Data_Member_Item> all;
    
    auto new_tokens = Filter_Out_Tokens_By_Group_Name(tokens,Token_Group::DATA_MEMBER);
    auto split =  Filter_By_Data_Member_Uniqueness(new_tokens);
    for(auto it: split){
        all.push_back(Build_Data_Member_Item(it));
    }
    
    return all;
❱

◀public: static▶ Data_Member_Item ☀Build_Data_Member_Item(std::vector<Parser_Token> const& tokens)❰
    
    Data_Member_Item item;
    for (auto it: tokens){
        
        //handle class accessors
        if(it.token.name == Token_Name::DATA_MEMBER_CLASS_SPECIFIERS) {
                 if (Contains(it.content,L'+')){item.class_access = Class_Access::PUBLIC;}
            else if (Contains(it.content,L'#')){item.class_access = Class_Access::PROTECTED;}
            else if (Contains(it.content,L'-')){item.class_access = Class_Access::PRIVATE;}
        }
        
        //handle other qualifiers
        else if (it.token.name == Token_Name::DATA_MEMBER_TYPE_QUALIFIERS)  {
            
            if (Contains(it.content,L's')){item.storage = Storage_Specifier::STATIC;}
            else if (Contains(it.content,L'e')){item.storage = Storage_Specifier::EXTERN;}
            else {item.storage = Storage_Specifier::NONE;}
            if (Contains(it.content,L'c')){item.is_const = true;}else{item.is_const = false;}
        }
        
        //handle singles
        else if (it.token.name == Token_Name::DATA_MEMBER_TYPE)             {
            item.type.value = it.content;
            item.type.location = it.location;
        }
        else if (it.token.name == Token_Name::DATA_MEMBER_IDENTIFIER)       {
            item.name.value = it.content;
            item.name.location = it.location;
        }
        else if (it.token.name == Token_Name::DATA_MEMBER_DEFAULT_VALUE)    {
            item.default_value.value = it.content;
            item.default_value.location = it.location;
        }
        else if (it.token.name == Token_Name::DATA_MEMBER_BRIEF)            {
            item.brief.value = it.content;
            item.brief.location = it.location;
        }
        else if (it.token.name == Token_Name::DATA_MEMBER_DETAILED)         {
            item.detail.value = it.content;
            item.detail.location = it.location;
        }
        
        
        
        
        else if (it.token.name == Token_Name::DATA_MEMBER_STATE_SPECIFIER)  {
            auto str = as_string(it.content);
            if (str == "observe"){ item.is_observable = true;}
            if (str == "inject"){ item.is_injectable = true;}
            if (str == "obtain"){ item.is_obtainable = true;}
        }

    }
    
    
    return item;
❱




//filtering stream of parse tokens
◀public: static▶ std::vector<Parser_Token> ☀Filter_Out_Tokens_By_Token_Name(std::vector<Parser_Token> const& tokens, Token_Name name)❰
    std::vector<Parser_Token> new_tokens;
    for (it: tokens){
        if(it.token.name == name) {new_tokens.push_back(it);}
    }
    return new_tokens;
❱
◀public: static▶ std::vector<Parser_Token> ☀Filter_Out_Tokens_By_Group_Name(std::vector<Parser_Token> const& tokens, Token_Group group_name)❰
    std::vector<Parser_Token> new_tokens;
    for (it: tokens){
        if(In_Vector(it.token.groups,group_name)){new_tokens.push_back(it);}
    }
    return new_tokens;
❱







◀public: static▶ std::vector<Parser_Token> ☀Filter_Out_Tokens_By_Group(std::vector<Parser_Token> const& tokens, Token_Group name)❰

    //filter
    std::vector<Parser_Token> new_tokens;
    for (it: tokens){
        for (y: it.token.groups){
            if(y == name) {new_tokens.push_back(it);}
        }
    }
    return new_tokens;
❱


◀public: static▶ std::vector<std::vector<Parser_Token>> ☀Filter_By_Data_Member_Uniqueness(std::vector<Parser_Token> const& tokens)❰
    std::vector<std::vector<Parser_Token>> all;
    std::vector<Parser_Token> some;
    std::set<Token_Name> s;
    
    for (auto const& it: tokens){
        if (Exists_In_Set(s,it.token.name)){
          all.push_back(some);
          some.clear();
          s.clear();
          
          //then add the one we just found
          some.push_back(it);
          Add_To_Set(s,it.token.name);
        }
        else{
          some.push_back(it);
          Add_To_Set(s,it.token.name);
        }
    }
    
  if (!some.empty()){
    all.push_back(some);
  }
    
    return all;
❱










◀public: static▶ Token_Value ☀Get_Token_Value_Of_Token_Name(std::vector<Parser_Token> const& tokens, Token_Name token_name)❰
    Token_Value t;
    
    for (auto i: tokens){
        if (i.token.name == token_name){
            t.value = i.content;
            t.location = i.location;
            break;
        }
    }
    
    return t;
❱
◀public: static▶ std::vector<Token_Value> ☀Get_Token_Values_Of_Token_Name(std::vector<Parser_Token> const& tokens, Token_Name token_name)❰
    std::vector<Token_Value> t;
    
    for (auto i: tokens){
        if (i.token.name == token_name){
            Token_Value yo;
            yo.value = i.content;
            yo.location = i.location;
            t.push_back(yo);
        }
    }
    
    return t;
❱










//utilities for stream of parser tokens
◀public: static▶ std::wstring ☀Get_Value_Of_Token_Name(std::vector<Parser_Token> const& tokens, Token_Name token_name)❰
    std::wstring content;
    
    for (auto i: tokens){
        if (i.token.name == token_name){
            content = i.content;
            break;
        }
    }
    
    return content;
❱
◀public: static▶ std::vector<std::wstring> ☀Get_Values_Of_Token_Name(std::vector<Parser_Token> const& tokens, Token_Name token_name)❰
    std::vector<std::wstring> contents;
    
    for (auto i: tokens){
        if (i.token.name == token_name){
            contents.push_back(i.content);
        }
    }
    
    return contents;
❱



