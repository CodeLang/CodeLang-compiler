class
❪"systems"❫
❪"utilities"❫
❪"CodeLang_structure"❫
❪"parser_token"❫

//sections
❪"meta_section"❫
❪"import_section"❫
❪"namespace_section"❫
❪"inheritance_section"❫
❪"method_section"❫
❪"data_member_section"❫

//items of sections
❪"import_item"❫
❪"namespace_item"❫
❪"inheritance_item"❫
❪"method_item"❫
❪"data_member_item"❫
⚯

⚞⚟

//turn the entire stream of tokens into a CodeLang data structure
◀public: static▶ CodeLang_Structure ☀Create_Code_Object_From_Token_Stream(std::vector<Parser_Token> const& tokens, std::string const& path_to_file)❰
    CodeLang_Structure code;
    
    //the overall structure of any CodeLang file
    code.meta         = Parse_Out_Meta_Section(tokens);
    code.imports      = Parse_Out_Import_Section(tokens);
    code.namespaces   = Parse_Out_Namespace_Section(tokens);
    code.inheritance  = Parse_Out_Inheritance_Section(tokens);
    code.methods      = Parse_Out_Method_Section(tokens);
    code.data_members = Parse_Out_Data_Member_Section(tokens);
    
    //set the file name that the code structure was derived from
    code.name = As_Removed_Suffix(Get_File_Name_From_File_Path(path_to_file));
    
    return code;
❱

//root setters
◀public: static▶ Meta_Section ☀Parse_Out_Meta_Section(std::vector<Parser_Token> const& tokens)❰
    Meta_Section section;
    
    //singles
    section.code_type            = Get_Value_Of_Token_Name(tokens, "meta-data-code-type");
    section.brief_description    = Get_Value_Of_Token_Name(tokens, "meta-data-brief-description");
    section.detailed_description = Get_Value_Of_Token_Name(tokens, "meta-data-detailed-description");
    
    //multiple instances
    section.group_names = Get_Values_Of_Token_Name(tokens, "meta-data-group-name");
    section.authors     = Get_Values_Of_Token_Name(tokens, "meta-data-author");
    section.bugs        = Get_Values_Of_Token_Name(tokens, "meta-data-bug");
    section.warnings    = Get_Values_Of_Token_Name(tokens, "meta-data-warning");
    
    return section;
❱
◀public: static▶ Import_Section ☀Parse_Out_Import_Section(std::vector<Parser_Token> const& tokens)❰
    Import_Section section;
    
    section.interface_dependencies      = Strip_Out_Interface_Imports(tokens);
    section.implementation_dependencies = Strip_Out_Implementation_Imports(tokens);
    
    return section;
❱
◀public: static▶ Namespace_Section ☀Parse_Out_Namespace_Section(std::vector<Parser_Token> const& tokens)❰
    Namespace_Section section;
    
    section.namespaces = Strip_Out_Namespaces(tokens);
    
    return section;
❱
◀public: static▶ Inheritance_Section ☀Parse_Out_Inheritance_Section(std::vector<Parser_Token> const& tokens)❰
    Inheritance_Section section;
    
    section.inherited_objects = Strip_Out_Inheritances(tokens);
    
    return section;
❱
◀public: static▶ Method_Section ☀Parse_Out_Method_Section(std::vector<Parser_Token> const& tokens)❰
    Method_Section section;
    
    section.methods = Strip_Out_Methods(tokens);
    
    return section;
❱
◀public: static▶ Data_Member_Section ☀Parse_Out_Data_Member_Section(std::vector<Parser_Token> const& tokens)❰
    Data_Member_Section section;
    
    section.data_members = Strip_Out_Data_Members(tokens);
    
    return section;
❱


//sub strippers
◀public: static▶ std::vector<Import_Item> ☀Strip_Out_Interface_Imports(std::vector<Parser_Token> const& tokens)❰
    std::vector<Import_Item> items;
    
    Import_Item item;
    
    bool hit_import = false;
    for (auto const& token: tokens){
        
        //store the import name when you see it
        if (token.token.name == "import-interface"){
            item.name = token.content;
            hit_import = true;
        }
        
        //the next token has to be a comment, or you don't get it
        else if (hit_import){
            if (token.token.name == "import-comment"){
                item.comment = token.content;
                items.push_back(item);
            }
            hit_import = false;
        }
    }
    
    return items;
❱
◀public: static▶ std::vector<Import_Item> ☀Strip_Out_Implementation_Imports(std::vector<Parser_Token> const& tokens)❰
    std::vector<Import_Item> items;
    
    return items;
❱
◀public: static▶ std::vector<Namespace_Item> ☀Strip_Out_Namespaces(std::vector<Parser_Token> const& tokens)❰
    std::vector<Namespace_Item> items;
    
    return items;
❱
◀public: static▶ std::vector<Inheritance_Item> ☀Strip_Out_Inheritances(std::vector<Parser_Token> const& tokens)❰
    std::vector<Inheritance_Item> items;
    
    return items;
❱
◀public: static▶ std::vector<Method_Item> ☀Strip_Out_Methods(std::vector<Parser_Token> const& tokens)❰
    std::vector<Method_Item> items;
    
    return items;
❱
◀public: static▶ std::vector<Data_Member_Item> ☀Strip_Out_Data_Members(std::vector<Parser_Token> const& tokens)❰
    std::vector<Data_Member_Item> items;
    
    return items;
❱




//utilities for stream of parser tokens
◀public: static▶ std::wstring ☀Get_Value_Of_Token_Name(std::vector<Parser_Token> const& tokens, std::string token_name)❰
    std::wstring content;
    
    for (auto i: tokens){
        if (i.token.name == token_name){
            content = i.content;
            break;
        }
    }
    
    return content;
❱
◀public: static▶ std::vector<std::wstring> ☀Get_Values_Of_Token_Name(std::vector<Parser_Token> const& tokens, std::string token_name)❰
    std::vector<std::wstring> contents;
    
    for (auto i: tokens){
        if (i.token.name == token_name){
            contents.push_back(i.content);
        }
    }
    
    return contents;
❱



