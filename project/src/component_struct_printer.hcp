class
❪"systems"❫
❪"utilities"❫
❪"CodeLang_structure"❫
❪"doxygen_block_printer"❫
❪"type_to_hungarian_notation_converter"❫
❪"component_input"❫
⚯

⚞⚟


//printing f2si objects
◀public: static▶ void ☀Print_Data_Structs(std::wofstream & out, CodeLang_Structure const& structure)❰
    Print_Local_Struct(out,structure);
    Print_Input_Struct(out,structure);
    Print_Output_Struct(out,structure);
❱
◀private: static▶ void ☀Print_Local_Struct(std::wofstream & out, CodeLang_Structure const& structure)❰


    //get all the variables that qualify for locals
    std::vector<Data_Member_Item> locals;
    for (auto it: structure.data_members.data_members){
        if (!it.is_observable && !it.is_obtainable){
            locals.push_back(it);
        }
    }
    
    if (!locals.empty()){
        
        auto dumb_name = As_Capital_And_Pushed_Together(structure.name) + "Locals_t";
        auto used_name = As_Capital_And_Pushed_Together(structure.name) + "LocalsT";
        auto print_name = Capitalize_Each_With_Space_In_Between(structure.name);
        Doxygen_Block_Printer::Print_Block(out,0,print_name + " Locals", "Contains internal state that should not be referenced by the client");
        Print_To_Stream(out,"typedef struct ");
        Print_To_Stream_With_Newline(out,dumb_name);
        Print_To_Stream_With_Newline(out,"{");
        Print_List_Of_Data_Members(out,locals);
        Print_To_Stream(out,"} ");
        Print_To_Stream(out,used_name);
        Print_To_Stream_With_Newline(out,";");
        Print_To_Stream_With_Newline(out,"");
    }
❱

◀private: static▶ void ☀Print_Input_Struct(std::wofstream & out, CodeLang_Structure const& structure)❰
        auto dumb_name = As_Capital_And_Pushed_Together(structure.name) + "Inputs_t";
        auto used_name = As_Capital_And_Pushed_Together(structure.name) + "InputsT";
        auto print_name = Capitalize_Each_With_Space_In_Between(structure.name);
        Doxygen_Block_Printer::Print_Block(out,0,print_name + " Inputs", "All of the conceivable inputs,\nthat may influence the state of the component, \nand potentially change any of the outputs");
        Print_To_Stream(out,"typedef struct ");
        Print_To_Stream_With_Newline(out,dumb_name);
        Print_To_Stream_With_Newline(out,"{");
        Print_Input_Struct_Variables(out,structure);
        Print_To_Stream(out,"} ");
        Print_To_Stream(out,used_name);
        Print_To_Stream_With_Newline(out,";");
        Print_To_Stream_With_Newline(out,"");
❱
◀private: static▶ void ☀Print_Input_Struct_Variables(std::wofstream & out, CodeLang_Structure const& structure)❰

    
    std::vector<Component_Input> inputs;
    
    for (auto it: structure.methods.methods){
        for (x: it.function_arguments){
            if (!Exists(inputs,as_string(x.identifier))){
                Component_Input d;
                d.name = as_string(x.identifier);
                d.from.push_back(as_string(it.function_name));
                d.arg = x;
                inputs.push_back(d);
            }else{
                Find(inputs,as_string(x.identifier)).from.push_back(as_string(it.function_name));
            }
        }
        
    }
    
    //print bools for all of the public methods
    Print_Component_Methods(out,structure.methods.methods);
    
    //print all the input parameters needed for all of the public methods
    Print_Component_Inputs(out,inputs);
❱

◀private: static▶ bool ☀Exists(std::vector<Component_Input> const& inputs, std::string name)❰
    for (auto it: inputs){
        if (it.name == name){
            return true;
        }
    }
    return false;
❱
◀private: static▶ Component_Input& ☀Find(std::vector<Component_Input> & inputs, std::string name)❰
    for (auto & it: inputs){
        if (it.name == name){
            return it;
        }
    }
    return inputs[0];
❱
◀private: static▶ void ☀Print_Output_Struct(std::wofstream & out, CodeLang_Structure const& structure)❰
        auto dumb_name = As_Capital_And_Pushed_Together(structure.name) + "Outputs_t";
        auto used_name = As_Capital_And_Pushed_Together(structure.name) + "OutputsT";
        auto print_name = Capitalize_Each_With_Space_In_Between(structure.name);
        Doxygen_Block_Printer::Print_Block(out,0,print_name + " Outputs", "All of the conceivable outputs,\nthat may be influenced by any of outputs during and update");
        Print_To_Stream(out,"typedef struct ");
        Print_To_Stream_With_Newline(out,dumb_name);
        Print_To_Stream_With_Newline(out,"{");
        Print_Output_Data_Variables(out,structure);
        Print_Output_Return_Variables(out,structure);
        Print_To_Stream(out,"} ");
        Print_To_Stream(out,used_name);
        Print_To_Stream_With_Newline(out,";");
        Print_To_Stream_With_Newline(out,"");
❱

◀private: static▶ void ☀Print_Output_Data_Variables(std::wofstream & out, CodeLang_Structure const& structure)❰

    //get all the necessary members based on state specifiers
    auto members = structure.data_members.data_members;
    Remove_Elements_Where_Function_Is_True(members,[](Data_Member_Item const& x){ return !x.is_observable && !x.is_injectable;});
    Print_List_Of_Data_Members(out,members);
❱
◀private: static▶ void ☀Print_Output_Return_Variables(std::wofstream & out, CodeLang_Structure const& structure)❰
❱


◀private: static▶ void ☀Print_Component_Methods(std::wofstream & out, std::vector<Method_Item> const& inputs)❰
    if (inputs.size() > 1){
        for (auto it: inputs){
            Doxygen_Block_Printer::Print_Block(out,4,as_string(it.brief_description),as_string(it.detailed_description));
            auto prefix = Type_To_Hungarian_Notation_Converter::Get_Hungarian_Notation_Prefix("BOOL",false,true,false,false,false);
            Print_To_Stream_With_Newline(out,"    BOOL " + prefix + As_Capital_And_Pushed_Together(as_string(it.function_name)) + ";");
        }
    }
❱

◀private: static▶ void ☀Print_Component_Inputs(std::wofstream & out, std::vector<Component_Input> const& inputs)❰
        
        
        //dump all of the API method triggers
/*
        if (inputs.size() > 1){
            std::vector<std::string> froms;
            for (auto it: inputs){
                
                froms += from;
            }
            
            Sort_And_Remove_Duplicates(froms);
            
            for (auto it: froms){
                //print
                Doxygen_Block_Printer::Print_Block(out,4,it,detail);
                //auto prefix = Type_To_Hungarian_Notation_Converter::Get_Hungarian_Notation_Prefix(as_string(it.arg.type),false,true,false,false,false);
                //Print_To_Stream_With_Newline(out,"    " + as_string(it.arg.type) + " " + prefix + As_Capital_And_Pushed_Together(as_string(it.arg.identifier)) + ";");
                //Print_To_Stream_With_Newline(out,"");
            }
        }*/
        
        
        
        //dump all of the parameters
        for (auto it: inputs){
            //build string that shows what functions it applies to:
            std::string detail;
            detail += "This parameter is applied to the following functions:\n";
            for (auto x: it.from){
                detail += As_Capital_And_Pushed_Together(x) + "\n";
            }
            
            
            //print
            Doxygen_Block_Printer::Print_Block(out,4,as_string(it.arg.comment),detail);
            auto prefix = Type_To_Hungarian_Notation_Converter::Get_Hungarian_Notation_Prefix(as_string(it.arg.type),false,true,false,false,false);
            Print_To_Stream_With_Newline(out,"    " + as_string(it.arg.type) + " " + prefix + As_Capital_And_Pushed_Together(as_string(it.arg.identifier)) + ";");
            Print_To_Stream_With_Newline(out,"");
        }
        
❱


//utility
◀private: static▶ void ☀Print_List_Of_Data_Members(std::wofstream & out, std::vector<Data_Member_Item> const& members)❰
    for (auto it: members){
        Print_Data_Member(out,it);
    }
❱


◀private: static▶ void ☀Print_Data_Member(std::wofstream & out, Data_Member_Item const& it)❰
        Doxygen_Block_Printer::Print_Block(out,4,as_string(it.brief),as_string(it.detail));
        auto prefix = Type_To_Hungarian_Notation_Converter::Get_Hungarian_Notation_Prefix(as_string(it.type),false,true,false,false,false);
        Print_To_Stream_With_Newline(out,"    " + as_string(it.type) + " " + prefix + As_Capital_And_Pushed_Together(as_string(it.name)) + ";" );
        Print_To_Stream_With_Newline(out,"");
❱

//◀private: static▶ std::vector<Data_Member_Item> ☀Extract_Local_Struct_Variables
//◀private: static▶ std::vector<Data_Member_Item> ☀Extract_Input_Struct_Variables
//◀private: static▶ std::vector<Data_Member_Item> ☀Extract_Output_Struct_Variables
























