class
❪"systems"❫
❪"utilities"❫
❪"CodeLang_structure"❫
⚯
❪"methods_printer"❫
⚞⚟

◀public: static▶ void ☀Print_Initialize_Declaration(std::wofstream & out, CodeLang_Structure const& structure)❰
    Print_To_Stream_With_Newline(out,"");
    auto func = Create_Method(structure);
    Methods_Printer::Print_Global_Interface_Methods(out,func);
❱
◀public: static▶ void ☀Print_Initialize_Definition(std::wofstream & out, CodeLang_Structure const& structure)❰
    Print_To_Stream_With_Newline(out,"");
    auto func = Create_Method(structure);
    Methods_Printer::Print_Global_Implementation_Methods(out,func);
❱

◀private: static▶ std::vector<Method_Item> ☀Create_Method(CodeLang_Structure const& structure)❰

    //build up fake params
    std::vector<Method_Item> func;
    Method_Item m;
    
    m.class_access = Class_Access::PUBLIC;
    m.value_overload = Value_Overload::NONE;
    m.is_static = false;
    m.is_const = false;
    m.is_virtual = false;
    m.function_name = L"initialize " + as_wstring(As_All_Lowercase_Letters_With_Underscores_As_Spaces(structure.name));
    m.brief_description = L"Sets the initial state of " + as_wstring(As_Capital_And_Pushed_Together(structure.name));
    m.detailed_description = L"Before the output can be used and updated, it must first be initialized to a valid state.";
    
    //set expected params
    Function_Argument one;
    one.is_const = false;
    one.type = as_wstring(As_Capital_And_Pushed_Together(structure.name)) + L"OutputsT *const";
    one.identifier = L"outputs";
    one.comment = L"Represents the internal state of the object.\nThe internal state of the object, will be initialized\nbased on the input parameters and any pre-defined state decisions";
    
    m.function_arguments.push_back(one);
    
    Add_Constructor_Params(structure.name,m.function_arguments,structure.methods.methods);
    Add_Body(structure.name,m,structure.methods.methods);
    
    func.push_back(m);
    
    return func;
❱

◀private: static▶ void ☀Add_Constructor_Params(std::string file_name, std::vector<Function_Argument> & args, std::vector<Method_Item> const& methods)❰

    auto constructor = Get_Constructor(file_name,methods);
    args += constructor.function_arguments;
❱
◀private: static▶ void ☀Add_Body(std::string file_name, Method_Item & m, std::vector<Method_Item> const& methods)❰

    auto constructor = Get_Constructor(file_name,methods);
    m.body = constructor.body;
❱

◀private: static▶ Method_Item ☀Get_Constructor(std::string file_name, std::vector<Method_Item> const& methods)❰

    for (auto it: methods){
        if (As_Capital_And_Pushed_Together(file_name) == As_Capital_And_Pushed_Together(as_string(it.function_name))){
            return it;
        }
    }
    
    
    return Method_Item{};
    
    
❱