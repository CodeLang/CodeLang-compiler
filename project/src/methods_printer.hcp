class
❪"systems"❫
❪"utilities"❫
❪"method_item"❫
⚯
❪"type_to_hungarian_notation_converter"❫
❪"doxygen_block_printer"❫
⚞⚟

//non-wrapped methods
◀public: static▶ void ☀Print_Global_Interface_Methods(std::wofstream & out, std::vector<Method_Item> const& methods)❰

    for (auto it: methods){
        Print_Method_Interface(out,it);
    }
❱
◀public: static▶ void ☀Print_Global_Implementation_Methods(std::wofstream & out, std::vector<Method_Item> const& methods)❰
    for (auto it: methods){
        Print_Method_Implementation(out,it);
    }
❱
◀public: static▶ void ☀Print_Method_Interface(std::wofstream & out, Method_Item const& method)❰
    Doxygen_Block_Printer::Print_Doxygen_Method_Comment(out,method);
    Print_Method_Deceleration(out,method);
❱
◀public: static▶ void ☀Print_Method_Implementation(std::wofstream & out, Method_Item const& method)❰
    Doxygen_Block_Printer::Print_Doxygen_Method_Comment(out,method);
    Print_Method_Definition(out,method);
❱
◀private: static▶ void ☀Print_Method_Deceleration(std::wofstream & out, Method_Item const& method)❰
    
    Print_Method_Signature(out,method);
    Print_To_Stream_With_Newline(out,";");
    Print_To_Stream_With_Newline(out,"");
❱
◀private: static▶ void ☀Print_Method_Definition(std::wofstream & out, Method_Item const& method)❰
    Print_Method_Signature(out,method);
    Print_To_Stream_With_Newline(out,"");
    Print_To_Stream_With_Newline(out,"{");
    Print_To_Stream_With_Newline(out,As_Trimmed(as_string(method.body)));
    Print_To_Stream_With_Newline(out,"}");
    Print_To_Stream_With_Newline(out,"");
❱
◀private: static▶ void ☀Print_Method_Signature(std::wofstream & out, Method_Item const& method)❰

     Print_Template_Argument_List(out,method.template_arguments);
     
     if (method.is_static){
        Print_To_Stream(out,"static ");
     }
     
    //print the return type
    if (!method.return_results.empty()){
        
        //maybe print const
        if (method.return_results[0].is_const){
            Print_To_Stream(out,"const ");
        }
        //print the type
        Print_To_Stream(out,method.return_results[0].type);
        Print_To_Stream(out," ");
    }
    
    //if no return type was given assume the type is void
    else{Print_To_Stream(out,"void ");}
    
    Print_To_Stream(out,Derive_Function_Name(method.function_name));
    Print_Function_Argument_List(out,method.function_arguments);
❱



//wrapped methods
◀public: static▶ void ☀Print_Wrapper_Decleration_Methods(std::string file_name, std::wofstream & out, std::vector<Method_Item> const& methods)❰
    for (auto it: methods){
        Print_Wrapper_Interface(file_name,out,it);
    }
❱
◀public: static▶ void ☀Print_Wrapper_Definition_Methods(std::string file_name, std::wofstream & out, std::vector<Method_Item> const& methods)❰
    for (auto it: methods){
        Print_Wrapper_Implementation(file_name,out,it);
    }
❱
◀public: static▶ void ☀Print_Wrapper_Interface(std::string file_name, std::wofstream & out, Method_Item const& method)❰
    Doxygen_Block_Printer::Print_Doxygen_Method_Comment(out,method);
    Print_Wrapper_Method_Deceleration(file_name,out,method);
❱
◀public: static▶ void ☀Print_Wrapper_Implementation(std::string file_name, std::wofstream & out, Method_Item const& method)❰
    Doxygen_Block_Printer::Print_Doxygen_Method_Comment(out,method);
    Print_Wrapper_Method_Definition(file_name,out,method);
❱
◀private: static▶ void ☀Print_Wrapper_Method_Deceleration(std::string file_name, std::wofstream & out, Method_Item const& method)❰
    
    Print_Wrapper_Method_Signature(file_name,out,method);
    Print_To_Stream_With_Newline(out,";");
    Print_To_Stream_With_Newline(out,"");
❱
◀private: static▶ void ☀Print_Wrapper_Method_Definition(std::string file_name, std::wofstream & out, Method_Item const& method)❰
    Print_Wrapper_Method_Signature_Source_Side(file_name, out,method);
    Print_To_Stream_With_Newline(out,"");
    Print_To_Stream_With_Newline(out,"{");
    Print_Wrapper_Body(file_name,out,method);
    Print_To_Stream_With_Newline(out,"}");
    Print_To_Stream_With_Newline(out,"");
❱


◀private: static▶ void ☀Print_Wrapper_Method_Signature(std::string file_name, std::wofstream & out, Method_Item const& method)❰
     
    //print the return type
    if (!method.return_results.empty()){
        
        //maybe print const
        if (method.return_results[0].is_const){
            Print_To_Stream(out,"const ");
        }
            Print_To_Stream(out,method.return_results[0].type);
            Print_To_Stream(out," ");
    }
    
    //if no return type was given assume the type is void
    else{
        
        //print the type (unless its a constructor)
        if (!Is_Constructor(file_name,method)){
            Print_To_Stream(out,"void ");
        }
    }
    
    Print_To_Stream(out,Derive_Function_Name(method.function_name));
    Print_Function_Argument_List(out,method.function_arguments);
❱

◀private: static▶ void ☀Print_Wrapper_Method_Signature_Source_Side(std::string file_name, std::wofstream & out, Method_Item const& method)❰
     
    //print the return type
    if (!method.return_results.empty()){
        
        //maybe print const
        if (method.return_results[0].is_const){
            Print_To_Stream(out,"const ");
        }
            Print_To_Stream(out,method.return_results[0].type);
            Print_To_Stream(out," ");
    }
    
    //if no return type was given assume the type is void
    else{
        
        //print the type (unless its a constructor)
        if (!Is_Constructor(file_name,method)){
            Print_To_Stream(out,"void ");
        }
    }
    Print_To_Stream(out,As_Capital_And_Pushed_Together(file_name) + "::");
    Print_To_Stream(out,Derive_Function_Name(method.function_name));
    Print_Function_Argument_List(out,method.function_arguments);
❱


◀private: static▶ void ☀Print_Wrapper_Body(std::string file_name, std::wofstream & out, Method_Item const& method)❰
    
    Print_To_Stream(out,As_Capital_And_Pushed_Together(file_name) + "InputsT i;");
    Set_Backend_API_Trigger(file_name,out,method);
    Set_Trigger_Method_Parameters(file_name,out,method);
    Call_Backend_API_Method(file_name,out,method);
    Detrigger_The_Call(file_name,out,method);
    Destructure_The_Observables(file_name,out,method);
    Return_The_Value_If_Needed(file_name,out,method);
❱

◀private: static▶ void ☀Set_Backend_API_Trigger(std::string file_name, std::wofstream & out, Method_Item const& method)❰
    Print_To_Stream_With_Newline(out,"//set the trigger for the backend API method");
    Print_To_Stream_With_Newline(out,"i.");
    Print_To_Stream_With_Newline(out,"");
❱
◀private: static▶ void ☀Set_Trigger_Method_Parameters(std::string file_name, std::wofstream & out, Method_Item const& method)❰
    Print_To_Stream_With_Newline(out,"//set the triggered method parameters");
    Print_To_Stream_With_Newline(out,"");
❱
◀private: static▶ void ☀Call_Backend_API_Method(std::string file_name, std::wofstream & out, Method_Item const& method)❰
    Print_To_Stream_With_Newline(out,"//call the method");
    Print_To_Stream(out,"Update");
    Print_To_Stream(out,As_Capital_And_Pushed_Together(file_name));
    Print_To_Stream_With_Newline(out,"(o,i);");
    Print_To_Stream_With_Newline(out,"");
                    
❱
◀private: static▶ void ☀Detrigger_The_Call(std::string file_name, std::wofstream & out, Method_Item const& method)❰
    Print_To_Stream_With_Newline(out,"//de-trigger the call");
    Print_To_Stream_With_Newline(out,"i.");
❱
◀private: static▶ void ☀Destructure_The_Observables(std::string file_name, std::wofstream & out, Method_Item const& method)❰
    Print_To_Stream_With_Newline(out,"//destructure the observables");
    Print_To_Stream_With_Newline(out,"DeStructure();");
❱
◀private: static▶ void ☀Return_The_Value_If_Needed(std::string file_name, std::wofstream & out, Method_Item const& method)❰
    Print_To_Stream_With_Newline(out,"//return the API result if applicable");
    Print_To_Stream_With_Newline(out,"");
❱







//other goodies


◀private: static▶ void ☀Print_Template_Argument_List(std::wofstream & out, std::vector<Template_Argument> const& arguments)❰
❱
◀private: static▶ void ☀Print_Function_Argument_List(std::wofstream & out, std::vector<Function_Argument> const& arguments)❰
    Print_To_Stream(out,"(");
    if (arguments.empty()){
        Print_To_Stream(out,"void");
    }else{
        Call_Function_On_All_Elements_Except_Last_Element_Then_Call_Function_On_Last_Element(arguments
                                                                     ,[&](Function_Argument arg){
                                                                       if (arg.is_const){Print_To_Stream(out,"const ");}
                                                                       Print_To_Stream(out,arg.type);
                                                                       Print_To_Stream(out," ");
                                                                       Print_To_Stream(out,Derive_Argument_Identifier_Name(arg));
                                                                       Print_To_Stream(out,", ");
                                                                     }
                                                                     ,[&](Function_Argument arg){
                                                                       if (arg.is_const){Print_To_Stream(out,"const ");}
                                                                       Print_To_Stream(out,arg.type);
                                                                       Print_To_Stream(out," ");
                                                                       Print_To_Stream(out,Derive_Argument_Identifier_Name(arg));
                                                                     });
    }
    Print_To_Stream(out,")");
❱



◀private: static▶ std::string ☀Derive_Function_Name(std::wstring const& name)❰
    auto str = as_string(name);
    str = As_Capital_And_Pushed_Together(str);
    return str;
❱

◀public: static▶ std::string ☀Derive_Argument_Identifier_Name(Function_Argument const& arg)❰
        auto identifier = as_string(arg.identifier);
        auto type       = as_string(arg.type);
        bool is_pointer = Begins_Or_Ends_With(type,"&") || Ends_With(type,"*const") || Ends_With(type,"*");
        auto prefix     = Type_To_Hungarian_Notation_Converter::Get_Hungarian_Notation_Prefix(type,is_pointer,false,false,false,false);
        auto new_identifier = prefix + As_Capital_And_Pushed_Together(identifier);
        return new_identifier;
❱

◀public: static▶ std::string ☀Derive_Return_Identifier_Name(Function_Result const& arg)❰
        auto identifier = as_string(arg.identifier);
        auto type       = as_string(arg.type);
        bool is_pointer = Begins_Or_Ends_With(type,"&") || Ends_With(type,"*const") || Ends_With(type,"*");
        auto prefix     = Type_To_Hungarian_Notation_Converter::Get_Hungarian_Notation_Prefix(type,is_pointer,false,false,false,false);
        auto new_identifier = prefix + As_Capital_And_Pushed_Together(identifier);
        return new_identifier;
❱


◀private: static▶ bool ☀Is_Constructor(std::string file_name, Method_Item const& m)❰
        if (As_Capital_And_Pushed_Together(file_name) == As_Capital_And_Pushed_Together(as_string(m.function_name))){
            return true;
        }
        return false;
❱





