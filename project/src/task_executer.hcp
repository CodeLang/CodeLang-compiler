class
❪"utilities"❫
❪"systems"❫
❪"program_options"❫
❪"dependency_paths"❫
❪"code_graph"❫
⚯
❪"filename_validator"❫
❪"parser"❫
❪"compiler"❫
❪"exception_handler"❫
❪"global_constants"❫
❪"dependency_path_validator"❫
⚞⚟

//WHY WE NEED A HIGHER HIGH LEVEL GUI LANGUAGE:
//things that are dumb, that code generation will fix:
//- having to write two files for global code (only one file now)
//- having to write two/three files for object code (only one file now)

//-repetitions that are no longer an issue:
// - source files automatically include their corresponding header files, with a header comment
// - no need to write both function decelerations and definitions.
// - no need to match the parameter name for doxygen comments
// - no need to figure out what the include guards are, and no need to type them.
// - no need to type the giant doxygen comment block header thing we use.

//dealing with boilerplate code:
//  - hard to keep consistent across files (generated automatically now)
//  - structs having that unnecessary extra name
//    (doesn't matter now.  All the structs you need are generated 
//    automatically based on member variables,functions, and the file name)
//hungarian notation is terrible.  This softens the blow, as the correct notation can be generated and met at the function signature level.
//Since you shouldn't be writing any code outside of functions, this analogous to static enforcement by the compiler.
//make a better write up later...


//SPECIFC TERMINOLOGY YOU MAY ENCOUNTER:
//manager methods: categories constructors and destructors under one name.
//http://stackoverflow.com/questions/33788300/is-there-an-umbrella-term-for-constructor-destructor-methods

//state specifier:

//operation category(might go away):

◀public: static▶ void ☀Execute_Needed_Tasks(Program_Options const& program_options)❰
    
    //the start of program logic (the actual main function does generated setup not unique to this project)
    Compile_Each_Of_The_Files_According_To_Program_Options(program_options.Input_Files(),program_options);
❱


◀private: static▶ void ☀Compile_Each_Of_The_Files_According_To_Program_Options(std::vector<std::string> const& input_files, Program_Options const& program_options)❰

    //process each file at a time
    //NOTE: looking for an alternative "For_Each(container,func);"
    for (auto const& it: input_files){
        Process_File(it,program_options);
    }
❱

◀private: static▶ void ☀Process_File(std::string const& path_to_file, Program_Options const& program_options)❰

    //compile the file
    //stop immediately if there are problems (this is done by throwing exceptions and catching them.)
    //We don't exit the program on a thrown exception; we continue onto the next file.
    try{ Compile_File(path_to_file
            ,program_options.Exporter()
            ,program_options.Language()
            ,program_options.Style()
            ,Dependency_Paths(program_options.Recursive_Dependency_Paths()
                             ,program_options.Dependency_Paths()));
       }
    catch(...){Exception_Handler::Handle_Exceptions();}
❱

◀private: static▶ void ☀Compile_File(std::string const& path_to_file, std::string const& exporter, std::string const& language, std::string const& style, Dependency_Paths const& dependency_paths)❰
        
        //Apart from just parsing the file that needs compiled, 
        //we will also need to compile all of the file's dependencies and store them in a graph data structure
        auto code_graph = Do_Validation_And_Parsing(path_to_file,dependency_paths);
    
        //compile the code structure into the appropriate source code files
        //TODO: pass in the code graph
        Compiler::Compile(code_graph.structure,exporter,language,style);
❱
◀private: static▶ Code_Graph ☀Do_Validation_And_Parsing(std::string const& path_to_file, Dependency_Paths dependency_paths)❰

        //validate program options before parsing the file.
        Do_Program_Option_Validation(path_to_file,dependency_paths);

        //parse the file and get back a class that represents it.
        //create a graph of these classes to handle the dependencies.
        //might throw...
        return Parser::Parse(path_to_file,dependency_paths);
❱
◀private: static▶ void ☀Do_Program_Option_Validation(std::string const& path_to_file, Dependency_Paths & dependency_paths)❰
    //check if something is initially wrong with the path and filename sent to the compiler
    //might throw..
    Filename_Validator::Validate_Input_File(path_to_file,global_constants::EXPECTED_FILE_EXTENSION);
    
    //Remove the unreachable paths and warns about them. Does not throw.
    Dependency_Path_Validator::Validate_Paths_By_Removing_And_Warning_About_Invalid_Paths(dependency_paths);
❱





