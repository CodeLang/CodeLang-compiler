class
❪"utilities"❫
❪"systems"❫
❪"program_options"❫
⚯
❪"filename_validator"❫
❪"CodeLang_parser"❫
❪"CodeLang_structure_analyzer"❫
❪"CodeLang_compiler"❫
❪"exception_handler"❫
⚞⚟

//things that are dumb, that code generation will fix:
//- having to write two files for global code (only one file now)
//- having to write two/three files for object code (only one file now)

//-repetitions that are no longer an issue:
// - source files automatically include their corresponding header files, with a header comment
// - no need to write both function decelerations and definitions.
// - no need to match the parameter name for doxygen comments
// - no need to figure out what the include guards are, and no need to type them.
// - no need to type the giant doxugen comment block header thing we use.

//dealing with boilerplate code:
//  - hard to keep consistent across files (generated automatically now)
//  - structs having that unnecessary extra name
//    (doesn't matter now.  All the structs you need are generated 
//    automatically based on member variables,functions, and the file name)
//hungarian notation is terrible.  This softens the blow, as the correct notation can be generated and met at the function signature level.
//Since you shouldn't be writing any code outside of functions, this analogous to static enforcement by the compiler.
//make a better write up later...

◀public: static▶ void ☀Execute_Needed_Tasks(Program_Options const& program_options)❰

     //process each file at a time
     for (auto const& path_to_file: program_options.Input_Files()){
      
        //compile the file
        //stop immediately if there are problems
        //always continue onto the next file
        try{ Compile_File(path_to_file,program_options.Exporter(),program_options.Language(),program_options.Style()); }
        catch(...){Exception_Handler::Handle_Parse_Exceptions();}
     }
❱
◀private: static▶ void ☀Compile_File(std::string const& path_to_file, std::string const& exporter, std::string const& language)❰

        //check if something is initially wrong with the path and filename sent to the compiler
        //might throw..
        Filename_Validator::Validate_Input_File(path_to_file);

        //parse the CodeLang file and get back a class that represents it
        //might throw...
        auto structure = CodeLang_Parser::Parse(path_to_file);//parsing out tokens does not do the macros correct yet
        
        //doesn't throw, but may print to std error
        CodeLang_Structure_Analyzer::Print_Warnings(structure);
    
        //compile the code structure into the appropriate source code files
        CodeLang_Compiler::Compile(structure,exporter,language);
❱