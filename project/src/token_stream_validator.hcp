class
❪"systems"❫
❪"utilities"❫
❪"parser_token"❫
⚯
❪"token_stream_validation_exception"❫
⚞⚟


◀public: static▶ void ☀Run_Validations_Over_Token_Stream(std::vector<Parser_Token> const& tokens)❰

    //ensure valid values for all the tokens that must contain only certain values
    Ensure_Tokens_Have_Valid_Values(tokens);
    
    Ensure_Appropiate_Tokens_And_Token_Values_Are_Being_Used(tokens);
    
    Ensure_Tokens_Are_In_The_Correct_Order(tokens);
❱

◀private: static▶ void ☀Ensure_Tokens_Have_Valid_Values(std::vector<Parser_Token> const& tokens)❰

    Validate_Code_Type(tokens);
    Ensure_Namespace_Specifiers_Are_Valid(tokens);
    Ensure_Inheritance_Specifiers_Are_Valid(tokens);
    Ensure_Function_Class_Specifiers_Are_Valid(tokens);
    Ensure_Function_Operation_Categories_Are_Valid(tokens);
    Ensure_Function_Argument_Type_Qualifiers_Are_Valid(tokens);
    Ensure_Function_Result_Type_Qualifiers_Are_Valid(tokens);
    Ensure_Data_Member_Class_Specifiers_Are_Valid(tokens);
    Ensure_Data_Member_Type_Qualifiers_Are_Valid(tokens);
    Ensure_Data_Member_State_Specifier_Are_Valid(tokens);
    
❱
◀private: static▶ void ☀Ensure_Appropiate_Tokens_And_Token_Values_Are_Being_Used(std::vector<Parser_Token> const& tokens)❰
    auto code_type_token = Get_First_Of_Parser_Token_Name(tokens,Token_Name::META_DATA_CODE_TYPE);
    if (code_type_token.content == L"global"){
        Ensure_Appropiate_Tokens_And_Token_Values_Are_Being_Used_For_Global_Code(tokens);
    }
    else if(code_type_token.content == L"object"){
        Ensure_Appropiate_Tokens_And_Token_Values_Are_Being_Used_For_Object_Code(tokens);
    }
    else if(code_type_token.content == L"enumerated"){
        Ensure_Appropiate_Tokens_And_Token_Values_Are_Being_Used_For_Enumerated_Code(tokens);
    }
❱
◀private: static▶ void ☀Ensure_Tokens_Are_In_The_Correct_Order(std::vector<Parser_Token> const& tokens)❰
    auto code_type_token = Get_First_Of_Parser_Token_Name(tokens,Token_Name::META_DATA_CODE_TYPE);
    if (code_type_token.content == L"global"){
        Ensure_Tokens_Are_In_The_Correct_Order_For_Global_Code(tokens);
    }
    else if(code_type_token.content == L"object"){
        Ensure_Tokens_Are_In_The_Correct_Order_For_Object_Code(tokens);
    }
    else if(code_type_token.content == L"enumerated"){
        Ensure_Tokens_Are_In_The_Correct_Order_For_Enumerated_Code(tokens);
    }
❱
◀private: static▶ void ☀Ensure_Appropiate_Tokens_And_Token_Values_Are_Being_Used_For_Global_Code(std::vector<Parser_Token> tokens)❰
❱
◀private: static▶ void ☀Ensure_Appropiate_Tokens_And_Token_Values_Are_Being_Used_For_Object_Code(std::vector<Parser_Token> tokens)❰
❱
◀private: static▶ void ☀Ensure_Appropiate_Tokens_And_Token_Values_Are_Being_Used_For_Enumerated_Code(std::vector<Parser_Token> tokens)❰
❱
◀private: static▶ void ☀Ensure_Tokens_Are_In_The_Correct_Order_For_Global_Code(std::vector<Parser_Token> tokens)❰
❱
◀private: static▶ void ☀Ensure_Tokens_Are_In_The_Correct_Order_For_Object_Code(std::vector<Parser_Token> tokens)❰
❱
◀private: static▶ void ☀Ensure_Tokens_Are_In_The_Correct_Order_For_Enumerated_Code(std::vector<Parser_Token> tokens)❰
❱






◀private: static▶ void ☀Validate_Code_Type(std::vector<Parser_Token> tokens)❰

    Reduce_To_Just_Tokens_Of_Name(tokens,Token_Name::META_DATA_CODE_TYPE);
    
    if (tokens.empty()){
        throw "No Code Type token given.";
    }
    
    if (tokens.size() > 1){
        throw Token_Stream_Validation_Exception("More than one Code Type token",tokens[1]);
    }
    
    if (tokens[0].content != L"global" && tokens[0].content != L"object"){
        throw Token_Stream_Validation_Exception("Invalid Code Type value",tokens[0]);
    }
❱
◀private: static▶ void ☀Ensure_Namespace_Specifiers_Are_Valid(std::vector<Parser_Token> tokens)❰
    Reduce_To_Just_Tokens_Of_Name(tokens,Token_Name::NAMESPACE_SPECIFIERS);
    for (auto it: tokens){
        if (it.content != L"i"){
            throw Token_Stream_Validation_Exception("Invalid namespace specifier",it);
        }
    }
❱
◀private: static▶ void ☀Ensure_Inheritance_Specifiers_Are_Valid(std::vector<Parser_Token> tokens)❰
    Reduce_To_Just_Tokens_Of_Name(tokens,Token_Name::INHERITANCE_SPECIFIERS);
    
//[inheritence-specifiers] =
//public / protected / private
//virtual

//looks like:
//+#-v

    for (auto it: tokens){
        
        auto str = as_string(it.content);
        auto publics = Count_Instances_Of_Character(str,'+');
        auto protecteds = Count_Instances_Of_Character(str,'#');
        auto privates = Count_Instances_Of_Character(str,'-');
        auto virtuals = Count_Instances_Of_Character(str,'v');
        
        //throw if there is more than one of any of these
        if (publics > 1){throw Token_Stream_Validation_Exception("More than one public access specifier",it);}
        if (protecteds > 1){throw Token_Stream_Validation_Exception("More than one protected access specifier",it);}
        if (privates > 1){throw Token_Stream_Validation_Exception("More than one private access specifier",it);}
        if (virtuals > 1){throw Token_Stream_Validation_Exception("More than one virtual class specifier",it);}
        
        //throw if no access specifier is given
        if (publics + protecteds + privates == 0){
            throw Token_Stream_Validation_Exception("No access specifier given",it);
        }
        
        //ensure no invalid characters were given
        auto number_of_valid_chars = publics + protecteds + privates + virtuals;
        if (number_of_valid_chars < it.content.size()){
            throw Token_Stream_Validation_Exception("Invalid characters given",it);
        }
    }
❱
◀private: static▶ void ☀Ensure_Function_Class_Specifiers_Are_Valid(std::vector<Parser_Token> tokens)❰
    Reduce_To_Just_Tokens_Of_Name(tokens,Token_Name::FUNCTION_CLASS_SPECIFIERS);

// [function class specifiers] =
// public / protected / private
// static
// const (observer)
// & / && overload
// virtual
// extern
// inline
// explicit (x)
// LEAVE OUT FRIEND FOR NOW (bad design)

// looks like:
// +#-scveix&&&
    
    for (auto it: tokens){
        auto str = as_string(it.content);
        auto publics = Count_Instances_Of_Character(str,'+');
        auto protecteds = Count_Instances_Of_Character(str,'#');
        auto privates = Count_Instances_Of_Character(str,'-');
        auto virtuals = Count_Instances_Of_Character(str,'s');
        auto consts = Count_Instances_Of_Character(str,'c');
        auto refs = Count_Instances_Of_Character(str,'&');
        auto externs = Count_Instances_Of_Character(str,'e');
        auto inlines = Count_Instances_Of_Character(str,'i');
        auto explicits = Count_Instances_Of_Character(str,'e');
        
        //throw if there is is too much of something
        if (publics > 1){throw Token_Stream_Validation_Exception("More than one public access specifier",it);}
        if (protecteds > 1){throw Token_Stream_Validation_Exception("More than one protected access specifier",it);}
        if (privates > 1){throw Token_Stream_Validation_Exception("More than one private access specifier",it);}
        if (virtuals > 1){throw Token_Stream_Validation_Exception("More than one virtual method specifier",it);}
        if (consts > 1){throw Token_Stream_Validation_Exception("More than one const method specifier",it);}
        if (refs > 2){throw Token_Stream_Validation_Exception("More than two ref method specifiers",it);}
        if (externs > 1){throw Token_Stream_Validation_Exception("More than one extern method specifier",it);}
        if (inlines > 1){throw Token_Stream_Validation_Exception("More than one inline method specifier",it);}
        if (explicits > 1){throw Token_Stream_Validation_Exception("More than one explicit method specifier",it);}
        
        //ensure only 1 access specifier is given
        auto total_access_specifiers = publics + protecteds + privates;
        if (total_access_specifiers > 1){
            throw Token_Stream_Validation_Exception("More than one class access specifier given",it);
        }
        
        //throw if no access specifier is given
        //if (publics + protecteds + privates == 0){
        //    throw Token_Stream_Validation_Exception("No access specifier given",it);
        //}
        
        //ensure no invalid characters were given
        auto number_of_valid_chars = publics + protecteds + privates + virtuals + consts + refs + externs + inlines + explicits;
        if (number_of_valid_chars < it.content.size()){
            throw Token_Stream_Validation_Exception("Invalid characters given",it);
        }
        
    }
    
    
❱
◀private: static▶ void ☀Ensure_Function_Operation_Categories_Are_Valid(std::vector<Parser_Token> tokens)❰
    Reduce_To_Just_Tokens_Of_Name(tokens,Token_Name::FUNCTION_OPERATION_CATEGORY);
    //might not be needed now
❱
◀private: static▶ void ☀Ensure_Function_Argument_Type_Qualifiers_Are_Valid(std::vector<Parser_Token> tokens)❰
    Reduce_To_Just_Tokens_Of_Name(tokens,Token_Name::FUNCTION_ARGUMENT_TYPE_QUALIFIERS);
    
    //just const is allowed I think
    for (auto it: tokens){
        auto str = as_string(it.content);
        auto consts = Count_Instances_Of_Character(str,'c');
        
        //throw if there is is too much of something
        if (consts > 1){throw Token_Stream_Validation_Exception("More than one const argument qualifier",it);}
        
        //ensure no invalid characters were given
        if (consts < it.content.size()){
            throw Token_Stream_Validation_Exception("Invalid characters given",it);
        }
    }
    
❱
◀private: static▶ void ☀Ensure_Function_Result_Type_Qualifiers_Are_Valid(std::vector<Parser_Token> tokens)❰
    Reduce_To_Just_Tokens_Of_Name(tokens,Token_Name::FUNCTION_RESULT_TYPE_QUALIFIERS);
    
    //just const is allowed I think
    for (auto it: tokens){
        auto str = as_string(it.content);
        auto consts = Count_Instances_Of_Character(str,'c');
        
        //throw if there is is too much of something
        if (consts > 1){throw Token_Stream_Validation_Exception("More than one const argument qualifier",it);}
        
        //ensure no invalid characters were given
        if (consts < it.content.size()){
            throw Token_Stream_Validation_Exception("Invalid characters given",it);
        }
    }
❱
◀private: static▶ void ☀Ensure_Data_Member_Class_Specifiers_Are_Valid(std::vector<Parser_Token> tokens)❰
    Reduce_To_Just_Tokens_Of_Name(tokens,Token_Name::DATA_MEMBER_CLASS_SPECIFIERS);
    //[type-qualifiers] = 
    //static extern
    //public private protected

    //looks like:
    //se+#-
    
    for (auto it: tokens){
        auto str = as_string(it.content);
        auto statics = Count_Instances_Of_Character(str,'s');
        auto externs = Count_Instances_Of_Character(str,'e');
        auto publics = Count_Instances_Of_Character(str,'+');
        auto protecteds = Count_Instances_Of_Character(str,'#');
        auto privates = Count_Instances_Of_Character(str,'-');
        
        //throw if there is is too much of something
        if (statics > 1){throw Token_Stream_Validation_Exception("More than one static data member specifier",it);}
        if (externs > 1){throw Token_Stream_Validation_Exception("More than one extern data member specifier",it);}
        if (publics > 1){throw Token_Stream_Validation_Exception("More than one public data member specifier",it);}
        if (protecteds > 1){throw Token_Stream_Validation_Exception("More than one protected data member specifier",it);}
        if (privates > 1){throw Token_Stream_Validation_Exception("More than one private data member specifier",it);}
        
        //ensure only 1 access specifier is given
        auto total_access_specifiers = publics + protecteds + privates;
        if (total_access_specifiers > 1){
            throw Token_Stream_Validation_Exception("More than one class access specifier given",it);
        }
        
        //ensure no invalid characters were given
        auto number_of_valid_chars = statics + externs + publics + protecteds + privates;
        if (number_of_valid_chars < it.content.size()){
            throw Token_Stream_Validation_Exception("Invalid characters given",it);
        }
    }
    
    
❱
◀private: static▶ void ☀Ensure_Data_Member_Type_Qualifiers_Are_Valid(std::vector<Parser_Token> tokens)❰
    Reduce_To_Just_Tokens_Of_Name(tokens,Token_Name::DATA_MEMBER_TYPE_QUALIFIERS);
    
    //just const is allowed I think
    for (auto it: tokens){
        auto str = as_string(it.content);
        auto consts = Count_Instances_Of_Character(str,'c');
        
        //throw if there is is too much of something
        if (consts > 1){throw Token_Stream_Validation_Exception("More than one const argument qualifier",it);}
        
        //ensure no invalid characters were given
        if (consts < it.content.size()){
            throw Token_Stream_Validation_Exception("Invalid characters given",it);
        }
    }
❱
◀private: static▶ void ☀Ensure_Data_Member_State_Specifier_Are_Valid(std::vector<Parser_Token> tokens)❰
    Reduce_To_Just_Tokens_Of_Name(tokens,Token_Name::DATA_MEMBER_STATE_SPECIFIER);
    
    //used to generate functions for access on variables
    for (auto it: tokens){
        auto str = as_string(it.content);
        if (str != "inject" && str != "observe" && str != "retrieve"){
            throw Token_Stream_Validation_Exception("Invalid data state specifier given",it);
        }
    }
❱



//utility
◀public: static▶ void ☀Reduce_To_Just_Tokens_Of_Name(std::vector<Parser_Token> & tokens, Token_Name name)❰
tokens.erase( std::remove_if( tokens.begin(), tokens.end(),
             [&](Parser_Token x){return x.token.name != name;}), tokens.end() ); 

❱

◀public: static▶ Parser_Token ☀Get_First_Of_Parser_Token_Name(std::vector<Parser_Token> const& tokens, Token_Name name)❰
    for (auto it : tokens){
        if (it.token.name == name){
            return it;
        }
    }
    return tokens[0];
❱










