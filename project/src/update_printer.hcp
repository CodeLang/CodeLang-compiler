class
❪"systems"❫
❪"utilities"❫
❪"CodeLang_structure"❫
⚯
❪"methods_printer"❫
⚞⚟

◀public: static▶ void ☀Print_Update_Declaration(std::wofstream & out, CodeLang_Structure const& structure)❰
    auto func = Create_Method(structure);
    Methods_Printer::Print_Global_Interface_Methods(out,func);
❱
◀public: static▶ void ☀Print_Update_Definition(std::wofstream & out, CodeLang_Structure const& structure)❰
    Print_To_Stream_With_Newline(out,"");
    auto func = Create_Method(structure);
    Methods_Printer::Print_Global_Implementation_Methods(out,func);
❱

◀private: static▶ std::vector<Method_Item> ☀Create_Method(CodeLang_Structure const& structure)❰

    //build up fake params
    std::vector<Method_Item> func;
    Method_Item m;
    
    m.class_access = Class_Access::PUBLIC;
    m.value_overload = Value_Overload::NONE;
    m.is_static = false;
    m.is_const = false;
    m.is_virtual = false;
    m.function_name = L"update " + as_wstring(As_All_Lowercase_Letters_With_Underscores_As_Spaces(structure.name));
    m.brief_description = L"Updates the state of " + as_wstring(As_Capital_And_Pushed_Together(structure.name)) + L" and generate new output";
    m.detailed_description = L"The input is used against the internal state of the output to generate a new output";
    
    //set expected params
    Function_Argument one;
    one.is_const = false;
    one.type = as_wstring(As_Capital_And_Pushed_Together(structure.name)) + L"OutputsT *const";
    one.identifier = L"outputs";
    one.comment = L"Represents the internal state of the object.\nThe internal state of the object, will be initialized\nbased on the input parameters and any pre-defined state decisions";
    
    //set expected params
    Function_Argument two;
    two.is_const = true;
    two.type = as_wstring(As_Capital_And_Pushed_Together(structure.name)) + L"InputsT *const";
    two.identifier = L"inputs";
    two.comment = L"All of the conceivable inputs used to transform the outputs.";
    
    m.function_arguments.push_back(one);
    m.function_arguments.push_back(two);
    
    Add_Body(structure.name,m,structure.methods.methods);
    
    func.push_back(m);
    
    return func;
❱

◀private: static▶ void ☀Add_Body(std::string file_name, Method_Item & m, std::vector<Method_Item> const& methods)❰

    //first get the number of callable methods
    unsigned int method_count = Number_Of_Non_Constructing_Methods(file_name,methods);
    
    //if it's only, we just call it.
    if (method_count <= 1){
        Update_Calls_One_Function(file_name,m.body,methods);
    }
    
    //if it's more than one, we produce and if chain using bools 
    //from the input as to whether or not the functions need called
    else{
        Update_Calls_Many_Functions(file_name,m.body,methods);
    }
    
❱

◀private: static▶ unsigned int ☀Number_Of_Non_Constructing_Methods(std::string file_name, std::vector<Method_Item> methods)❰
    //first get the number of callable methods
    unsigned int number_of_methods_not_counting_constructor = 0;
    for (auto it: methods){
        if (!Is_Constructor(file_name,it)){
            ++number_of_methods_not_counting_constructor;
        }
    }
    return number_of_methods_not_counting_constructor;
❱


◀private: static▶ void ☀Update_Calls_One_Function(std::string file_name, std::wstring & body, std::vector<Method_Item> const& methods)❰
    for (auto it: methods){
        if (!Is_Constructor(file_name,it)){
            auto func_name = as_wstring(As_Capital_And_Pushed_Together(as_string(it.function_name)));
            body += func_name;
            body += L"(";
            body += L"ptOutputs";
            for (auto x: it.function_arguments){
                body +=L",";
                body += L"ptInputs->";
                auto arg = Methods_Printer::Derive_Argument_Identifier_Name(x);
                body += as_wstring(arg);
            }
            body += L");\n";
        }
    }
❱
◀private: static▶ void ☀Update_Calls_Many_Functions(std::string file_name, std::wstring & body, std::vector<Method_Item> const& methods)❰
    for (auto it: methods){
        if (!Is_Constructor(file_name,it)){
            Add_Body_Part(it.body,it);
        }
    }
❱




◀private: static▶ void ☀Add_Body_Part(std::wstring & body, Method_Item const& m)❰
    
    auto func_name = as_wstring(As_Capital_And_Pushed_Together(as_string(m.function_name)));
    body += L"if (ptInputs->" + func_name + L")\n";
    body += L"{\n";
    if (!m.return_results.empty()){
        body += L"ptOutputs->";
        body += as_wstring(Methods_Printer::Derive_Return_Identifier_Name(m.return_results[0])) + L" = ";
    }
    body += func_name;
    body += L"(";
    body += L"ptOutputs";
    for (auto it: m.function_arguments){
        body +=L",";
        body += L"ptInputs->";
        auto arg = Methods_Printer::Derive_Argument_Identifier_Name(it);
        body += as_wstring(arg);
        
    }
    body += L");\n";
    body += L"}\n";
    
❱




◀private: static▶ bool ☀Is_Constructor(std::string file_name, Method_Item & m)❰
        if (As_Capital_And_Pushed_Together(file_name) == As_Capital_And_Pushed_Together(as_string(m.function_name))){
            return true;
        }
        return false;
❱






