􏶞g􏶟
􏷲various algorithms for analyzing and lane marking a route
algorithms decide to make markings based on annotated route information, and provided user data􏷱
􏷰there may be various reasons to mark lanes along a route
knowing when to regenerate is one such use case􏷯
􏷮Regeneration􏷭
􏴃Precondition Checks􏴄
􏴁functions for checking the preconditions of various APIs􏴂
􏴃Lane Marking􏴄
􏴁functions that decide where to mark lanes along a route􏴂
􏴃Annotated Route􏴄
􏴁functions related to the annotated route􏴂
􏷬Trevor Hickey􏷫

􏶔􏶕􏶒local_map/libs/regeneration/preset_routes􏶓
􏶔s􏶕􏶒algorithm􏶓
􏶔s􏶕􏶒set􏶓
􏶔s􏶕􏶒iostream􏶓􏲐

􏲏􏲐
􏲍local_map/libs/regeneration/preset_routes􏲎

􏷞local_map􏷝􏷞statik􏷝


􏷘+􏷗􏷒precondition mark lanes that exceed accumulated distance􏷑
􏴅Precondition Checks􏴆
􏷐Checks whether the arguments are valid as a precondition to the call􏷏
􏶠This function is a predicate for checking all the necessary preconditions􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to minimally reach􏶿
􏶚m􏶛􏶾bool􏶽􏶼meets preconditions􏶻􏶺whether the arguments meet the implementation's preconditions􏶹
􏶴
    if (!is_positive(distance_m)){
        return false;
    }
    
    meets_preconditions = true;
􏶳

􏷘+􏷗􏷒precondition mark lanes prior to exceeding distance􏷑
􏴅Precondition Checks􏴆
􏷐Checks whether the arguments are valid as a precondition to the call􏷏
􏶠This function is a predicate for checking all the necessary preconditions􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance that must not be exceeded􏶿
􏶚m􏶛􏶾bool􏶽􏶼meets preconditions􏶻􏶺whether the arguments meet the implementation's preconditions􏶹
􏶴
    if (!is_positive(distance_m)){
        return false;
    }
    
    if (!no_lane_longer_than_distance(route,distance_m)){
        return false;
    }
    
    meets_preconditions = true;
􏶳

􏷘+􏷗􏷒precondition mark lanes for local map sla requirement􏷑
􏴅Precondition Checks􏴆
􏷐Checks whether the arguments are valid as a precondition to the call􏷏
􏶠This function is a predicate for checking all the necessary preconditions􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to minimally reach􏶿
􏶚m􏶛􏶾bool􏶽􏶼meets preconditions􏶻􏶺whether the arguments meet the implementation's preconditions􏶹
􏶴
    if (!precondition_mark_lanes_that_exceed_accumulated_distance(route,distance_m)){
        return false;
    }
    
    meets_preconditions = true;
􏶳

􏷘+􏷗􏷒mark lanes􏷑
􏴅Lane Marking􏴆
􏷐mark lanes based on the configured marking strategy􏷏
􏶠This is a frontend for calling the different marking algorithms
Manily used for testing􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶜􏶝􏷆marking_input􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄settings􏷃􏷀the marking strategy to use􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    if (settings.exceeding_accumulated_distance){
        auto indexes = mark_lanes_that_exceed_accumulated_distance(route,settings.distance_m);
        lane_indexes.insert(indexes.begin(),indexes.end());
    }
    if (settings.before_exceeding_accumulated_distance){
        auto indexes = mark_lanes_prior_to_exceeding_accumulated_distance(route,settings.distance_m);
        lane_indexes.insert(indexes.begin(),indexes.end());
    }
    if (settings.prior_to_loop){
        auto indexes = mark_lanes_prior_to_forming_a_submap_loop(route);
        lane_indexes.insert(indexes.begin(),indexes.end());
    }
    if (settings.first_lane_loop){
        auto indexes = mark_first_lanes_involved_in_submap_loop(route);
        lane_indexes.insert(indexes.begin(),indexes.end());
    }
    if (settings.all_lanes_loop){
        auto indexes = mark_all_lanes_in_entered_submap_loop(route);
        lane_indexes.insert(indexes.begin(),indexes.end());
    }
    if (settings.after_loop){
        auto indexes = mark_first_lane_after_loop_causing_submaps(route);
        lane_indexes.insert(indexes.begin(),indexes.end());
    }
    if (settings.submap_transition){
        auto indexes = mark_lanes_that_transition_to_new_submaps(route);
        lane_indexes.insert(indexes.begin(),indexes.end());
    }
    if (settings.first){
        auto indexes = mark_first_lane(route);
        lane_indexes.insert(indexes.begin(),indexes.end());
    }
    if (settings.last){
        auto indexes = mark_last_lane(route);
        lane_indexes.insert(indexes.begin(),indexes.end());
    }
    if (settings.all){
        auto indexes = mark_all_lanes(route);
        lane_indexes.insert(indexes.begin(),indexes.end());
    }
    if (settings.regen_sla){
        auto indexes = mark_lanes_for_local_map_sla_requirement(route,settings.distance_m);
        lane_indexes.insert(indexes.begin(),indexes.end());
    }
􏶳

􏷘+􏷗􏷒mark lanes that exceed accumulated distance􏷑
􏴅Lane Marking􏴆
􏷐mark lanes along that route that exceed an accumulated distance greater than the provided distance􏷏
􏶠Ensures the distance is minimally met along each division made on the route􏶡
􏵪distance_must_be_positive()􏵫
􏵨the distance must be positive􏵩
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏲧local_map/libs/submap/submap_identifier􏲨􏲥local_map/libs/submap/local_map_submap􏲦􏷀the distance to minimally reach􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    double total_distance = 0.0;
    for (size_t i = 0; i < number_of_lanes(route); ++i){
        double lane_distance_m = lane_length(route,i);
        if (total_distance+lane_distance_m > distance_m){
            lane_indexes.insert(i);
            total_distance = 0;
        }
        else{
            total_distance += lane_distance_m;
        }
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto any_valid_distance_m = 1.0;
    auto indexes = mark_lanes_that_exceed_accumulated_distance(r,any_valid_distance_m);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯mark every lane􏴰
􏲝If every lane exceeds the distance given, all of the lanes should be marked􏲞
􏲛Implementation is no longer handling the exceeded distance check properly􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({100,100,100});
    
    //ACT
    auto distance_m = 50;
    auto indexes = mark_lanes_that_exceed_accumulated_distance(r,distance_m);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),3);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
    EXPECT_TRUE(indexes.find(1) != indexes.end());
    EXPECT_TRUE(indexes.find(2) != indexes.end());
􏴮
􏴯mark every other lane􏴰
􏲝If the distance is exceeded every other lane, we should have every other lane marked􏲞
􏲛Implementation is no longer handling the exceeded distance check properly􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({100,100,100,100,100,100});
    
    //ACT
    auto distance_m = 101;
    auto indexes = mark_lanes_that_exceed_accumulated_distance(r,distance_m);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),3);
    EXPECT_TRUE(indexes.find(0) == indexes.end());
    EXPECT_TRUE(indexes.find(1) != indexes.end());
    EXPECT_TRUE(indexes.find(2) == indexes.end());
    EXPECT_TRUE(indexes.find(3) != indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
    EXPECT_TRUE(indexes.find(5) != indexes.end());
􏴮
􏴯distance not reached􏴰
􏲝If the distance is never reached along the route, no lanes should be marked􏲞
􏲛Implementation is accidentally marking lanes before the distance is exceeded along the route􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({25,25,25,25});
    
    //ACT
    auto distance_m = 100;
    auto indexes = mark_lanes_that_exceed_accumulated_distance(r,distance_m);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
    EXPECT_TRUE(indexes.find(0) == indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) == indexes.end());
    EXPECT_TRUE(indexes.find(3) == indexes.end());
􏴮

􏷘+􏷗􏷒mark lanes prior to exceeding accumulated distance􏷑
􏴅Lane Marking􏴆
􏷐mark lanes along that route that each division does not exceed the distance given􏷏
􏶠Ensures no division is greater than the distance provided􏶡
􏵪distance_must_be_positive()􏵫
􏵨the distance must be positive􏵩
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏲧local_map/libs/submap/submap_identifier􏲨􏲥local_map/libs/submap/local_map_submap􏲦􏷀the distance that must not be exceeded􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    double total_distance = 0.0;
    for (size_t i = 0; i < number_of_lanes(route); ++i){
        double lane_distance_m = lane_length(route,i);
        if (total_distance+lane_distance_m > distance_m){
            insert_previous(lane_indexes,i);
            total_distance = lane_distance_m;
        }
        else{
            total_distance += lane_distance_m;
        }
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto any_valid_distance_m = 1.0;
    auto indexes = mark_lanes_prior_to_exceeding_accumulated_distance(r,any_valid_distance_m);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯mark every lane except last􏴰
􏲝We should be able to mark every lane except the last one􏲞
􏲛Implementation is no longer marking the lanes before the lanes that exceed an accumulated distance􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({100,100,100});
    
    //ACT
    auto distance_m = 50;
    auto indexes = mark_lanes_prior_to_exceeding_accumulated_distance(r,distance_m);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),2);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
    EXPECT_TRUE(indexes.find(1) != indexes.end());
    EXPECT_TRUE(indexes.find(2) == indexes.end());
􏴮
􏴯mark lanes before distance is exceeded􏴰
􏲝We should be able to mark only the lanes prior to exceeding an accumulated distance􏲞
􏲛Implementation is no longer marking the lanes before the lanes that exceed an accumulated distance􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({5,5,5,5,5,5});
    
    //ACT
    auto distance_m = 21;
    auto indexes = mark_lanes_prior_to_exceeding_accumulated_distance(r,distance_m);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),1);
    EXPECT_TRUE(indexes.find(0) == indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) == indexes.end());
    EXPECT_TRUE(indexes.find(3) != indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
    EXPECT_TRUE(indexes.find(5) == indexes.end());
􏴮


􏷘+􏷗􏷒mark lanes prior to forming a submap loop􏷑
􏴅Lane Marking􏴆
􏷐Mark the lanes prior to the lanes that would create a submap loop􏷏
􏶠Ensures that each marked lane comes before a submap loop is formed along the route􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨
􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    std::set<hub::base::guid> seen;
    hub::base::guid previous;
    for (size_t i = 0; i < number_of_lanes(route); ++i){
        auto id = local_map::internal::submap_identifier(route.lane_sequence[i]);
        
        if (previous != id){
            if (seen.find(id) != seen.end()){
                insert_previous(lane_indexes,i);
                seen.clear();
            }
        }
        previous = id;
        seen.insert(id);
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = mark_lanes_prior_to_forming_a_submap_loop(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯mark before submap loop􏴰
􏲝We should be able to mark the lane before the submap loop occurs􏲞
􏲛Implementation is no longer marking the lane before the submap loop􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,1,1});
    
    //ACT
    auto indexes = mark_lanes_prior_to_forming_a_submap_loop(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),1);
    EXPECT_TRUE(indexes.find(3) != indexes.end());
􏴮
􏴯mark before submap loop twice􏴰
􏲝We should be able to mark the lane before the submap loops occur􏲞
􏲛Implementation is no longer marking the lane before each submap loop􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,1,1,2,2,1,1});
    
    //ACT
    auto indexes = mark_lanes_prior_to_forming_a_submap_loop(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),2);
    EXPECT_TRUE(indexes.find(3) != indexes.end());
    EXPECT_TRUE(indexes.find(7) != indexes.end());
􏴮



􏷘+􏷗􏷒mark first lanes involved in submap loop􏷑
􏴅Lane Marking􏴆
􏷐when we detect submap loops, mark the first lane that is part of the submap loop􏷏
􏶠Ensures that each marked lane is the first lane in a submap that is part of a submap loop􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    std::map<hub::base::guid,size_t> seen;
    hub::base::guid previous;
    
    
    for (size_t i = 0; i < number_of_lanes(route); ++i){
        auto id = local_map::internal::submap_identifier(route.lane_sequence[i]);
        
        if (previous != id){
            auto found = seen.find(id);
            if (found != seen.end()){
                lane_indexes.insert(found->second);
                seen.clear();
            }
            seen[id] = i;
        }
        previous = id;
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = mark_first_lanes_involved_in_submap_loop(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯mark first lane of submap loop􏴰
􏲝We should be able to mark the first laneof a submap loop􏲞
􏲛Implementation is no longer marking the first lane of a submap loop􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,1,1});
    
    //ACT
    auto indexes = mark_first_lanes_involved_in_submap_loop(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),1);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) == indexes.end());
    EXPECT_TRUE(indexes.find(3) == indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
    EXPECT_TRUE(indexes.find(5) == indexes.end());
􏴮
􏴯mark first lane of each submap loop􏴰
􏲝We should be able to mark the lane before the submap loops occur􏲞
􏲛Implementation is no longer marking the lane before each submap loop􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,1,1,2,2,1,1});
    
    //ACT
    auto indexes = mark_first_lanes_involved_in_submap_loop(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),2);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
    EXPECT_TRUE(indexes.find(4) != indexes.end());
􏴮

􏷘+􏷗􏷒mark all lanes in entered submap loop􏷑
􏴅Lane Marking􏴆
􏷐when we detect submap loops, mark the all lanes that are part of the first time we are in the submap􏷏
􏶠Ensures that each marked lane is part of the first set of lanes in the loop conflicting submap􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    auto conflicting_submap_indexes = mark_first_lanes_involved_in_submap_loop(route);
    for (auto const& it: conflicting_submap_indexes){
        auto conflicting_submap = local_map::internal::submap_identifier(route.lane_sequence[it]);
        for (size_t i = it; i < number_of_lanes(route); ++i){
            auto next_submap = local_map::internal::submap_identifier(route.lane_sequence[i]);
            if (next_submap == conflicting_submap){
                lane_indexes.insert(i);
            }
            else
            {
                break;
            }
        }
    }
􏶳


􏷘+􏷗􏷒mark first lane after loop causing submaps􏷑
􏴅Lane Marking􏴆
􏷐when we detect submap loops, mark the first lane along the route that is past the conflicting submap􏷏
􏶠The lanes that are marked are still a part of the overall loop, but we are now outside the submap that we will later revisit􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    auto conflicting_submap_indexes = mark_first_lanes_involved_in_submap_loop(route);
    for (auto const& it: conflicting_submap_indexes){
        auto conflicting_submap = local_map::internal::submap_identifier(route.lane_sequence[it]);
        for (size_t i = it; i < number_of_lanes(route); ++i){
            auto next_submap = local_map::internal::submap_identifier(route.lane_sequence[i]);
            if (next_submap != conflicting_submap){
                lane_indexes.insert(i);
                break;
            }
        }
    }
􏶳
􏴯mark lanes after loops􏴰
􏲝We should be able to mark the lanes immediately after submap loops􏲞
􏲛Implementation is no longer marking the lane after the submap loop􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,1,1,2,2,1,1});
    
    //ACT
    auto indexes = mark_first_lane_after_loop_causing_submaps(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),2);
    EXPECT_TRUE(indexes.find(0) == indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) != indexes.end());
    EXPECT_TRUE(indexes.find(3) == indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
    EXPECT_TRUE(indexes.find(5) == indexes.end());
    EXPECT_TRUE(indexes.find(6) != indexes.end());
    EXPECT_TRUE(indexes.find(7) == indexes.end());
    EXPECT_TRUE(indexes.find(8) == indexes.end());
    EXPECT_TRUE(indexes.find(9) == indexes.end());
􏴮
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = mark_first_lane_after_loop_causing_submaps(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮

􏷘+􏷗􏷒mark lanes that transition to new submaps􏷑
􏴅Lane Marking􏴆
􏷐mark every lane that transitions to a different submap􏷏
􏶠Ensures that each marked lane exists in a different submap that the previous marked lane􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    hub::base::guid previous;
    for (size_t i = 0; i < number_of_lanes(route); ++i){
        auto id = local_map::internal::submap_identifier(route.lane_sequence[i]);
        
        if (previous != id){
            lane_indexes.insert(i);
        }
        previous = id;
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = mark_lanes_that_transition_to_new_submaps(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯mark lanes into new submaps􏴰
􏲝We should be able to mark each lane in a submap transition􏲞
􏲛Implementation is no longer marking each new lane in a submap transition􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,2,1});
    
    //ACT
    auto indexes = mark_lanes_that_transition_to_new_submaps(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),3);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) != indexes.end());
    EXPECT_TRUE(indexes.find(3) == indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
    EXPECT_TRUE(indexes.find(5) != indexes.end());
􏴮


􏷘+􏷗􏷒mark first lane􏷑
􏴅Lane Marking􏴆
􏷐Marks the first lane of the route􏷏
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    if (has_lanes(route)){
        lane_indexes.insert(0);
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = mark_first_lane(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯last􏴰
􏲝Marks the first lane􏲞
􏲛Implementation is no longer marking the first lane􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,1,2});
    
    //ACT
    auto indexes = mark_first_lane(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),1);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
􏴮

􏷘+􏷗􏷒mark last lane􏷑
􏴅Lane Marking􏴆
􏷐Marks the last lane of the route􏷏
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    if (has_lanes(route)){
        lane_indexes.insert(number_of_lanes(route) -1);
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = mark_last_lane(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯last􏴰
􏲝Marks the last lane􏲞
􏲛Implementation is no longer marking the last lane􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,2,2,2});
    
    //ACT
    auto indexes = mark_last_lane(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),1);
    EXPECT_TRUE(indexes.find(3) != indexes.end());
􏴮
􏷘+􏷗􏷒mark all lanes􏷑
􏴅Lane Marking􏴆
􏷐Marks all of the lanes in the route􏷏
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    for (size_t i = 0; i < number_of_lanes(route); ++i){
        lane_indexes.insert(i);
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = mark_all_lanes(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯all􏴰
􏲝All of the lanes should be marked􏲞
􏲛Implementation is no longer marking all of the lanes􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,3,3});
    
    //ACT
    auto indexes = mark_all_lanes(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),6);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
    EXPECT_TRUE(indexes.find(1) != indexes.end());
    EXPECT_TRUE(indexes.find(2) != indexes.end());
    EXPECT_TRUE(indexes.find(3) != indexes.end());
    EXPECT_TRUE(indexes.find(4) != indexes.end());
    EXPECT_TRUE(indexes.find(5) != indexes.end());
􏴮

􏷘+􏷗􏷒mark lanes for local map sla requirement􏷑
􏴅Lane Marking􏴆
􏷐marks lanes based on the local map's regeneration SLA requirements􏷏
􏶠Ensures that the proper lanes are marked to guarantee by the local map's SLA requirements during regeneration􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to minimally reach􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    􏶲perform marking policy􏶱
    lane_indexes = mark_lanes_prior_to_exceeding_accumulated_distance(route,distance_m);
    
    􏶲perform marking policy􏶱
    auto in_loop = mark_all_lanes_in_entered_submap_loop(route);
    
    􏶲perform marking policy􏶱
    auto after_loop = mark_first_lane_after_loop_causing_submaps(route);
    
    􏶲perform marking policy􏶱
    auto first = mark_first_lane(route);
    
    􏶲perform marking policy􏶱
    auto last = mark_last_lane(route);
    
    􏶲combine policy results􏶱
    lane_indexes.insert(in_loop.begin(),in_loop.end());
    lane_indexes.insert(after_loop.begin(),after_loop.end());
    lane_indexes.insert(first.begin(),first.end());
    lane_indexes.insert(last.begin(),last.end());
    
    􏶲we may want to do additional filtering􏶱
    􏶲probably convert this to a distance aware loop cutting with an offset from the explicitly marked first lane􏶱
    􏶲currently using a strategy that has little to no effect on PBM􏶱
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto any_valid_distance_m = 1.0;
    auto indexes = mark_lanes_for_local_map_sla_requirement(r,any_valid_distance_m);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮

􏷘+􏷗􏷒create event route􏷑
􏴅Annotated Route􏴆
􏷐Take a translated route, and convert it into an event annotated route􏷏
􏶠The event annotated route will not have any regeneration events marked by default􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to create an event route from􏶿
􏶚m􏶛􏶾event_annotated_route􏶽􏶼event route􏶻􏶺a route with regeneration information attached􏶹
􏶴
    event_route.route_plan_id = route.route_plan_id;
    event_route.evaluation_range.current = route.route_progress_index;
    for (size_t i = 0; i < number_of_lanes(route); ++i){
        lane_event event;
        event.lane.map_ref = route.lane_sequence[i];
        event.lane.annotation = route.annotation_sequence[i];
        event_route.event_lane_sequence.emplace_back(event);
    }
􏶳
􏴯empty conversion􏴰
􏲝We turn an empty route into an event route􏲞
􏲛Implementation is can't convert empty routes to event routes􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto event_route = create_event_route(r);
    
    //ASSERT
    EXPECT_TRUE(event_route.event_lane_sequence.empty());
􏴮
􏴯preserve lane count􏴰
􏲝Converting a route to an event route preserves lane count􏲞
􏲛Conversion is not preserving lane count􏲜
􏴭
    //ARRANGE
    route r;
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 5;
        r.annotation_sequence.emplace_back(annotation);
        
        mlp::lane_graph::map_ref_id ref;
        ref.map_index = hub::base::guid::from_int64(1);
        r.lane_sequence.emplace_back(ref);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 5;
        r.annotation_sequence.emplace_back(annotation);
        
        mlp::lane_graph::map_ref_id ref;
        ref.map_index = hub::base::guid::from_int64(1);
        r.lane_sequence.emplace_back(ref);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 5;
        r.annotation_sequence.emplace_back(annotation);
        
        mlp::lane_graph::map_ref_id ref;
        ref.map_index = hub::base::guid::from_int64(1);
        r.lane_sequence.emplace_back(ref);
    }
    
    //ACT
    auto event_route = create_event_route(r);
    
    //ASSERT
    EXPECT_EQ(event_route.event_lane_sequence.size(),3);
􏴮

􏷘+􏷗􏷒create event route􏷑
􏴅Annotated Route􏴆
􏷐Take the route creation input, and convert it into an event annotated route􏷏
􏶠The event annotated route may have regeneration events marked based on the route creation's annotation strategy􏶡
􏶜􏶝􏷆route_creation_input􏷅􏲥local_map/libs/regeneration/local_map_regeneration_preset_routes􏲦􏷄input􏷃􏷀the input to create an event route from􏶿
􏶚m􏶛􏶾event_annotated_route􏶽􏶼event route􏶻􏲅create_event_route(create_route_from_test_input(input))􏲆􏶺a route with regeneration information attached􏶹
􏶴
􏶳




􏷘+􏷗􏷒set regeneration events􏷑
􏴅Annotated Route􏴆
􏷐Decide where along the event annotated route where to place regeneration events􏷏
􏶠Applies event actions to take on the lane based on the lane indexes given􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to set events on􏶿
􏶜􏶝􏷆unordered_indexes􏷅􏷄lane indexes􏷃􏷀the lane indexes to apply regeneration events to􏶿
􏶜􏶝􏷆regeneration_reason􏷅􏷄reason􏷃􏷀the reason you are regenerating on these lanes􏶿
􏶴
    for (const auto & lane_index: lane_indexes){
        route.event_lane_sequence[lane_index].entrance_event = event_action_regenerate;
        route.event_lane_sequence[lane_index].reason = reason;
    }
􏶳

􏷘+􏷗􏷒set previous index on route􏷑
􏴅Annotated Route􏴆
􏷐explicitly adjust the previous index used in the evaluation range of the route􏷏
􏶠Ideally, you would create an event route, and adjust the evaluation range by advancing forward.  
If you need to create the route in a particular state however, you can explicitly set the starting range of evaluation here􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to update progress on􏶿
􏶜􏶝􏷆size􏷅􏷄previous lane index􏷃􏷀the index of the previous lane we were non􏶿
􏶴
    route.evaluation_range.previous = previous_lane_index;
􏶳

􏷘+􏷗􏷒set current index on route􏷑
􏴅Annotated Route􏴆
􏷐explicitly adjust the current index used in the evaluation range of the route􏷏
􏶠Ideally, you would create an event route, and adjust the evaluation range by advancing forward.  
If you need to create the route in a particular state however, you can explicitly set the ending range of evaluation here􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to update progress on􏶿
􏶜􏶝􏷆size􏷅􏷄current lane index􏷃􏷀the index of the current lane we were non􏶿
􏶴
    route.evaluation_range.current = current_lane_index;
􏶳

􏷘+􏷗􏷒advance forward on route􏷑
􏴅Annotated Route􏴆
􏷐extends the processing view forward to the current lane provided􏷏
􏶠The previous current lane becomes the start of the event view
This way we won't skip any lanes when evaluating for regeneration events􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to update progress on􏶿
􏶜􏶝􏷆size􏷅􏷄current lane index􏷃􏷀the index of the current lane we are on􏶿
􏶴
    route.evaluation_range.previous = route.evaluation_range.current;
    route.evaluation_range.current = current_lane_index;
􏶳

􏷘+􏷗􏷒expire route􏷑
􏴅Annotated Route􏴆
􏷐extends the processing view forward to the end of the route􏷏
􏶠If we have finished the route or have transitioned to a new route, we may still want to process events along the remainder of the previous route
Expiring the route sets a processing view that will allow process to the end despite specifying a lane index􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to update progress on􏶿
􏶴
    route.evaluation_range.previous = route.evaluation_range.current;
    route.evaluation_range.current = stdx::nullopt;
􏶳

􏷘+􏷗􏷒interpret route status􏷑
􏴅Annotated Route􏴆
􏷐interpret the status of the route by observing the range of lanes that need evaluated􏷏
􏶠Based on the status of lanes that need evaluated, we can derive some contextual information about the route􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze the status of􏶿
􏶚m􏶛􏶾route_status􏶽􏶼route interpretation􏶻􏲅route_status_invalid􏲆􏶺an interpretation about the status of the route􏶹
􏶴
    􏶲(n,n) = existing route􏶱
    if (route.evaluation_range.previous && route.evaluation_range.current){
        return route_status_existing_route;
    }
    
    􏶲(?,n) = new route􏶱
    else if(!route.evaluation_range.previous && route.evaluation_range.current){
        return route_status_new_route;
    }
    
    􏶲(n,?) = expired route􏶱
    else if(route.evaluation_range.previous && !route.evaluation_range.current){
        return route_status_expired;
    }
    
    􏶲(?,?) = invalid route􏶱
    else if(!route.evaluation_range.previous && !route.evaluation_range.current){
        return route_status_invalid;
    }
􏶳
􏴯converting a route makes it new􏴰
􏲝Converting a route makes its status new (since we don't have any previous indexes)􏲞
􏲛Converting a route did not make it new􏲜
􏴭
    //ARRANGE
    route r;
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 5;
        r.annotation_sequence.emplace_back(annotation);
        
        mlp::lane_graph::map_ref_id ref;
        ref.map_index = hub::base::guid::from_int64(1);
        r.lane_sequence.emplace_back(ref);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 5;
        r.annotation_sequence.emplace_back(annotation);
        
        mlp::lane_graph::map_ref_id ref;
        ref.map_index = hub::base::guid::from_int64(1);
        r.lane_sequence.emplace_back(ref);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 5;
        r.annotation_sequence.emplace_back(annotation);
        
        mlp::lane_graph::map_ref_id ref;
        ref.map_index = hub::base::guid::from_int64(1);
        r.lane_sequence.emplace_back(ref);
    }
    
    //ACT
    auto event_route = create_event_route(r);
    
    //ASSERT
    EXPECT_EQ(interpret_route_status(event_route),route_status_new_route);
􏴮
􏴯walk though route status􏴰
􏲝We should be able to transition the status from new, to current, to expired􏲞
􏲛Status is not correct when transitioning the status of a route􏲜
􏴭
    //ARRANGE
    route r;
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 5;
        r.annotation_sequence.emplace_back(annotation);
        
        mlp::lane_graph::map_ref_id ref;
        ref.map_index = hub::base::guid::from_int64(1);
        r.lane_sequence.emplace_back(ref);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 5;
        r.annotation_sequence.emplace_back(annotation);
        
        mlp::lane_graph::map_ref_id ref;
        ref.map_index = hub::base::guid::from_int64(1);
        r.lane_sequence.emplace_back(ref);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 5;
        r.annotation_sequence.emplace_back(annotation);
        
        mlp::lane_graph::map_ref_id ref;
        ref.map_index = hub::base::guid::from_int64(1);
        r.lane_sequence.emplace_back(ref);
    }
    
    //ACT
    auto event_route = create_event_route(r);
    
    //ASSERT
    EXPECT_EQ(interpret_route_status(event_route),route_status_new_route);
    
    //ACT
    advance_forward_on_route(event_route,1);
    
    //ASSERT
    EXPECT_EQ(interpret_route_status(event_route),route_status_existing_route);
    
    //ACT
    advance_forward_on_route(event_route,2);
    
    //ASSERT
    EXPECT_EQ(interpret_route_status(event_route),route_status_existing_route);
    
    //ACT
    expire_route(event_route);
    
    //ASSERT
    EXPECT_EQ(interpret_route_status(event_route),route_status_expired);
􏴮

􏷘+􏷗􏷒should regenerate􏷑
􏴅Annotated Route􏴆
􏷐determines whether we should regenerate􏷏
􏶠Uses the internal event view to process over lanes􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze for regeneration􏶿
􏶚m􏶛􏶾bool􏶽􏶼should regenerate􏶻􏲅false􏲆􏶺whether we should regenerate based on our current progress􏶹
􏶴
    􏶲if we already processed the last lane index in the route,􏶱
    􏶲then there is nothing to regenerate􏶱
    if (route.evaluation_range.previous){
        if (*route.evaluation_range.previous == last_lane_index(route)){
            return false;
        }
    }
    

    􏶲get index interval to check for events on􏶱
    size_t start_index = first_index_to_process(route);
    size_t end_index = last_index_to_process(route);
    
    for (size_t i = start_index; i <= end_index; ++i){
        if (route.event_lane_sequence[i].entrance_event == event_action_regenerate){
            return true;
        }
    }
􏶳

􏷘+􏷗􏷒total distance􏷑
􏴅Annotated Route􏴆
􏷐the total distance of the route􏷏
􏶠calculates the total distance of the route by traversing all of the lanes􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to calculate distance over􏶿
􏶚m􏶛􏶾double􏶽􏶼total_distance􏶻􏲅0􏲆􏶺the total distance over the route􏶹
􏶴
    􏶲choosing range iteration over std::accumulate􏶱
    for (const auto & event : route.event_lane_sequence){
        total_distance += event.lane.annotation.distance;
    }
􏶳

􏷘+􏷗􏷒distance to lane index􏷑
􏴅Annotated Route􏴆
􏷐convert the total accumulated distance along the route into the corresponding lane index􏷏
􏶠if we decide to traverse over the route using raw distance, we may also want to match that distance to a particular lane
if the distance provided goes beyond the distance of the route, the no lane index can be returned
if the route is empty, no lane index can be returned􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to find the lane on􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to to traverse the route with to find the corresponding lane􏶿
􏶚m?􏶛􏶾size􏶽􏶼lane index􏶻􏲅stdx::nullopt􏲆􏶺the lane index􏶹
􏶴
    double total_distance_m = 0;
    if (has_lanes(route)){
        for (size_t i = 0; i < number_of_lanes(route); ++i){
            total_distance_m += lane_length(route,i);
            if (total_distance_m > distance_m){
                return i;
            }
        }
    }
􏶳

􏷘-􏷗􏷒first index to process􏷑
􏷐gets the first index to process over the route􏷏
􏶠determined through the event view of the route􏶡
􏴅Detail􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀event annotated route􏶿
􏶚m􏶛􏶾size􏶽􏶼lane index􏶻􏲅0􏲆􏶺the lane index􏶹
􏶴
    􏶲if we don't have a previous index we start processing at the beginning􏶱
    􏶲if we do have a previous index we leave off processing the remaining lanes􏶱
    if (route.evaluation_range.previous){
        lane_index = *route.evaluation_range.previous + 1;
    }
􏶳
􏷘-􏷗􏷒last index to process􏷑
􏷐gets the last index to process over the route􏷏
􏶠determined through the event view of the route􏶡
􏴅Detail􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀event annotated route􏶿
􏶚m􏶛􏶾size􏶽􏶼lane index􏶻􏶺the lane index􏶹
􏶴
    􏶲if we don't have a current index, we process to the end of the route􏶱
    􏶲if we do have have a current index, we use that􏶱
    lane_index = last_lane_index(route);
    if (route.evaluation_range.current){
        lane_index = *route.evaluation_range.current;
    }
􏶳

􏷘-􏷗􏷒last lane index􏷑
􏷐the index of the last lane􏷏
􏶠Assumes the route is not empty􏶡
􏴅Detail􏴆
􏵪!route_is_empty()􏵫
􏵨the route is not empty􏵩
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to get the last lane index from􏶿
􏶚m􏶛􏶾size􏶽􏶼lane index􏶻􏲅0􏲆􏶺the index of the last lane􏶹
􏶴
    if (!route.event_lane_sequence.empty()){
        lane_index = route.event_lane_sequence.size()-1;
    }
􏶳

􏷘-􏷗􏷒insert previous􏷑
􏷐store the previous index􏷏
􏶠Assumes the previous index is valid􏶡
􏴅Detail􏴆
􏵪index != 0􏵫
􏵨the previous index exists􏵩
􏶜mr􏶝􏷆unordered_indexes􏷅􏷄indexes􏷃􏷀indexes􏶿
􏶜􏶝􏷆size􏷅􏷄index􏷃􏷀the next we should store the previous of􏶿
􏶴
    if (index != 0){
        indexes.insert(index-1);
    }
􏶳

􏷘-􏷗􏷒no lane longer than distance􏷑
􏷐checks to see if any individual lane is longer then the distance provided􏷏
􏶠True if any lane is longer; false otherwise.􏶡
􏴅Detail􏴆
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to analyze lane lengths􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to check against􏶿
􏶚m􏶛􏶾bool􏶽􏶼no lane longer􏶻􏶺whether any lane is longer than the distance􏶹
􏶴
    
    􏶲simplify predicate􏶱
    no_lane_longer = std::none_of(route.annotation_sequence.begin(),route.annotation_sequence.end(),[&](const route_planning::lane_neighbor_annotation & annotation){
        return annotation.distance > distance_m;
    });
􏶳

􏷘-􏷗􏷒is positive􏷑
􏷐checks whether the number is positive􏷏
􏶠0 is not positive􏶡
􏴅Detail􏴆
􏶜􏶝􏷆d􏷅􏷄num􏷃􏷀the number to check􏶿
􏶚m􏶛􏶾bool􏶽􏶼is positive􏶻􏲅num > 0􏲆􏶺whether the number is positive􏶹
􏶴􏶳

􏷘-􏷗􏷒has lanes􏷑
􏷐checks whether the route has lanes􏷏
􏶠True if there are any lanes, False if there is not􏶡
􏴅Shared Interface􏴆
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to analyze lane lengths􏶿
􏶚m􏶛􏶾bool􏶽􏶼has lanes􏶻􏲅!route.lane_sequence.empty()􏲆􏶺whether the route has lanes􏶹
􏶴􏶳

􏷘-􏷗􏷒lane length􏷑
􏷐get the length of a particular indexed lane􏷏
􏴅Shared Interface􏴆
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to analyze lane lengths􏶿
􏶜􏶝􏷆size􏷅􏷄index􏷃􏷀the lane index􏶿
􏶚m􏶛􏶾d􏶽􏶼length􏶻􏵜meters􏵝􏲅route.annotation_sequence[index].distance􏲆􏶺the length of the lane􏶹
􏶴􏶳

􏷘-􏷗􏷒number of lanes􏷑
􏷐the number of lanes in the route􏷏
􏴅Shared Interface􏴆
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to count lanes on􏶿
􏶚m􏶛􏶾size􏶽􏶼number of lanes􏶻􏲅route.lane_sequence.size()􏲆􏶺the number of lanes in the route􏶹
􏶴􏶳




􏷘-􏷗􏷒has lanes􏷑
􏷐checks whether the route has lanes􏷏
􏶠True if there are any lanes, False if there is not􏶡
􏴅Shared Interface􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze lane lengths􏶿
􏶚m􏶛􏶾bool􏶽􏶼has lanes􏶻􏲅!route.event_lane_sequence.empty()􏲆􏶺whether the route has lanes􏶹
􏶴􏶳

􏷘-􏷗􏷒lane length􏷑
􏷐get the length of a particular indexed lane􏷏
􏴅Shared Interface􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze lane lengths􏶿
􏶜􏶝􏷆size􏷅􏷄index􏷃􏷀the lane index􏶿
􏶚m􏶛􏶾d􏶽􏶼length􏶻􏵜meters􏵝􏲅route.event_lane_sequence[index].lane.annotation.distance􏲆􏶺the length of the lane􏶹
􏶴􏶳

􏷘-􏷗􏷒number of lanes􏷑
􏷐the number of lanes in the route􏷏
􏴅Shared Interface􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to count lanes on􏶿
􏶚m􏶛􏶾size􏶽􏶼number of lanes􏶻􏲅route.event_lane_sequence.size()􏲆􏶺the number of lanes in the route􏶹
􏶴􏶳