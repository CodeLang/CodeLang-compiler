􏶞g􏶟
􏷲various algorithms for analyzing and lane marking a route
algorithms decide to make markings based on annotated route information, and provided user data􏷱
􏷰there may be various reasons to mark lanes along a route
knowing when to regenerate is one such use case􏷯
􏷮Regeneration􏷭
􏴃Precondition Checks􏴄
􏴁functions for checking the preconditions of various APIs􏴂
􏴃Lane Marking􏴄
􏴁functions that decide where to mark lanes along a route􏴂
􏴃Annotated Route􏴄
􏴁functions related to the annotated route􏴂
􏷬Trevor Hickey􏷫

􏶔s􏶕􏶒algorithm􏶓
􏶔s􏶕􏶒set􏶓

􏷞local_map􏷝􏷞statik􏷝


􏷘+􏷗􏷒precondition mark lanes that exceed accumulated distance􏷑
􏴅Precondition Checks􏴆
􏷐Checks whether the arguments are valid as a precondition to the call􏷏
􏶠This function is a predicate for checking all the necessary preconditions􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to minimally reach􏶿
􏶚m􏶛􏶾bool􏶽􏶼meets preconditions􏶻􏶺whether the arguments meet the implementation's preconditions􏶹
􏶴
    if (!􏵲is positive􏵳􏵶distance􏵷)){
        return false;
    }
    
    meets_preconditions = true;
􏶳

􏷘+􏷗􏷒precondition mark lanes prior to exceeding distance􏷑
􏴅Precondition Checks􏴆
􏷐Checks whether the arguments are valid as a precondition to the call􏷏
􏶠This function is a predicate for checking all the necessary preconditions􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance that must not be exceeded􏶿
􏶚m􏶛􏶾bool􏶽􏶼meets preconditions􏶻􏶺whether the arguments meet the implementation's preconditions􏶹
􏶴
    if (!􏵲is positive􏵳􏵶distance􏵷)){
        return false;
    }
    
    if (!􏵲no lane longer than distance􏵳􏵶route􏵷,􏵶distance􏵷)){
        return false;
    }
    
    meets_preconditions = true;
􏶳

􏷘+􏷗􏷒precondition mark lanes for local map sla requirement􏷑
􏴅Precondition Checks􏴆
􏷐Checks whether the arguments are valid as a precondition to the call􏷏
􏶠This function is a predicate for checking all the necessary preconditions􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to minimally reach􏶿
􏶚m􏶛􏶾bool􏶽􏶼meets preconditions􏶻􏶺whether the arguments meet the implementation's preconditions􏶹
􏶴
    if (!􏵲precondition mark lanes that exceed accumulated distance􏵳􏵶route􏵷,􏵶distance􏵷)){
        return false;
    }
    
    meets_preconditions = true;
􏶳

􏷘+􏷗􏷒mark lanes that exceed accumulated distance􏷑
􏴅Lane Marking􏴆
􏷐mark lanes along that route that exceed an accumulated distance greater than the provided distance􏷏
􏶠Ensures the distance is minimally met along each division made on the route􏶡
􏵪distance_must_be_positive()􏵫
􏵨the distance must be positive􏵩
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏲧local_map/libs/submap/submap_identifier􏲨􏲥local_map/libs/submap/local_map_submap􏲦􏷀the distance to minimally reach􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    double total_distance = 0.0;
    for (size_t i = 0; i < 􏵶route􏵷.annotation_sequence.size(); ++i){
        double lane_distance_m = 􏵶route􏵷.annotation_sequence[i].distance;
        if (total_distance+lane_distance_m > 􏵶distance􏵷){
            lane_indexes.insert(i);
            total_distance = 0;
        }
        else{
            total_distance += lane_distance_m;
        }
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto any_valid_distance_m = 1.0;
    auto indexes = mark_lanes_that_exceed_accumulated_distance(r,any_valid_distance_m);
    
    //ASSERT
    ASSERT_TRUE(indexes.empty());
􏴮
􏴯mark every lane􏴰
􏲝If every lane exceeds the distance given, all of the lanes should be marked􏲞
􏲛Implementation is no longer handling the exceeded distance check properly􏲜
􏴭
    //ARRANGE
    route r;
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 100;
        r.annotation_sequence.emplace_back(annotation);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 100;
        r.annotation_sequence.emplace_back(annotation);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 100;
        r.annotation_sequence.emplace_back(annotation);
    }
    
    //ACT
    auto distance_m = 50;
    auto indexes = mark_lanes_that_exceed_accumulated_distance(r,distance_m);
    
    //ASSERT
    ASSERT_EQ(indexes.size(),3);
    ASSERT_TRUE(indexes.find(0) != indexes.end());
    ASSERT_TRUE(indexes.find(1) != indexes.end());
    ASSERT_TRUE(indexes.find(2) != indexes.end());
􏴮
􏴯mark every other lane􏴰
􏲝If the distance is exceeded every other lane, we should have every other lane marked􏲞
􏲛Implementation is no longer handling the exceeded distance check properly􏲜
􏴭
    //ARRANGE
    route r;
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 100;
        r.annotation_sequence.emplace_back(annotation);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 100;
        r.annotation_sequence.emplace_back(annotation);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 100;
        r.annotation_sequence.emplace_back(annotation);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 100;
        r.annotation_sequence.emplace_back(annotation);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 100;
        r.annotation_sequence.emplace_back(annotation);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 100;
        r.annotation_sequence.emplace_back(annotation);
    }
    
    //ACT
    auto distance_m = 101;
    auto indexes = mark_lanes_that_exceed_accumulated_distance(r,distance_m);
    
    //ASSERT
    ASSERT_EQ(indexes.size(),3);
    ASSERT_TRUE(indexes.find(0) == indexes.end());
    ASSERT_TRUE(indexes.find(1) != indexes.end());
    ASSERT_TRUE(indexes.find(2) == indexes.end());
    ASSERT_TRUE(indexes.find(3) != indexes.end());
    ASSERT_TRUE(indexes.find(4) == indexes.end());
    ASSERT_TRUE(indexes.find(5) != indexes.end());
􏴮
􏴯distance not reached􏴰
􏲝If the distance is never reached along the route, no lanes should be marked􏲞
􏲛Implementation is accidentally marking lanes before the distance is exceeded along the route􏲜
􏴭
    //ARRANGE
    route r;
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 25;
        r.annotation_sequence.emplace_back(annotation);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 25;
        r.annotation_sequence.emplace_back(annotation);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 25;
        r.annotation_sequence.emplace_back(annotation);
    }
    {
        route_planning::lane_neighbor_annotation annotation;
        annotation.distance = 25;
        r.annotation_sequence.emplace_back(annotation);
    }
    
    //ACT
    auto distance_m = 100;
    auto indexes = mark_lanes_that_exceed_accumulated_distance(r,distance_m);
    
    //ASSERT
    ASSERT_TRUE(indexes.empty());
    ASSERT_TRUE(indexes.find(0) == indexes.end());
    ASSERT_TRUE(indexes.find(1) == indexes.end());
    ASSERT_TRUE(indexes.find(2) == indexes.end());
    ASSERT_TRUE(indexes.find(3) == indexes.end());
􏴮

􏷘+􏷗􏷒mark lanes prior to exceeding accumulated distance􏷑
􏴅Lane Marking􏴆
􏷐mark lanes along that route that each division does not exceed the distance given􏷏
􏶠Ensures no division is greater than the distance provided􏶡
􏵪distance_must_be_positive()􏵫
􏵨the distance must be positive􏵩
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏲧local_map/libs/submap/submap_identifier􏲨􏲥local_map/libs/submap/local_map_submap􏲦􏷀the distance that must not be exceeded􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    double total_distance = 0.0;
    for (size_t i = 0; i < 􏵶route􏵷.annotation_sequence.size(); ++i){
        double lane_distance_m = 􏵶route􏵷.annotation_sequence[i].distance;
        if (total_distance+lane_distance_m > 􏵶distance􏵷){
            􏵲insert previous􏵳lane_indexes,i);
            total_distance = lane_distance_m;
        }
        else{
            total_distance += lane_distance_m;
        }
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto any_valid_distance_m = 1.0;
    auto indexes = mark_lanes_prior_to_exceeding_accumulated_distance(r,any_valid_distance_m);
    
    //ASSERT
    ASSERT_TRUE(indexes.empty());
􏴮

􏷘+􏷗􏷒mark lanes prior to forming a submap loop􏷑
􏴅Lane Marking􏴆
􏷐Mark the lanes prior to the lanes that would create a submap loop􏷏
􏶠Ensures that each marked lane comes before a submap loop is formed along the route􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨
􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    std::set<hub::base::guid> seen;
    hub::base::guid previous;
    for (size_t i = 0; i < 􏵶route􏵷.lane_sequence.size(); ++i){
        auto id = local_map::internal::submap_identifier(􏵶route􏵷.lane_sequence[i]);
        
        if (previous != id){
            if (seen.find(id) != seen.end()){
                􏵲insert previous􏵳lane_indexes,i);
                seen.clear();
            }
        }
        previous = id;
        seen.insert(id);
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = mark_lanes_prior_to_forming_a_submap_loop(r);
    
    //ASSERT
    ASSERT_TRUE(indexes.empty());
􏴮

􏷘+􏷗􏷒mark first lanes involved in submap loop􏷑
􏴅Lane Marking􏴆
􏷐when we detect submap loops, mark the first lane that is part of the submap loop􏷏
􏶠Ensures that each marked lane is the first lane in a submap that is part of a submap loop􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    std::map<hub::base::guid,size_t> seen;
    hub::base::guid previous;
    
    
    for (size_t i = 0; i < 􏵶route􏵷.lane_sequence.size(); ++i){
        auto id = local_map::internal::submap_identifier(􏵶route􏵷.lane_sequence[i]);
        
        if (previous != id){
            auto found = seen.find(id);
            if (found != seen.end()){
                lane_indexes.insert(found->second);
                seen.clear();
            }
        }
        previous = id;
        seen[id] = i;
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = mark_first_lanes_involved_in_submap_loop(r);
    
    //ASSERT
    ASSERT_TRUE(indexes.empty());
􏴮

􏷘+􏷗􏷒mark first lanes after loop causing submap􏷑
􏴅Lane Marking􏴆
􏷐when we detect submap loops, mark the first lane along the route that is past the conflicting submap􏷏
􏶠The lanes that are marked are still a part of the overall loop, but we are now outside the submap that we will later revisit􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    auto conflicting_submap_indexes = 􏵲mark first lanes involved in submap loop􏵳􏵶route􏵷);
    for (auto const& it: conflicting_submap_indexes){
        auto conflicting_submap = local_map::internal::submap_identifier(􏵶route􏵷.lane_sequence[it]);
        for (size_t i = it; i < 􏵶route􏵷.lane_sequence.size(); ++i){
            auto next_submap = local_map::internal::submap_identifier(􏵶route􏵷.lane_sequence[i]);
            if (next_submap != conflicting_submap){
                lane_indexes.insert(i);
                break;
            }
        }
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = mark_first_lanes_after_loop_causing_submap(r);
    
    //ASSERT
    ASSERT_TRUE(indexes.empty());
􏴮

􏷘+􏷗􏷒mark lanes that transition to new submaps􏷑
􏴅Lane Marking􏴆
􏷐mark every lane that transitions to a different submap􏷏
􏶠Ensures that each marked lane exists in a different submap that the previous marked lane􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    hub::base::guid previous;
    for (size_t i = 0; i < 􏵶route􏵷.lane_sequence.size(); ++i){
        auto id = local_map::internal::submap_identifier(􏵶route􏵷.lane_sequence[i]);
        
        if (previous != id){
            lane_indexes.insert(i);
        }
        previous = id;
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = mark_lanes_that_transition_to_new_submaps(r);
    
    //ASSERT
    ASSERT_TRUE(indexes.empty());
􏴮

􏷘+􏷗􏷒mark first lane􏷑
􏴅Lane Marking􏴆
􏷐Marks the first lane of the route􏷏
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    if (􏵲has lanes􏵳􏵶route􏵷)){
        lane_indexes.insert(0);
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = mark_first_lane(r);
    
    //ASSERT
    ASSERT_TRUE(indexes.empty());
􏴮

􏷘+􏷗􏷒mark last lane􏷑
􏴅Lane Marking􏴆
􏷐Marks the last lane of the route􏷏
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    if (􏵲has lanes􏵳􏵶route􏵷)){
        lane_indexes.insert(􏵶route􏵷.lane_sequence.size() -1);
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = mark_last_lane(r);
    
    //ASSERT
    ASSERT_TRUE(indexes.empty());
􏴮

􏷘+􏷗􏷒mark all lanes􏷑
􏴅Lane Marking􏴆
􏷐Marks all of the lanes in the route􏷏
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    for (size_t i = 0; i < 􏵶route􏵷.lane_sequence.size(); ++i){
        lane_indexes.insert(i);
    }
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = mark_all_lanes(r);
    
    //ASSERT
    ASSERT_TRUE(indexes.empty());
􏴮

􏷘+􏷗􏷒mark lanes for local map sla requirement􏷑
􏴅Lane Marking􏴆
􏷐marks lanes based on the local map's regeneration SLA requirements􏷏
􏶠Ensures that the proper lanes are marked to guarantee by the local map's SLA requirements during regeneration􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to mark lanes on􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to minimally reach􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺marked lanes along the route􏶹
􏶴
    􏶲perform marking policy􏶱
    lane_indexes = 􏵲mark lanes that exceed accumulated distance􏵳􏵶route􏵷,􏵶distance􏵷);
    
    􏶲perform marking policy􏶱
    auto loop_marks = 􏵲mark lanes prior to forming a submap loop􏵳􏵶route􏵷);
    
    􏶲combine policy results􏶱
    lane_indexes.insert(loop_marks.begin(),loop_marks.end());
    
    􏶲we may want to do additional filtering􏶱
􏶳
􏴯empty􏴰
􏲝We should be able to mark empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto any_valid_distance_m = 1.0;
    auto indexes = mark_lanes_for_local_map_sla_requirement(r,any_valid_distance_m);
    
    //ASSERT
    ASSERT_TRUE(indexes.empty());
􏴮

􏷘+􏷗􏷒create event route􏷑
􏴅Annotated Route􏴆
􏷐Take a translated route, and convert it into an event annotated route􏷏
􏶠The event annotated route will not have any regeneration events marked by default􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to create an event route from􏶿
􏶚m􏶛􏶾event_annotated_route􏶽􏶼event route􏶻􏶺a route with regeneration information attached􏶹
􏶴
    event_route.route_plan_id = 􏵶route􏵷.route_plan_id;
    event_route.evaluation_range.current = 􏵶route􏵷.route_progress_index;
    for (size_t i = 0; i < 􏵶route􏵷.lane_sequence.size(); ++i){
        lane_event event;
        event.lane.map_ref = 􏵶route􏵷.lane_sequence[i];
        event.lane.annotation = 􏵶route􏵷.annotation_sequence[i];
        event_route.event_lane_sequence.emplace_back(event);
    }
􏶳

􏷘+􏷗􏷒set regeneration events􏷑
􏴅Annotated Route􏴆
􏷐Decide where along the event annotated route where to place regeneration events􏷏
􏶠Applies event actions to take on the lane based on the lane indexes given􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to set events on􏶿
􏶜􏶝􏷆unordered_indexes􏷅􏷄lane indexes􏷃􏷀the lane indexes to apply regeneration events to􏶿
􏶜􏶝􏷆regeneration_reason􏷅􏷄reason􏷃􏷀the reason you are regenerating on these lanes􏶿
􏶴
    for (const auto & lane_index: 􏵶lane indexes􏵷){
        􏵶route􏵷.event_lane_sequence[lane_index].entrance_event = event_action_regenerate;
        􏵶route􏵷.event_lane_sequence[lane_index].reason = 􏵶reason􏵷;
    }
􏶳

􏷘+􏷗􏷒advance forward on route􏷑
􏴅Annotated Route􏴆
􏷐extends the processing view forward to the current lane provided􏷏
􏶠The previous current lane becomes the start of the event view
This way we won't skip any lanes when evaluating for regeneration events􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to update progress on􏶿
􏶜􏶝􏷆size􏷅􏷄current lane index􏷃􏷀the index of the current lane we are on􏶿
􏶴
    􏵶route􏵷.evaluation_range.previous = 􏵶route􏵷.evaluation_range.current;
    􏵶route􏵷.evaluation_range.current = 􏵶current lane index􏵷;
􏶳

􏷘+􏷗􏷒expire route􏷑
􏴅Annotated Route􏴆
􏷐extends the processing view forward to the end of the route􏷏
􏶠If we have finished the route or have transitioned to a new route, we may still want to process events along the remainder of the previous route
Expiring the route sets a processing view that will allow process to the end despite specifying a lane index􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to update progress on􏶿
􏶴
    􏵶route􏵷.evaluation_range.previous = 􏵶route􏵷.evaluation_range.current;
    􏵶route􏵷.evaluation_range.current = stdx::nullopt;
􏶳

􏷘+􏷗􏷒interpret route status􏷑
􏴅Annotated Route􏴆
􏷐interpret the status of the route by observing the range of lanes that need evaluated􏷏
􏶠Based on the status of lanes that need evaluated, we can derive some contextual information about the route􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze the status of􏶿
􏶚m􏶛􏶾route_status􏶽􏶼route interpretation􏶻􏶺an interpretation about the status of the route􏶹
􏶴

    route_interpretation = route_status_invalid;
    
    􏶲(n,n) = existing route􏶱
    if (􏵶route􏵷.evaluation_range.previous && 􏵶route􏵷.evaluation_range.current){
        return route_status_existing_route;
    }
    
    􏶲(?,n) = new route􏶱
    else if(!􏵶route􏵷.evaluation_range.previous && 􏵶route􏵷.evaluation_range.current){
        return route_status_new_route;
    }
    
    􏶲(n,?) = expired route􏶱
    else if(􏵶route􏵷.evaluation_range.previous && !􏵶route􏵷.evaluation_range.current){
        return route_status_expired;
    }
    
    􏶲(?,?) = invalid route􏶱
    else if(!􏵶route􏵷.evaluation_range.previous && !􏵶route􏵷.evaluation_range.current){
        return route_status_invalid;
    }
􏶳

􏷘+􏷗􏷒should regenerate􏷑
􏴅Annotated Route􏴆
􏷐determines whether we should regenerate􏷏
􏶠Uses the internal event view to process over lanes􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze for regeneration􏶿
􏶚m􏶛􏶾bool􏶽􏶼should regenerate􏶻􏶺whether we should regenerate based on our current progress􏶹
􏶴
    􏶲if we already processed the last lane index in the route,􏶱
    􏶲then there is nothing to regenerate􏶱
    if (􏵶route􏵷.evaluation_range.previous){
        if (*􏵶route􏵷.evaluation_range.previous == 􏵲last lane index􏵳􏵶route􏵷)){
            return false;
        }
    }
    

    􏶲get index interval to check for events on􏶱
    size_t start_index = 􏵲first index to process􏵳􏵶route􏵷);
    size_t end_index = 􏵲last index to process􏵳􏵶route􏵷);
    
    for (size_t i = start_index; i <= end_index; ++i){
        if (􏵶route􏵷.event_lane_sequence[i].entrance_event == event_action_regenerate){
            return true;
        }
    }
    
    should_regenerate = false;
􏶳

􏷘-􏷗􏷒first index to process􏷑
􏷐gets the first index to process over the route􏷏
􏶠determined through the event view of the route􏶡
􏴅Detail􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀event annotated route􏶿
􏶚m􏶛􏶾size􏶽􏶼lane index􏶻􏶺the lane index􏶹
􏶴
    􏶲if we don't have a previous index we start processing at the beginning􏶱
    􏶲if we do have a previous index we leave off processing the remaining lanes􏶱
    lane_index = 0;
    if (􏵶route􏵷.evaluation_range.previous){
        lane_index = *􏵶route􏵷.evaluation_range.previous + 1;
    }
􏶳
􏷘-􏷗􏷒last index to process􏷑
􏷐gets the last index to process over the route􏷏
􏶠determined through the event view of the route􏶡
􏴅Detail􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀event annotated route􏶿
􏶚m􏶛􏶾size􏶽􏶼lane index􏶻􏶺the lane index􏶹
􏶴
    􏶲if we don't have a current index, we process to the end of the route􏶱
    􏶲if we do have have a current index, we use that􏶱
    lane_index = 􏵲last lane index􏵳􏵶route􏵷);
    if (􏵶route􏵷.evaluation_range.current){
        lane_index = *􏵶route􏵷.evaluation_range.current;
    }
􏶳

􏷘-􏷗􏷒last lane index􏷑
􏷐the index of the last lane􏷏
􏶠Assumes the route is not empty􏶡
􏴅Detail􏴆
􏵪!route_is_empty()􏵫
􏵨the route is not empty􏵩
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to get the last lane index from􏶿
􏶚m􏶛􏶾size􏶽􏶼lane index􏶻􏶺the index of the last lane􏶹
􏶴
    􏶲isolated because we may or may not apply precondition check􏶱
    return 􏵶route􏵷.event_lane_sequence.size()-1;
􏶳

􏷘-􏷗􏷒insert previous􏷑
􏷐store the previous index􏷏
􏶠Assumes the previous index is valid􏶡
􏴅Detail􏴆
􏵪index != 0􏵫
􏵨the previous index exists􏵩
􏶜m􏶝􏷆unordered_indexes􏷅􏷄indexes􏷃􏷀indexes􏶿
􏶜􏶝􏷆size􏷅􏷄index􏷃􏷀the next we should store the previous of􏶿
􏶴
    􏶲isolated because we may or may not apply precondition check􏶱
    􏵶indexes􏵷.insert(􏵶index􏵷-1);
􏶳

􏷘-􏷗􏷒no lane longer than distance􏷑
􏷐checks to see if any individual lane is longer then the distance provided􏷏
􏶠True if any lane is longer; false otherwise.􏶡
􏴅Detail􏴆
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to analyze lane lengths􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to check against􏶿
􏶚m􏶛􏶾bool􏶽􏶼no lane longer􏶻􏶺whether any lane is longer than the distance􏶹
􏶴
    
    􏶲simplify predicate􏶱
    no_lane_longer = std::none_of(route.annotation_sequence.begin(),route.annotation_sequence.end(),[&](const route_planning::lane_neighbor_annotation & annotation){
        return annotation.distance > distance_m;
    });
􏶳

􏷘-􏷗􏷒is positive􏷑
􏷐checks whether the number is positive􏷏
􏶠0 is not positive􏶡
􏴅Detail􏴆
􏶜􏶝􏷆d􏷅􏷄num􏷃􏷀the number to check􏶿
􏶚m􏶛􏶾bool􏶽􏶼is positive􏶻􏶺whether the number is positive􏶹
􏶴
    is_positive = 􏵶num􏵷 > 0;
􏶳

􏷘-􏷗􏷒has lanes􏷑
􏷐checks whether the route has lanes􏷏
􏴅Detail􏴆
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to analyze lane lengths􏶿
􏶚m􏶛􏶾bool􏶽􏶼has lanes􏶻􏶺whether the route has lanes􏶹
􏶴
    has_lanes = !􏵶route􏵷.lane_sequence.empty();
􏶳