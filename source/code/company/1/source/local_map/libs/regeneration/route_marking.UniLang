􏶞g􏶟
􏷲various algorithms for analyzing and cutting a route
algorithms decide to make cuts based on annotated route information, and provided user data􏷱
􏷰there may be various reasons to cut a route
knowing when to regenerate is one such use case􏷯
􏷮Regeneration􏷭
􏴃cutting􏴄
􏴁functions that decide where to cut the route􏴂
􏷬Trevor Hickey􏷫

􏶔s􏶕􏶒algorithm􏶓
􏶔s􏶕􏶒set􏶓

􏷞local_map􏷝􏷞statik􏷝

􏷘+􏷗􏷒cut for distance􏷑
􏴅cutting􏴆
􏷐Cuts the route based on distance􏷏
􏶠Ensures that no cute route is greater than the distance provided􏶡
􏵪no partition longer than distance􏵫
􏵨we cannot cut for distance if there is a partition longer than the distance provided􏵩
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to apply cuts to􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to cut with􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼cut indexes􏶻􏶺indexes along the route to cut􏶹
􏶴
    double total_distance = 0.0;
    for (size_t i = 0; i < 􏵶route􏵷.annotation_sequence.size(); ++i){
        double partition_distance_m = 􏵶route􏵷.annotation_sequence[i].distance;
        if (total_distance+partition_distance_m > 􏵶distance􏵷){
            􏵲insert previous􏵳cut_indexes,i);
            total_distance = partition_distance_m;
        }
        else{
            total_distance += partition_distance_m;
        }
    }
􏶳

􏷘-􏷗􏷒insert previous􏷑
􏷐store the previous index􏷏
􏶠Assumes the previous index is valid􏶡
􏵪index != 0􏵫
􏵨the previous index exists􏵩
􏶜m􏶝􏷆unordered_indexes􏷅􏷄indexes􏷃􏷀indexes􏶿
􏶜􏶝􏷆size􏷅􏷄index􏷃􏷀the next we should store the previous of􏶿
􏶴
    􏶲isolated because we may or may not apply precondition check􏶱
    􏵶indexes􏵷.insert(􏵶index􏵷-1);
􏶳

􏷘-􏷗􏷒no partition longer than distance􏷑
􏷐checks to see if any individual partition is longer then the distance provided􏷏
􏶠True if any partition is longer; false otherwise.􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to analyze partition lengths􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to check against􏶿
􏶚m􏶛􏶾bool􏶽􏶼no partition longer􏶻􏶺whether any partition is longer than the distance􏶹
􏶴
    
    􏶲simplify predicate􏶱
    no_partition_longer = std::none_of(route.annotation_sequence.begin(),route.annotation_sequence.end(),[&](const route_planning::lane_neighbor_annotation & annotation){
        return annotation.distance > distance_m;
    });
    
􏶳

􏷘+􏷗􏷒cut for loops􏷑
􏴅cutting􏴆
􏷐Cuts the route based on discovered loops􏷏
􏶠Ensures that no cute route has any loops (i.e. no duplicate partitions)􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to apply cuts to􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼cut indexes􏶻􏶺indexes along the route to cut􏶹
􏶴
    std::set<mlp::lane_graph::map_ref_id> seen;
    for (size_t i = 0; i < 􏵶route􏵷.lane_sequence.size(); ++i){
        auto id = 􏵶route􏵷.lane_sequence[i];
        if (seen.find(id) != seen.end()){
            􏵲insert previous􏵳cut_indexes,i);
            seen.clear();
        }
        seen.insert(id);
    }
􏶳

􏷘+􏷗􏷒cut for local map sla requirements􏷑
􏴅cutting􏴆
􏷐Cuts the route based on the local map's regeneration SLA requirements􏷏
􏶠Ensures that no cute route violates any regeneration restrictions guaranteed by the local map's SLA􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to apply cuts to􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to cut with􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼cut indexes􏶻􏶺indexes along the route to cut􏶹
􏶴
    􏶲perform cut policy􏶱
    cut_indexes = 􏵲cut for distance􏵳􏵶route􏵷,􏵶distance􏵷);
    
    􏶲perform cut policy􏶱
    auto loop_cuts = 􏵲cut for loops􏵳􏵶route􏵷);
    
    􏶲combine policy results􏶱
    cut_indexes.insert(loop_cuts.begin(),loop_cuts.end());
    
    􏶲we may want to do additional filtering􏶱
􏶳
