#include "local_map/libs/regeneration/route_marking.hh"
#include "local_map/libs/regeneration/event_annotations.hh"
#include "local_map/libs/regeneration/preset_routes.hh"

#include "imgui.h"
#include "imgui_impl_sdl.h"
#include "imgui_impl_opengl3.h"
#include <GL/gl3w.h>
#include "SDL.h"

#include <iostream>
#include <cstdlib>
#include <stdio.h>


// all settings
struct window_position
{
    bool       force     = true;
    int        x         = 0;
    int        y         = 0;
    ImGuiCond_ condition = ImGuiCond_Always;
};
struct position
{
    int x = 0;
    int y = 0;
};

struct window_size
{
    bool       force     = true;
    int        width     = 400;
    int        height    = 200;
    ImGuiCond_ condition = ImGuiCond_Always;
};

struct menu_properties
{
    std::string title;
    std::string shortcut;
};

struct window_properties
{
    std::string     title;
    window_position position;
    window_size     size;
    menu_properties menu;
    bool            titlebar  = true;
    bool            scrollbar = true;
    bool            has_menu  = false;
    bool            move      = true;
    bool            resize    = true;
    bool            collapse  = true;
    bool            nav       = true;
    bool            close     = false;
    bool            is_open   = false;
    bool            focus     = true;
    float           bg_alpha  = 1;
};

struct color
{
    int r     = 0;
    int g     = 0;
    int b     = 0;
    int alpha = 255;
    color()   = default;
    color(int r, int g, int b, int alpha) : r(r), g(g), b(b), alpha(alpha) {}
};


struct rectangle_settings
{
    int   width     = 50;
    int   height    = 50;
    int   thickness = 1;
    color color_border;
    color color_fill;
};

struct rectangle_events
{
    bool hovered = false;
};

struct event_route_render_settings
{
    bool               draw_lanes            = true;
    bool               draw_submaps          = true;
    bool               draw_evaluation_range = true;
    rectangle_settings lane_annotated;
    rectangle_settings lane_unannotated;
    rectangle_settings submap;

    // generated colors
    std::vector<color> distinct_colors;
};

struct settings
{
    // windows
    window_properties annotated_route_window;
    window_properties create_route_window;

    // rendering
    event_route_render_settings event_route;
};

static void ShowHelpMarker(const char *desc)
{
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered())
    {
        ImGui::BeginTooltip();
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

std::vector<color> distinct_colors()
{
    std::vector<color> colors;
    colors.emplace_back(0, 130, 200, 255);
    colors.emplace_back(245, 130, 48, 255);
    colors.emplace_back(0, 128, 128, 255);
    colors.emplace_back(230, 25, 75, 255);
    colors.emplace_back(60, 180, 75, 255);
    colors.emplace_back(250, 190, 190, 255);
    colors.emplace_back(255, 255, 25, 255);
    return colors;
}

void create_window(window_properties &properties)
{

    ImGuiWindowFlags window_flags = 0;
    bool *           p_open       = NULL;
    if (!properties.titlebar)
    {
        window_flags |= ImGuiWindowFlags_NoTitleBar;
    }
    if (!properties.scrollbar)
    {
        window_flags |= ImGuiWindowFlags_NoScrollbar;
    }
    if (properties.has_menu)
    {
        window_flags |= ImGuiWindowFlags_MenuBar;
    }
    if (!properties.move)
    {
        window_flags |= ImGuiWindowFlags_NoMove;
    }
    if (!properties.resize)
    {
        window_flags |= ImGuiWindowFlags_NoResize;
    }
    if (!properties.collapse)
    {
        window_flags |= ImGuiWindowFlags_NoCollapse;
    }
    if (!properties.nav)
    {
        window_flags |= ImGuiWindowFlags_NoNav;
    }
    if (!properties.close)
    {
        p_open = NULL;
    }

    if (properties.position.force)
    {
        ImGui::SetNextWindowPos(ImVec2(properties.position.x, properties.position.y), properties.position.condition);
        properties.position.force = false;
    }

    if (properties.size.force)
    {
        ImGui::SetNextWindowSize(ImVec2(properties.size.width, properties.size.height), properties.size.condition);
        properties.size.force = false;
    }

    ImGui::SetNextWindowBgAlpha(properties.bg_alpha);
    if (properties.focus)
    {
        ImGui::SetNextWindowFocus();
        properties.focus = false;
    }
    ImGui::Begin(properties.title.c_str(), &properties.is_open, window_flags);
}

position window_adjusted_position(int x, int y)
{
    const ImVec2 screen_position = ImGui::GetCursorScreenPos();
    position     p;
    p.x = x + screen_position.x;
    p.y = y + screen_position.y;
    return p;
}


void colorize_red_button()
{
    ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4) ImColor::HSV(0, 0.6f, 0.6f));
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4) ImColor::HSV(0, 0.7f, 0.7f));
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4) ImColor::HSV(0, 0.8f, 0.8f));
}
void colorize_yellow_button()
{
    ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4) ImColor::HSV(1 / 7.0f, 0.6f, 0.6f));
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4) ImColor::HSV(1 / 7.0f, 0.7f, 0.7f));
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4) ImColor::HSV(1 / 7.0f, 0.8f, 0.8f));
}
void colorize_green_button()
{
    ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4) ImColor::HSV(2 / 7.0f, 0.6f, 0.6f));
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4) ImColor::HSV(2 / 7.0f, 0.7f, 0.7f));
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4) ImColor::HSV(2 / 7.0f, 0.8f, 0.8f));
}
void colorize_turquoise_button()
{
    ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4) ImColor::HSV(3 / 7.0f, 0.6f, 0.6f));
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4) ImColor::HSV(3 / 7.0f, 0.7f, 0.7f));
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4) ImColor::HSV(3 / 7.0f, 0.8f, 0.8f));
}

void draw_range(ImDrawList *draw_list)
{
}

rectangle_events draw_rectangle(ImDrawList *draw_list, position pos, rectangle_settings const &settings)
{
    draw_list->AddRectFilled(
        ImVec2(pos.x, pos.y),
        ImVec2(pos.x + settings.width, pos.y + settings.height),
        IM_COL32(settings.color_fill.r, settings.color_fill.g, settings.color_fill.b, settings.color_fill.alpha),
        0,
        ImDrawCornerFlags_All);

    draw_list->AddRect(
        ImVec2(pos.x, pos.y),
        ImVec2(pos.x + settings.width, pos.y + settings.height),
        IM_COL32(
            settings.color_border.r, settings.color_border.g, settings.color_border.b, settings.color_border.alpha),
        0,
        ImDrawCornerFlags_All,
        settings.thickness);

    rectangle_events events;
    if (ImGui::IsMouseHoveringRect(
            ImVec2(pos.x, pos.y), ImVec2(pos.x + settings.width, pos.y + settings.height), false))
    {
        events.hovered = true;
    }

    return events;
}

void render(ImDrawList *                         draw_list,
            const local_map::statik::event_view &view,
            const position &                     pos,
            const int                            spanning_length,
            const size_t &                       lane_count)
{
    int start_x = 0;
    if (view.previous)
    {
        start_x = pos.x + ((spanning_length - 1) * (*view.previous)) + (spanning_length / 2);
    }
    else
    {
        start_x = pos.x - (spanning_length / 2);
    }

    int end_x = 0;
    if (view.current)
    {
        end_x = pos.x + ((spanning_length - 1) * (*view.current)) + (spanning_length / 2);
    }
    else
    {
        end_x = pos.x + ((spanning_length - 1) * lane_count) + (spanning_length / 2);
    }


    auto start_vec1 = ImVec2(start_x, pos.y + spanning_length);
    auto start_vec2 = ImVec2(start_x, pos.y + spanning_length + 10);
    auto end_vec1   = ImVec2(end_x, pos.y + spanning_length);
    auto end_vec2   = ImVec2(end_x, pos.y + spanning_length + 10);

    auto connect_vec1 = ImVec2(start_x, pos.y + spanning_length + 10);
    auto connect_vec2 = ImVec2(end_x, pos.y + spanning_length + 10);

    auto test     = pos.x + (end_x - start_x) - spanning_length;
    auto bar_vec1 = ImVec2(test, pos.y + spanning_length + 10);
    auto bar_vec2 = ImVec2(test, pos.y + spanning_length + 20);

    draw_list->AddLine(start_vec1, start_vec2, IM_COL32(0, 0, 0, 255), 1);
    draw_list->AddLine(end_vec1, end_vec2, IM_COL32(0, 0, 0, 255), 1);
    draw_list->AddLine(connect_vec1, connect_vec2, IM_COL32(0, 0, 0, 255), 1);
    draw_list->AddLine(bar_vec1, bar_vec2, IM_COL32(0, 0, 0, 255), 1);
}

void render(local_map::statik::event_annotated_route const &route, event_route_render_settings const &settings)
{

    ImDrawList *draw_list = ImGui::GetWindowDrawList();

    auto pos = window_adjusted_position(180, 85);

    // decide submap colors
    std::map<hub::base::guid, color> submap_colors;
    for (auto lane : route.event_lane_sequence)
    {
        if (submap_colors.find(lane.lane.map_ref.map_index) == submap_colors.end())
        {
            if (settings.distinct_colors.size() >= submap_colors.size())
            {
                submap_colors[lane.lane.map_ref.map_index] = settings.distinct_colors[submap_colors.size()];
            }
            else
            {
                submap_colors[lane.lane.map_ref.map_index] = settings.distinct_colors[0];
            }
        }
    }

    // build submap settings
    std::vector<rectangle_settings> submap_settings;
    rectangle_settings              temp = settings.submap;
    stdx::optional<hub::base::guid> previous_guid;
    for (auto lane : route.event_lane_sequence)
    {
        if (previous_guid)
        {
            if (*previous_guid == lane.lane.map_ref.map_index)
            {
                temp.width += settings.submap.width;
            }
            else
            {
                temp.color_fill = submap_colors[previous_guid];
                submap_settings.emplace_back(temp);
                temp = settings.submap;
            }
        }

        previous_guid = lane.lane.map_ref.map_index;
    }
    temp.color_fill = submap_colors[previous_guid];
    submap_settings.emplace_back(temp);


    // draw submap settings
    if (settings.draw_submaps)
    {
        for (auto s : submap_settings)
        {
            pos.x -= (s.width / settings.submap.width) - 1;
            draw_rectangle(draw_list, pos, s);
            pos.x += s.width;
        }
    }


    // draw lanes
    pos = window_adjusted_position(180, 100);
    if (settings.draw_lanes)
    {
        for (auto lane : route.event_lane_sequence)
        {
            draw_rectangle(draw_list, pos, settings.lane_annotated);
            pos.x += settings.lane_annotated.width - 1;
        }
    }
    pos = window_adjusted_position(180, 100);


    // rectangle_settings lane_annotated;
    // rectangle_settings lane_unannotated;
    // rectangle_settings submap;


    // draw the event window
    if (settings.draw_evaluation_range)
    {
        render(draw_list, route.evaluation_range, pos, settings.lane_annotated.width, route.event_lane_sequence.size());
    }


    pos.y += settings.lane_annotated.width + 30;
}

void render(std::vector<local_map::statik::event_annotated_route> const &event_routes,
            event_route_render_settings const &                          settings)
{
    for (auto route : event_routes)
    {
        render(route, settings);
    }

    ImGui::End();
}

std::set<size_t> render(local_map::statik::lane_creation_input &lane,
                        size_t &                                index,
                        std::set<size_t> &                      remove_indexes,
                        std::set<size_t> &                      insert_indexes)
{

    ImGui::PushItemWidth(50);
    std::string name = "##submap" + std::to_string(index);
    ImGui::InputInt(name.c_str(), &lane.submap_id, 0, 0);
    ImGui::PopItemWidth();

    ImGui::NextColumn();

    // ImGui::SameLine();
    ImGui::PushItemWidth(50);
    name       = "##distance" + std::to_string(index);
    float test = lane.distance_m;
    ImGui::DragFloat(name.c_str(), &test, 1.0f, 0.0f);
    lane.distance_m = test;
    if (lane.distance_m < 0)
    {
        lane.distance_m = 0;
    }
    ImGui::PopItemWidth();

    ImGui::NextColumn();


    // insert button
    ImGui::SameLine();
    ImGui::PushItemWidth(100);

    ImGui::PushID(index);
    colorize_green_button();

    name = "+##insert" + std::to_string(index);
    if (ImGui::Button(name.c_str()))
    {
        insert_indexes.insert(index);
    }
    ImGui::PopStyleColor(3);
    ImGui::PopID();
    ImGui::PopItemWidth();

    // remove button
    ImGui::SameLine();
    ImGui::PushItemWidth(100);

    ImGui::PushID(index);
    colorize_red_button();

    name = "-##remove" + std::to_string(index);
    if (ImGui::Button(name.c_str()))
    {
        remove_indexes.insert(index);
    }
    ImGui::PopStyleColor(3);
    ImGui::PopID();
    ImGui::PopItemWidth();

    ImGui::NextColumn();

    return remove_indexes;
}

void render(std::vector<local_map::statik::route_creation_input> &inputs,
            local_map::statik::route_creation_input &             route,
            event_route_render_settings const &                   settings)
{

    render(local_map::statik::create_event_route(route), settings);

    ImGui::Text("Create a new route");
    ImGui::SameLine();
    ShowHelpMarker("You create the data that comes from a \"translated route\"\nThen you configure your \"annotation "
                   "strategy\" to get an \"event annotated route\".");

    std::string name;
    static char buf[64];

    ImGui::PushItemWidth(50);
    ImGui::Text("Name: ");
    ImGui::PopItemWidth();

    ImGui::SameLine();
    ImGui::PushItemWidth(150);
    ImGui::InputText("##name", buf, IM_ARRAYSIZE(buf));
    ImGui::PopItemWidth();
    name = std::string(buf);


    ImGui::Text("Lanes: ");

    ImGui::SameLine();
    colorize_green_button();
    if (ImGui::Button("+"))
    {
        local_map::statik::lane_creation_input i;
        route.lane_input_sequence.emplace_back(i);
    }
    ImGui::PopStyleColor(3);

    // clear all the lanes on the individual route
    if (!route.lane_input_sequence.empty())
    {
        ImGui::SameLine();
        colorize_red_button();
        if (ImGui::Button("x"))
        {
            route.lane_input_sequence.clear();
        }
        ImGui::PopStyleColor(3);

        ImGui::Columns(2, NULL, false);
        ImGui::SetColumnWidth(0, 60);
        ImGui::SetColumnWidth(1, 120);


        // ImGui::PushItemWidth(50);
        ImGui::Text("submap");
        // ImGui::PopItemWidth();

        ImGui::NextColumn();

        // ImGui::SameLine();
        // ImGui::PushItemWidth(50);
        ImGui::Text("distance (m)");
        // ImGui::PopItemWidth();

        ImGui::Columns(1);
    }

    // add a new lane to the individual route

    ImGui::Columns(3, NULL, false);
    ImGui::SetColumnWidth(0, 60);
    ImGui::SetColumnWidth(1, 60);
    ImGui::SetColumnWidth(2, 60);
    std::set<size_t> remove_indexes;
    std::set<size_t> insert_indexes;
    for (size_t i = 0; i < route.lane_input_sequence.size(); ++i)
    {
        render(route.lane_input_sequence[i], i, remove_indexes, insert_indexes);
    }
    ImGui::Columns(1);

    // apply inserts and deletes
    for (auto it : remove_indexes)
    {
        route.lane_input_sequence.erase(route.lane_input_sequence.begin() + it);
    }
    for (auto it : insert_indexes)
    {
        local_map::statik::lane_creation_input i = *(route.lane_input_sequence.begin() + it);
        route.lane_input_sequence.insert(route.lane_input_sequence.begin() + it + 1, i);
    }


    // Add the route to the global set of routes
    if (ImGui::Button("Save"))
    {
        inputs.emplace_back(route);
    }


    ImGui::End();
}

void setup_sdl()
{
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) != 0)
    {
        std::cerr << "We weren't able to initialize SDL.\n";
        std::cerr << "Something is incompatible with your display.\n";
        std::cerr << "Here is the SDL error:\n";
        std::cerr << SDL_GetError() << '\n';
        exit(EXIT_FAILURE);
    }
}

std::string decide_sdl_glsl_version()
{
    std::string version;

#if __APPLE__
    // GL 3.2 Core + GLSL 150
    version = "#version 150";
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG); // Always required on Mac
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
#else
    // GL 3.0 + GLSL 130
    version = "#version 130";
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
#endif

    return version;
}

bool user_asked_to_quit(SDL_Window *window, SDL_Event event)
{
    if (event.type == SDL_QUIT)
    {
        return true;
    }
    if (event.type == SDL_WINDOWEVENT && event.window.event == SDL_WINDOWEVENT_CLOSE
        && event.window.windowID == SDL_GetWindowID(window))
    {
        return true;
    }
    return false;
}

SDL_Window *create_main_window()
{
    // Setup window
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);
    SDL_DisplayMode current;
    SDL_GetCurrentDisplayMode(0, &current);
    SDL_Window *window = SDL_CreateWindow("Annotating Routes",
                                          SDL_WINDOWPOS_CENTERED,
                                          SDL_WINDOWPOS_CENTERED,
                                          1280,
                                          720,
                                          SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);
    return window;
}

void clean_up_resources(SDL_GLContext &gl_context, SDL_Window *window)
{
    // Cleanup
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplSDL2_Shutdown();
    ImGui::DestroyContext();

    SDL_GL_DeleteContext(gl_context);
    SDL_DestroyWindow(window);
    SDL_Quit();
}

bool poll_for_events(SDL_Window *window)
{
    // Poll and handle events (inputs, window resize, etc.)
    // You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your
    // inputs.
    // - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application.
    // - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application.
    // Generally you may always pass all inputs to dear imgui, and hide them from your application based on those
    // two flags.
    SDL_Event event;
    bool      done = false;
    while (SDL_PollEvent(&event))
    {
        ImGui_ImplSDL2_ProcessEvent(&event);
        done = user_asked_to_quit(window, event);
    }
    return done;
}

void create_route_window(settings &                                            s,
                         std::vector<local_map::statik::route_creation_input> &inputs,
                         local_map::statik::route_creation_input &             route_input)
{

    // get input routes
    create_window(s.create_route_window);
    render(inputs, route_input, s.event_route);
}

void render_frame(SDL_Window *window, SDL_GLContext &gl_context, ImGuiIO &io, ImVec4 &clear_color)
{
    // Rendering
    ImGui::Render();
    SDL_GL_MakeCurrent(window, gl_context);
    glViewport(0, 0, (int) io.DisplaySize.x, (int) io.DisplaySize.y);
    glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w);
    glClear(GL_COLOR_BUFFER_BIT);
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
    SDL_GL_SwapWindow(window);
}

void handle_menu_item(window_properties &window)
{
    if (ImGui::MenuItem(window.menu.title.c_str(), window.menu.shortcut.c_str()))
    {
        window.is_open = true;
    }
}

void create_main_menu(settings &s)
{
    if (ImGui::BeginMainMenuBar())
    {
        handle_menu_item(s.create_route_window);
        handle_menu_item(s.annotated_route_window);
        ImGui::EndMainMenuBar();
    }
}

int main()
{

    // settings for the translation route tool
    settings s;
    s.create_route_window.title              = "Create a translated route";
    s.create_route_window.menu.title         = "Create Routes";
    s.create_route_window.menu.shortcut      = "CTRL+N";
    s.create_route_window.position.x         = 20;
    s.create_route_window.position.y         = 38;
    s.create_route_window.position.condition = ImGuiCond_Once;
    s.create_route_window.size.width         = 800;
    s.create_route_window.size.height        = 410;
    s.create_route_window.size.condition     = ImGuiCond_Once;
    s.create_route_window.titlebar           = true;
    s.create_route_window.scrollbar          = true;
    s.create_route_window.has_menu           = false;
    s.create_route_window.move               = true;
    s.create_route_window.resize             = true;
    s.create_route_window.collapse           = true;
    s.create_route_window.nav                = false;
    s.create_route_window.close              = true;
    s.create_route_window.is_open            = false;
    s.create_route_window.focus              = false;
    s.create_route_window.bg_alpha           = 1;

    // settings for the event annotation simulation tool
    s.annotated_route_window.title              = "Event Annotated Routes";
    s.annotated_route_window.menu.title         = "Simulate Events";
    s.annotated_route_window.menu.shortcut      = "CTRL+S";
    s.annotated_route_window.position.x         = 830;
    s.annotated_route_window.position.y         = 20;
    s.annotated_route_window.position.condition = ImGuiCond_Once;
    s.annotated_route_window.size.width         = 400;
    s.annotated_route_window.size.height        = 600;
    s.annotated_route_window.size.condition     = ImGuiCond_Once;
    s.annotated_route_window.titlebar           = true;
    s.annotated_route_window.scrollbar          = true;
    s.annotated_route_window.has_menu           = false;
    s.annotated_route_window.move               = true;
    s.annotated_route_window.resize             = true;
    s.annotated_route_window.collapse           = true;
    s.annotated_route_window.nav                = true;
    s.annotated_route_window.close              = true;
    s.annotated_route_window.is_open            = false;
    s.annotated_route_window.focus              = false;
    s.annotated_route_window.bg_alpha           = 1;

    // settings for rendering annotated routes
    s.event_route.draw_lanes            = true;
    s.event_route.draw_submaps          = true;
    s.event_route.draw_evaluation_range = true;
    s.event_route.distinct_colors       = distinct_colors();

    s.event_route.lane_annotated.width              = 30;
    s.event_route.lane_annotated.height             = 30;
    s.event_route.lane_annotated.thickness          = 1;
    s.event_route.lane_annotated.color_border.r     = 0;
    s.event_route.lane_annotated.color_border.g     = 0;
    s.event_route.lane_annotated.color_border.b     = 0;
    s.event_route.lane_annotated.color_border.alpha = 255;
    s.event_route.lane_annotated.color_fill.r       = 116;
    s.event_route.lane_annotated.color_fill.g       = 183;
    s.event_route.lane_annotated.color_fill.b       = 224;
    s.event_route.lane_annotated.color_fill.alpha   = 255;

    s.event_route.lane_unannotated.width              = 30;
    s.event_route.lane_unannotated.height             = 30;
    s.event_route.lane_unannotated.thickness          = 1;
    s.event_route.lane_unannotated.color_border.r     = 0;
    s.event_route.lane_unannotated.color_border.g     = 0;
    s.event_route.lane_unannotated.color_border.b     = 0;
    s.event_route.lane_unannotated.color_border.alpha = 255;
    s.event_route.lane_unannotated.color_fill.r       = 116;
    s.event_route.lane_unannotated.color_fill.g       = 183;
    s.event_route.lane_unannotated.color_fill.b       = 224;
    s.event_route.lane_unannotated.color_fill.alpha   = 255;

    s.event_route.submap.width              = 30;
    s.event_route.submap.height             = 60;
    s.event_route.submap.thickness          = 0;
    s.event_route.submap.color_border.r     = 0;
    s.event_route.submap.color_border.g     = 0;
    s.event_route.submap.color_border.b     = 0;
    s.event_route.submap.color_border.alpha = 255;
    s.event_route.submap.color_fill.r       = 116;
    s.event_route.submap.color_fill.g       = 183;
    s.event_route.submap.color_fill.b       = 224;
    s.event_route.submap.color_fill.alpha   = 255;


    setup_sdl();
    auto glsl_version = decide_sdl_glsl_version();
    auto window       = create_main_window();

    SDL_GLContext gl_context = SDL_GL_CreateContext(window);
    SDL_GL_SetSwapInterval(1); // Enable vsync
    gl3wInit();

    // Setup Dear ImGui binding
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO &io = ImGui::GetIO();
    (void) io;
    // io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls

    ImGui_ImplSDL2_InitForOpenGL(window, gl_context);
    ImGui_ImplOpenGL3_Init(glsl_version.c_str());

    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);

    // customize overall look
    ImGui::StyleColorsLight();
    ImGuiStyle &style      = ImGui::GetStyle();
    style.FrameBorderSize  = 1;
    style.PopupBorderSize  = 1;
    style.WindowBorderSize = 1;


    // input
    std::vector<local_map::statik::route_creation_input> inputs;

    // start the route input with a single lane
    local_map::statik::route_creation_input route_input;

    bool done = false;
    while (!done)
    {
        done = poll_for_events(window);

        // Start the Dear ImGui frame
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplSDL2_NewFrame(window);
        ImGui::NewFrame();

        create_main_menu(s);


        // for testing
        bool show_demo_window = true;
        ImGui::ShowDemoWindow(&show_demo_window);

        if (s.create_route_window.is_open)
        {
            create_route_window(s, inputs, route_input);
        }

        // turn inputs into event routes
        std::vector<local_map::statik::event_annotated_route> event_routes;
        for (auto const &it : inputs)
        {
            event_routes.emplace_back(local_map::statik::create_event_route(it));
        }


        if (s.annotated_route_window.is_open)
        {
            create_window(s.annotated_route_window);
            render(event_routes, s.event_route);
        }


        render_frame(window, gl_context, io, clear_color);
    }

    clean_up_resources(gl_context, window);
    return EXIT_SUCCESS;
}
