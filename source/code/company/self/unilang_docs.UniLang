things to maybe mention somewhere:
"A language is a dialect with an army and navy"
https://en.wikipedia.org/wiki/Rule_of_least_power


􏱭0􏱮􏱕􏱖􏱫A universal programming language􏱬
􏱥.readme/unilang-trimmed.png􏱦􏱣Unilang􏱤􏱡Unilang􏱢􏱓395􏱔􏱑112􏱒

􏱭0􏱮􏱕􏱖􏱫Introduction􏱬

􏱭1􏱮􏱕􏱖􏱫Overview􏱬
􏱏a universal programming language􏱐
􏱏the requirements for universality􏱐
􏱏encoded information and software-related artifacts􏱐
􏱏comparison to other programming languages􏱐
􏱩welcome to Unilang; the self proclaimed **universal programming language**􏱪􏱟􏱠􏱧􏱨
􏱩Unilang takes a novel approach to a language's role in facilitating software􏱪􏱟􏱠􏱧facilitate?􏱨
􏱩the design and implementation of Unilang is built with particular language philosophies in mind􏱪􏱟􏱠􏱧􏱨
􏱩this overview will discuss some of these ideas first in order to build the foundation for the rest of Unilang􏱪􏱟􏱠􏱧􏱨
􏱩Unilang will then be described in the context of software engineering􏱪􏱟􏱠􏱧􏱨

􏱭2􏱮􏱕􏱖􏱫􏱬
􏱩a primary focus when first introducing Unilang is a discussion around **encoded information** and **software-related artifacts**􏱪􏱟􏱠􏱧􏱨
􏱩what do we encode for software and what is the resulting software artifacts?􏱪􏱟􏱠􏱧􏱨
􏱩we discuss what engineers need to encode while working in a problem domain, and what products should come from such an encoding􏱪􏱟􏱠􏱧􏱨
􏱩a conclusion is made that engineers are not encoding everything necessary due to the limitations, scope, and enforced structure of individual tools􏱪􏱟􏱠􏱧􏱨
􏱩the effect of not having a universal encoding results in multiple encodings across different languages which makes maintenance less feasible over time􏱪􏱟􏱠􏱧􏱨
􏱩an argument is made that more concepts related to software must be semantically encoded at the language level􏱪􏱟􏱠􏱧􏱨
􏱩the technical aspects of this are discussed later􏱪􏱟􏱠􏱧􏱨
􏱩we will compare it to other programming languages to show the similarities and key differences between them􏱪􏱟􏱠􏱧􏱨
􏱩the take-away from this comparison is that Unilang is not competing with other programming languages􏱪􏱟􏱠􏱧􏱨
􏱩it embraces all of them in its own implementation􏱪􏱟􏱠􏱧􏱨

preface junk:
a conceptual model is used to raise the design and implementation abstraction above other high level languages
you can use Unilang to transcompile down to other languages and data formats
Unilang has an abundance of interesting code transformations and static analysis techniques
it was built to improve the efficiency of the modern software engineer
the language empowers a level of engineering discipline that users would not be able to sustain in other languages

Unilang is the unification of programming concepts without syntax.
It is a reconstructed approach on how language should be used to facilitate the creation of software.
A conceptual model is used to raise the design and implementation abstraction above other high level languages.

􏱭2􏱮􏱕􏱖􏱫􏱬
􏱩let's start by getting you acquainted with the big picture􏱪􏱟􏱠􏱧􏱨
􏱩Unilang is a tool for writing software􏱪􏱟􏱠􏱧􏱨
􏱩and like all tools in software, it takes an input and produces an output􏱪􏱟􏱠􏱧􏱨
􏱩the scope of Unilang's throughput however is ambitious􏱪􏱟􏱠􏱧􏱨
􏱩everything a software engineer can express around a problem domain must be encoded in the same ontology􏱪􏱟􏱠􏱧􏱨
􏱩we find this necessary in maximizing our current understanding of the problem domain, and adapting to its change over time􏱪􏱟􏱠􏱧mention maintenance?􏱨
􏱩the output of this ontology is every chosen artifact that facilitates desired tasks in that domain􏱪􏱟􏱠􏱧􏱨
􏱩From a programming perspective, we unify all formal and informal languages involved around software􏱪􏱟􏱠􏱧􏱨
􏱩this information is then encoded as a single abstract data model which is used to create various artifacts􏱪􏱟􏱠􏱧􏱨
􏱥.readme/unilang_overview.png􏱦􏱣very high level overview of Unilang􏱤
􏱩the diagram above is intentionally vague􏱪􏱟􏱠􏱧􏱨
􏱩however, we can use it to compare the transformation process of source code in other programing languages􏱪􏱟􏱠􏱧􏱨
􏱩the scope of these other languages do not entail all of the work that needs to be done in a real-world software engineering context􏱪􏱟􏱠􏱧􏱨
􏱥.readme/typical_gpl_overview.png􏱦􏱣high level overview of a GPL􏱤

􏱩the goals of general purpose programming languages (GPLs) shown above, are also realized within Unilang􏱪􏱟􏱠􏱧􏱨
􏱩Unilang can be used to generate programs for any domain􏱪􏱟􏱠􏱧􏱨
􏱩A key feature of Unilang is that it can even target the source code of all other GPLs􏱪􏱟􏱠􏱧􏱨
􏱩this means that Unilang can be easily adopted in current systems as a transcompiler to other programming languages􏱪􏱟􏱠􏱧􏱨
􏱥.readme/unilang_as_a_transcompiler.png􏱦􏱣Unilang as a transcompiler􏱤
􏱩There are many other types of artifacts that should be created alongside software􏱪􏱟􏱠􏱧􏱨
􏱩Unilang facilitates the creation of these artifacts as well􏱪􏱟􏱠􏱧􏱨
􏱥.readme/unilang_to_many_artifacts.png􏱦􏱣Unilang to many artifacts􏱤
􏱩in fact, what you are reading now was generated from Unilang􏱪􏱟􏱠􏱧􏱨

Initial critique:  sounds like a cluster fuck.
talk about 1 giant ontology that creates other onotologies.  
vs manually maintaining a set of ontologies that all share some partial information with each other.
diagram of one big graph, deriving all the other graphs.  vs a set of graphs with dotted lines between things that must be manually maintained
close with an argument that, the would is complex and problems are complex and systems grow to huge complexity.  
and all of this encoded information is necessary anyway, and its really a matter of "how do you want to manage this complexity?"  
and which system is better for managing the growth and changes of complexity in a fluid undefined problem domain.

􏱭1􏱮􏱕􏱖􏱫Motivation􏱬
􏱏fdg1111dfgdfg􏱐
􏱏fdg1222111dfgdfg􏱐
􏱩the motivation behind Unilang has grown organically while working as a software engineer􏱪􏱟􏱠􏱧􏱨
􏱩it serves a purpose both practical and personal from working in the industry􏱪􏱟􏱠􏱧􏱨
􏱩some of it has been designed to help within a professional context􏱪􏱟􏱠􏱧􏱨
􏱩other parts have been designed around the personal/hobby context􏱪􏱟􏱠􏱧􏱨
􏱩in this section we will cover the specific motivations around Unilang􏱪􏱟􏱠􏱧􏱨

􏱭2􏱮􏱕􏱖􏱫Practical􏱬
􏱩TODO􏱪􏱟􏱠􏱧􏱨

you need one including.  you can't have multiple
look at html/css/javascript all coming together

􏱭2􏱮􏱕􏱖􏱫Personal􏱬
􏱩i often find myself frustrated when working with other people􏱪􏱟􏱠􏱧􏱨
􏱩quite often others will advocate misguided opinions that slow me down and lead to worse software􏱪􏱟􏱠􏱧􏱨
􏱩compromising with and teaching others is a social undertaking that wastes a lot of my time and ultimately stresses me out􏱪􏱟􏱠􏱧􏱨
􏱩i have found it better to write software correctly without compromise, and then transform it into a shared development space􏱪􏱟􏱠􏱧􏱨
􏱩this lets me keep my integrity as an engineer and not break any of my engineering values while working with others􏱪􏱟􏱠􏱧􏱨
􏱩this process also helps me get along with other people because they think they are helping, even though my true interests are not in anything they contribute to􏱪􏱟􏱠􏱧􏱨
􏱥.readme/unilang-personal-overview.png􏱦􏱣an overview of how unilang is used for personal reasons􏱤
􏱩we attribute labels on which parts of the development cycle we care about􏱪􏱟􏱠􏱧􏱨
􏱩this reveals a "don't care" cycle which we use unilang to optimize the iteration of as fast as possible􏱪􏱟􏱠􏱧􏱨
􏱩what we do care about remains streamlined and isolated from other people􏱪􏱟􏱠􏱧􏱨
􏱥.readme/unilang-personal-annotated.png􏱦􏱣an overview of how unilang is used for personal reasons􏱤
􏱩this shows that even if the project being worked on is meaningless, we measure our success from a personal space outside􏱪􏱟􏱠􏱧􏱨

􏱭0􏱮􏱕􏱖􏱫Features􏱬
􏱩TODO. also consider a language matrix of tests/features that we have working across languages.􏱪􏱟􏱠􏱧􏱨

􏱭1􏱮􏱕􏱖􏱫IDL support􏱬
􏱩TODO􏱪􏱟􏱠􏱧􏱨

􏱭1􏱮􏱕􏱖􏱫GPL support􏱬
􏱩TODO􏱪􏱟􏱠􏱧􏱨

􏱭1􏱮􏱕􏱖􏱫DSL support􏱬
􏱩TODO􏱪􏱟􏱠􏱧􏱨

􏱭0􏱮􏱕􏱖􏱫Language Design􏱬
􏱩in this section, we will discuss the theory of what a programming language should be􏱪􏱟􏱠􏱧􏱨
􏱩we show how these ideas are applied in shaping the design of Unilang􏱪

􏱭1􏱮􏱕􏱖􏱫Hierarchy􏱬
􏱩in this section we discuss the hierarchy of language􏱪
􏱩consider the current language abstractions within the software engineering domain􏱪
􏱩Unilang and its conceptual model are placed above these high level languages􏱪
􏱥.readme/language-abstraction.png􏱦􏱣software engineering language abstraction with Unilang placed at the top􏱤
􏱩Unilang can transcompile down to other languages􏱪

􏱭1􏱮􏱕􏱖􏱫Structure􏱬
􏱩in this section we discuss the structure of language􏱪
􏱩many programming languages represent their syntactic structure as an abstract syntax tree􏱪
􏱩other languages like Lisp and its derivations choose nested lists􏱪
􏱩the structure of Unilang is a composed set of algebraic data types􏱪
􏱥.readme/choosing-structure.png􏱦􏱣choosing the Unilang structure􏱤
􏱩this is a subtle but important distinction􏱪
􏱩an ADT models the concise structure and shape of programming concepts􏱪
􏱩this allows us to work backwards and enable programmers to efficiently populate this structure􏱪
􏱩trying to contort a variety of programming concepts syntactically, and then extracting them out with regular expressions and grammars into generic data structures such as trees and lists has proven insufficient for semantic analysis􏱪
􏱩its the reason that parsing errors are often confusing and unhelpful􏱪
􏱩its the reason that community tooling on code transformation is often limited􏱪
􏱩most importantly, its the reason a language's evolution tends to stagnate as more abstract concepts are squeezed into an existing syntax and grammar􏱪

## Direct semantic encoding (syntax considered harmful)
TODO.  
essentially end at a markup language.  
markup language is great from the compilers perspective,
but terrible from the programmers perspective.  
Explain how we fix this.  
uh, we'll probably need a deeper section about natural language vs programming language.  
what is relevant, what is not. how properties of natural language has incorrectly been applied in programming
talk about how semantics is what matters most in programming

here is a good example that sumarizes why the whole syntatical approach is incorrect.  
Where they focus on keyword, we have Unilang language tokens
http://mail.openjdk.java.net/pipermail/amber-spec-experts/2019-January/000945.html

􏱭1􏱮􏱕􏱖􏱫Ergonomics􏱬
􏱩in this section we discuss the ergonomics of the language in terms of reading and writing􏱪
􏱩TODO. this is where we talk about discrete infinity􏱪
􏱩TODO. this is where we talk about projectional editors􏱪

􏱭1􏱮􏱕􏱖􏱫Guiding Principles􏱬

􏱭2􏱮􏱕􏱖􏱫Syntax􏱬
􏱩syntax doesn't matter.  It never has, and it never will􏱪􏱟􏱠􏱧􏱨
􏱩we eliminate syntax complexity through unique symbolic tokens􏱪􏱟􏱠􏱧􏱨
􏱩Unilang pulls from Unicode's Private Use Area (PUA)􏱪􏱟􏱠􏱧􏱨
􏱩As a result, no matter how many tokens get added the the language, the lexical and syntactical analysis remains trivial􏱪􏱟􏱠􏱧􏱨
􏱩Unilang comes with its own font, but users can choose their own glyphs to represent individual code points􏱪􏱟􏱠􏱧􏱨
􏱩Although Unilang could equally be represented in a markup format such as json or yaml, we provide the unicode textual frontend as it tends to look simpler, allow for custom glyphs, and is easy to colorize in editors􏱪􏱟􏱠􏱧􏱨
􏱩User's can choose to write directly in this unicode format, or use the graphical system built on top of it􏱪􏱟􏱠􏱧􏱨
􏱥.readme/unilang-look.png􏱦􏱣Unilang's frontend perspectives vs developer experience􏱤

The first point of contention people have with the language,  
is that they cannot fire of vim and start writing in it.  
In its ascii markup format, Unilang is too dense.  
It's dense, because we don't play any games with syntax or grammar in an attempt to make it more palatable.  
We want the user to be encoding concepts as close to the Unilang conceptual ADT as possible.  
Programming in unicode has proven to be a good trade-off between readability and writeability.  
I urge you to remember, that software engineering requires a lot more reading than it does writing.  

**Design choice:**  
Code is data.  We intend to make the language as close to a data structure as possible.  
Without making yet another lisp-like language, and have you drowning in parenthesis, we  
chose to target a conceptual ADT utilizing nested variants.  It's richer than an AST, or having everything as a list.

􏱭2􏱮􏱕􏱖􏱫Grammar􏱬
􏱩You can express anything in any order assuming that it makes sense conceptually􏱪􏱟􏱠􏱧􏱨
􏱩Semantic analysis builds an ADT nearly identical to the tokens you write􏱪􏱟􏱠􏱧􏱨
􏱩You can leave many token out, and based on various configurations, you will get default values, automated enrichments, or descriptive errors􏱪􏱟􏱠􏱧􏱨
􏱩So many languages have bad compiler errors􏱪􏱟􏱠􏱧􏱨
􏱩You will not find this in Unilang due to the rich token set and easy to understand grammar􏱪􏱟􏱠􏱧􏱨

**Design choice:**  
We are already set on using unique tokens for 1-1 mappings on the conceptual ADT.  
It is trivial to parse these independent tokens in any order so why enforce it.  
If user's want consistency, Unilang can simply tidy itself to a particular user chosen order.  

􏱭2􏱮􏱕􏱖􏱫Code Generation􏱬
􏱩Unilang could target LLVM, output byte code for the JVM, or operate under its own interpreter􏱪􏱟􏱠􏱧􏱨
􏱩However, there is little reason to invest in these efforts at this time􏱪􏱟􏱠􏱧􏱨
􏱩We stand on the shoulder's of giants and transcompile to other languages􏱪􏱟􏱠􏱧􏱨
􏱩This is a strategic decision because it helps Unilang grow in 2 ways􏱪􏱟􏱠􏱧􏱨
􏱩The more languages Unilang can transcompile to other languages, the more we can generalize programming concepts across the ecosystem􏱪􏱟􏱠􏱧􏱨
􏱩It also helps us show that two seemingly apposing language design decisions  can be incorporated into the same language and chosen programatically at build time􏱪􏱟􏱠􏱧􏱨

**Design choice:**  
This was an easy decision.  For Unilang to grow in a conceptually pure way,  
we measure our success by our ability to transcompile to other languages.  
It's also less work for the backend, and it lets us secretly and immediately use Unilang in industrial cirumstances.  
We get real situations where Unilang is being used, and user's are unaware that they  
are contributing to its success by commenting on the transcompiled format.  
We can usually meet the needs of other programmers reading the transcompiled version  
of Unilang by putting their opinions into the configuration of the backend transcompiler.  

􏱭2􏱮􏱕􏱖􏱫Supersets􏱬
􏱩many people believe a language should have a strong and simple core􏱪􏱟􏱠􏱧􏱨
􏱩this is followed by the advice of having libraries do the rest of the heavy lifting􏱪􏱟􏱠􏱧􏱨
􏱩this stems from the experience of how difficult it becomes to change a language once so much code is written in it􏱪􏱟􏱠􏱧􏱨
􏱩unilang puts as much in the language as possible, because anything that is added must be a concept that stands independent of the code that is generated􏱪􏱟􏱠􏱧􏱨
􏱩extending Unilang with new tokens is backwards-compatible, and doesn't affect the existing grammar􏱪􏱟􏱠􏱧􏱨
􏱩although Unilang may have a large number of language tokens to account for all these concepts, it is not very overwhelming because the majority of them are not required􏱪􏱟􏱠􏱧􏱨

**Design choice:**  
The more context a compiler has, the more it can do.  
It can generate better code, give better error messages,  
and improve static analysis.

􏱭2􏱮􏱕􏱖􏱫Steal􏱬
􏱩Unilang is not afraid to steal all the good ideas from other languages􏱪􏱟􏱠􏱧􏱨
􏱩Through its design, it avoids all of the pitfalls that current languages accrue when adding too many features􏱪􏱟􏱠􏱧􏱨

􏱭2􏱮􏱕􏱖􏱫No trade-offs􏱬
􏱩Typical programming languages are designed around trade-offs􏱪􏱟􏱠􏱧􏱨
􏱩Unilang refuses to make trade-offs􏱪􏱟􏱠􏱧􏱨
􏱩Most opinions can be dual supported at the language level, and chosen during code generation􏱪􏱟􏱠􏱧􏱨


􏱭0􏱮􏱕􏱖􏱫User Guide􏱬
􏱩TODO. talk about how to use unilang􏱪

􏱭1􏱮􏱕􏱖􏱫Installation􏱬
􏱩Ready to get started?􏱪
􏱩Unilang can be built from source in the following way􏱪
􏱍git clone git@github.com:Unilang/unilang.git unilang􏱎
􏱍cd unilang􏱎
􏱍./build_everything􏱎

􏱩various CIs are also building from source and can be used as reference􏱪
􏱛Builds from online CIs􏱜
􏱙Continuous Integration􏱚􏱙Status􏱚􏱙Notes􏱚
􏱗App Veyor􏱘􏱗[![Build status](https://ci.appveyor.com/api/projects/status/mubmrg7wis4vubar/branch/master?svg=true)](https://ci.appveyor.com/project/luxe/everything/branch/master)􏱘􏱗Full Build􏱘
􏱗Circle􏱘􏱗[![CircleCI](https://circleci.com/gh/Unilang/unilang.svg?style=svg)](https://circleci.com/gh/Unilang/unilang)􏱘􏱗Bootstraps Build􏱘
􏱗Cirrus􏱘􏱗[![Build Status](https://api.cirrus-ci.com/github/Unilang/unilang.svg)](https://cirrus-ci.com/github/Unilang/unilang)􏱘􏱗Bootstraps Build􏱘
􏱗Codeship􏱘􏱗[![Codeship Status for Unilang/unilang](https://app.codeship.com/projects/9bd37ae0-f384-0136-68bc-72341457e248/status?branch=master)](https://app.codeship.com/projects/9bd37ae0-f384-0136-68bc-72341457e248/)􏱘􏱗Full Build􏱘
􏱗Scrutinizer􏱘􏱗[![Build Status](https://scrutinizer-ci.com/g/unilang/unilang/badges/build.png?b=master)](https://scrutinizer-ci.com/g/unilang/unilang/build-status/master)􏱘􏱗Full Build􏱘
􏱗Semaphore􏱘􏱗[![Build Status](https://semaphoreci.com/api/v1/luxe/everything/branches/master/shields_badge.svg)](https://semaphoreci.com/luxe/unilang)􏱘􏱗Full Build􏱘
􏱗Shippable􏱘􏱗[![Run Status](https://api.shippable.com/projects/5c3163fd4e246e0700cea316/badge?branch=master)](https://app.shippable.com/accounts/5c3163cad1578b0700302159/dashboard)􏱘􏱗Full Build􏱘
􏱗Travis􏱘􏱗[![Build Status](https://travis-ci.com/Unilang/unilang.svg?branch=master)](https://travis-ci.com/Unilang/unilang)􏱘􏱗Full Build􏱘


􏱭0􏱮􏱕􏱖􏱫Developer Guide􏱬
􏱩TODO. here we talk about information for anyone who wants to contribute to the Unilang project􏱪

􏱭1􏱮􏱕􏱖􏱫Build System􏱬
􏱩TODO􏱪

􏱭2􏱮􏱕􏱖􏱫Hermetics􏱬
􏱩the project is designed to be hermetic􏱪􏱟􏱠􏱧􏱨
􏱩this means that all external dependencies should be bootstrapped by the build system and self-contained within the repository􏱪􏱟􏱠􏱧􏱨
􏱩if anything in the build relies on an external dependency (not available or tracked by the repository) this can break user's builds, and it is a bug􏱪􏱟􏱠􏱧􏱨
􏱩here is an overview on what the build system looks like􏱪􏱟􏱠􏱧􏱨
􏱥.readme/build-system.png􏱦􏱣diagram of the build system􏱤

If you experience a build issue, make a ticket.  
Also take a look at the CIs that are passing, and see if they  
do anything extra to get a successful build.  

Things to improve:  
 - bundle sysroot
 - disable all external linking / include file paths (same as sysroot?)
 - test in different docker containers (kind of have this with existing CIs)
 - move more system dependencies (see CI config files) into bazel deps (GMP specifically)
 - set a default compiler toolchain automatically? (instead of specifying directly on cli)

􏱭1􏱮􏱕􏱖􏱫Contribute􏱬
􏱩there are no rules􏱪
􏱩make a ticket about anything􏱪
􏱩we'll figure it out together􏱪




#### Stand-alone binaries
TODO.  
what do we want here?  
deb packages? rpm?  other distribution methods?
I want a quick and easy installer for people.

#### Is it building in the cloud?  
We strive to get all of these to pass.  
Due to the different limitations of these free services, that might not always be possible.  
At the very least, it gives us some good visibility into different issues.  
If the majority of these are passing, you have a good chance of succeeding in a local build.  
If they are failing,  I recomend you look back to a commit where they passed and clone from there.  


[1]: https://en.wikipedia.org/wiki/Private_Use_Areas
[2]: https://en.wikipedia.org/wiki/Code_point