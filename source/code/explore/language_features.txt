Various language features and code generation ideas to support:

- Option to make function result cached
this could turn a regular function into a function that holds the result as a static.
It may also create an additional function so that there is a cached / noncached version.

- Tag portions of unilang structure as "generated" or "not generated".
Based on options an code generation, we are going to be changing the actual unilang structure pragmatically.
adding methods to the methods section. Adding data members to objects. All kinds of things.
All of this data needs an enum for SPECIFIED/GENERATED. in accordance to what is contained in the actual .UniLang file.
We may also accomplish this at the graphical level with an additional label face that holds this property.

- Side Effects
The language may be purely functional, it may not be.
If side effects are a possibility we should consider having a token that says what the side effects are?
At least an English comment about the side effect.
And as far as I understand contract programming, side effects are not post conditions.
If the function does not complete successfully, the post conditions are irrelevant.
Side effects aren't necessarily exceptions either. That's why I think a separate language tokens may be needed.
Hopefully this something we can detect and generate automatically. Might need a token for this, but I'm hoping that we don't.
// side effects:
// - uses IO
// - changes global var: foo

- Higher Order Detector
We need a function that takes a look at all the arguments and return values,
and decides whether it is a higher order function. Not too hard.
We need to backtrack and find function pointers. Looks at std::function.
I guess some classes could have () overloaded..
does that mean the function is actually higher order. More to consider here.

- Idempotence Detector
A function is idempotent if reapplying it to its result does not produce a different result.
Not sure how difficult this come to be.
Might have to implement other features first-- like detecting side effects, etc.
Although having side effects doesn't mean the function isn't still idempotent.
So than there is a whole flow analysis involved. Tricky.

- [why change value] token for data members
Often times a chunk of data is sent into some business logic.
The data has a brief/detailed description,
but sometimes it is useful to describe WHY a user may want to change the data.
The can also serve as additional GUI text in say a settings panel.

- [questionable] token to code elements
sometimes you have to make a change to some code.
Those changes may be hackish, and somewhat questionable.
Other times, you are implementing something off of a requirement specification, and you don't agree with the requirement specification.
Maybe the requirement specification is wrong, but you don't have time to hold off on implementation until you know.
I think the best thing to so in these situations, is tag a particular code element as "questionable".
That way it is self documenting (better than just a regular comment).
The "questionable" will just be a string explaining why you find the code element questionable.
If it doesn't exist, then the code is not questionable. Easy to implement, lots of tokens though for every code element.
I assume this is going to be similar to the "deprecation" or "warning" or "note" attributes.

- [optional why] token
we'll be able to tag arguments, return values, identifiers as "optional".
We will also be able to supply a list of reasons as to why the variable may be optional.

- Mustache settings for different parts of the unilang structure
we'll have to think about how wildly this can be used, and if it should be ignored by just using language features instead

- time tracking, and file navigation recording
this stupid but it would be cool if we recorded (somehow), how long a programmer has been looking at file.
If they aren't scrolling or moving their mouse or something, we'll have some kind of timeout.
The idea is, that we will be able to show hot spots where people spend their time looking a lot.
And see cold spots where people pretty much trust, or have no need to look at certain code.
It would also be cool to record the file tracing that occurs for programmers.
For example, they might look at a child class, and then most would look at some parent class,
and then maybe they would go to class thats composed inside the parent.
We can trace these file jumps to determine if users are jumping to disconnected files for particular reasons.
This can help determine cohesion and such.
Also, allow microphone listening, to learn about a particular file.
based on people cursing, and cursing other people's names etc.
AI can learn about a programmer's feelings toward a particular file.

- generate or not generate auto based on specified conditions
converting between using auto and not using auto should be an algorithmic conversion.
this is mostly a c++ concern both other languages that have similar auto concept as well.
even java with choosing Object even thought this is different than type deduction

- provide a way to duplicate const on methods
example for c++:
class some_class{
    ...
    const std::map<std::string, std::string> &get_value_items() const;
    std::map<std::string, std::string> &      get_value_items();
   ...
 };
 
 - static analysis refactor suggestions
o detecting patterns and recommending templates
o detecting patterns and recommending higher order functions
o o help data bubble to the top
find duplicate code and suggest function interface
I think there is a lot of re-factoring opportunities that lead you down different roads when re-factoring.
Sometimes it pays off, sometimes it does not. We need to do some research on what re-factoring techniques work, and which do not.
I'd like to set up an experiment with made up types, and made up functionalists, and try different scenarios and use-cases to see how decisions pan out.
Maybe there is some research papers on the matter that we can tap into

- generate "to_tuple" free function / member function
all types should be able to generate to tuples.
Keep in mind, that we might want the order of the tuple arguments based on size to create the best alignment.
We may also want them in the order that they were originally in the class.

- all functions should be tagged with their "category of transform"
every function is some kind of transform.
We should be able to categorize these transforms.
A function can belong to more than one group.
Examples:
 converters
 accumulators
 transformers
 sorters
 printers (return nothing. has side effects)
 -validators (return bool)
 describers (takes a structure and describes it with another type. I dunno. something like that)
 builders
-generators
We'll want to come up with clear definitions for all of these.
Hopefully we can add enough semantics to detect a function's "category of transformation"
automatically. Also, some "transform" categories inherit. For example,
if you call a printer internally, you are also a printer. Not so much if you call coverters/transformers etc.
You would be a printer even if the function doesn't actually print if its blocked by a conditional or something which we wouldn't be able to figure out.


- error message token values
[what happened]
[why]
[suggest next step]
[rate the seriousness of the issue]
^ this can guide static analysis in deciding whether the error message has the right tone.

- homoglyph substitution and zero-width fingerprinting
It would be super sneaky and super sly to watermark generated code with unilang zero-width fingerprinting.
This way we'll now if someone has copied code, etc.

- allow inserting zero width character messages
similar to:
https://umpox.github.io/zero-width-detection/
https://medium.com/@umpox/be-careful-what-you-copy-invisibly-inserting-usernames-into-text-with-zero-width-characters-18b4e6f17b66
(for secret watermarks)

- measuring technical debt
this is stupid but lets say technical debt exists from an "interest rate"
and "interest rate" is a function of time. Let's see if we can get a rough algorithm to compute and keep track of this on functions/classes/modules

- demonstrative detector
"Instead of using demonstratives “this” and “that” or pronouns like “it” or “they“, use the specific names of the things, even if it seems slightly redundant.
It’s especially good for the case when you are focused on technical writing which often requires referring to many different things at once, which may confuse the reader."

- comments that use terms must link to definition
static analysis of comment. We find acronyms, concepts, and terms. These must be linked to the name that has all of the necessary contextual information.

- code should have music associated with it
music can also inspire feelings about a particular piece of code, and can help someone gain familiarity



