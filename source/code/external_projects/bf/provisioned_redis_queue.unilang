􏶞o􏶟
􏷲a queue that is designed to hold particularly provisioned elements􏷱
􏷰a provisioned redis queue is an implementation of a queue data structure which internally uses a redis cluster to distribute the data across shards.
Its important to know that the lifetime of the queue persists before and after the queue data structure is created (since it exists in redis)
Therefore, two redis queues with the same name, would in fact be the same underlying redis queue

This redis queue comes with a list of required provisions
if the queue element does not meet the required provisions, it should not be stored in the queue

Provision queues are intended to represent particular operations that should only be processed by particular workers.
An example use case for this would be to have two dedicated provision queues for CPU and GPU operations.
CPU/GPU requirements would be determined through the remote api's command platform properties.
We designate provision queues to have a set of "required provisions" (which match the platform properties).
This allows the scheduler to distribute operations by their properties and allows workers to dequeue from particular queues􏷯
􏷞build􏷝􏷞buildfarm􏷝􏷞common􏷝􏷞redis􏷝

􏷤􏷣􏷦com.google.common.collect.LinkedHashMultimap􏷥
􏷤􏷣􏷦com.google.common.collect.Lists􏷥
􏷤􏷣􏷦com.google.common.collect.SetMultimap􏷥
􏷤􏷣􏷦java.util.List􏷥
􏷤􏷣􏷦build.buildfarm.common.redis.BalancedRedisQueue􏷥
􏷤􏷣􏷦redis.clients.jedis.JedisCluster􏷥

􏲏􏲐􏲍build.buildfarm.instance.shard.JedisClusterFactory􏲎
􏲏􏲐􏲍build.buildfarm.common.redis.BalancedRedisQueue􏲎
􏲏􏲐􏲍build.buildfarm.common.StringVisitor􏲎
􏲏􏲐􏲍redis.clients.jedis.JedisCluster􏲎
􏲏􏲐􏲍org.junit.Test􏲎
􏲏􏲐􏲍java.util.List􏲎
􏲏􏲐􏲍java.util.ArrayList􏲎
􏲏􏲐􏲍org.junit.runner.RunWith􏲎
􏲏􏲐􏲍org.junit.runners.JUnit4􏲎
􏲏􏲐􏲍java.lang.Thread􏲎
􏲏􏲐􏲍java.util.concurrent.TimeUnit􏲎
􏲏􏲐􏲍java.lang.RuntimeException􏲎
􏲏􏲐􏲍java.io.IOException􏲎
􏲏􏲐􏲍java.util.function.Supplier􏲎
􏲏􏲐􏲍org.mockito.Mock􏲎
􏲏􏲐􏲍org.mockito.MockitoAnnotations􏲎
􏲏􏲐􏲍java.util.Arrays􏲎
􏲏i􏲐􏲍com.google.common.truth.Truth.assertThat􏲎
􏲏i􏲐􏲍org.mockito.Mockito.eq􏲎
􏲏i􏲐􏲍org.mockito.Mockito.mock􏲎
􏲏i􏲐􏲍org.mockito.Mockito.times􏲎
􏲏i􏲐􏲍org.mockito.Mockito.verify􏲎
􏲏i􏲐􏲍org.mockito.Mockito.when􏲎
􏲏i􏲐􏲍org.mockito.Mockito.any􏲎
􏲏􏲐􏲍java.util.HashSet􏲎
􏲏􏲐􏲍java.util.Map􏲎
􏲏􏲐􏲍java.util.Set􏲎


􏶨wildcard value􏶧
􏶦symbol for identifying wildcard in both key/value of provisions􏶥
􏶘+s􏶙􏶰c􏶯􏶮String􏶭􏶬WILDCARD_VALUE􏶫􏶪"*"􏶩

􏶨if the queue will deem any set of properties eligible􏶧
􏶦if any of the provision keys has a wildcard, we consider anything for the queue to be eligible􏶥
􏶘-􏶙􏶰c􏶯􏶮bool􏶭􏶬is fully wildcard􏶫􏶪􏶩

􏶨the wildcard provisions of the queue􏶧
􏶦a filtered set of all provisions that use wildcards􏶥
􏶘-􏶙􏶰c􏶯􏶮Set<String>􏶭􏶬wildcard provisions􏶫􏶪􏶩

􏶨the required provisions of the queue􏶧
􏶦The required provisions to allow workers and operations to be added to the queue.  
These often match the remote api's command platform properties􏶥
􏶘-􏶙􏶰c􏶯􏶮Set<Map.Entry<String, String>>􏶭􏶬required provisions􏶫􏶪􏶩

􏶨the queue itself􏶧
􏶦a balanced redis queue designed to hold particularly provisioned elements􏶥
􏶘-􏶙􏶰c􏶯􏶮BalancedRedisQueue􏶭􏶬queue􏶫􏶪􏶩

􏷐constructor􏷏
􏶠construct the provision queue􏶡
􏷘+􏷗􏴅Constructor􏴆􏷒provisioned redis queue􏷑
􏶜􏶝􏷆string􏷅􏷄name􏷃􏷀the global name of the queue􏶿
􏶜􏶝􏷆List<String>􏷅􏷄hashtags􏷃􏷀hashtags to distribute queue data􏶿
􏶜􏶝􏷆SetMultimap<String, String>􏷅􏷄filter provisions􏷃􏷀the filtered provisions of the queue􏶿
􏶴
    this.queue = new BalancedRedisQueue(name, hashtags);
    isFullyWildcard = filterProvisions.containsKey(WILDCARD_VALUE);
    filterProvisionsByWildcard(filterProvisions);
􏶳
􏴱can construct􏴲􏴯regular􏴰
􏲝the object can be constructed􏲞
􏲛the object cannot be constructed􏲜
􏴭
    RedisProvisionQueue queue = new RedisProvisionQueue();
􏴮

􏷐filter the provisions into separate sets by checking for the existence of wildcards􏷏
􏶠this will organize the incoming  provisions into separate sets􏶡
􏷘-􏷗􏴅Observers􏴆􏷒filter provisions by wildcard􏷑
􏶜􏶝􏷆SetMultimap<String, String>􏷅􏷄filter provisions􏷃􏷀the filtered provisions of the queue􏶿
􏶴
    wildcardProvisions =
        isFullyWildcard
            ? ImmutableSet.of()
            : filterProvisions.asMap().entrySet().stream()
                .filter(e -> e.getValue().contains(WILDCARD_VALUE))
                .map(e -> e.getKey())
                .collect(ImmutableSet.toImmutableSet());
    requiredProvisions =
        isFullyWildcard
            ? ImmutableSet.of()
            : filterProvisions.entries().stream()
                .filter(e -> !wildcardProvisions.contains(e.getKey()))
                .collect(ImmutableSet.toImmutableSet());
􏶳

􏷐checks required properties􏷏
􏶠checks whether the properties given fulfill all of the required provisions of the queue􏶡
􏷘+􏷗􏴅Observers􏴆􏷒is eligible􏷑
􏶜􏶝􏷆SetMultimap<String, String>􏷅􏷄properties􏷃􏷀properties to check that requirements are met􏶿
􏶾bool􏶽􏶼is eligible􏶻􏶺whether the queue is eligible based on the properties given􏶹
􏶴
    // set intersection of requirements and properties with wildcarding
    if (isFullyWildcard) {
      return true;
    }
    // all required non-wildcard provisions must be matched
    Set<Map.Entry<String, String>> requirements = new HashSet<>(requiredProvisions);
    for (Map.Entry<String, String> property : properties.entries()) {
      // for each of the properties specified, we must match requirements
      if (!wildcardProvisions.contains(property.getKey()) && !requirements.remove(property)) {
        return false;
      }
    }
    return requirements.isEmpty();
􏶳

􏷐explain eligibility􏷏
􏶠returns an explanation as to why the properties provided are eligible / ineligible to be placed on the queue􏶡
􏷘+􏷗􏴅Observers􏴆􏷒explain eligibility􏷑
􏶜􏶝􏷆SetMultimap<String, String>􏷅􏷄properties􏷃􏷀properties to get an eligibility explanation of􏶿
􏶾String􏶽􏶼explanation􏶻􏶺an explanation on the eligibility of the provided properties􏶹
􏶴

     //is it eligible?
     String explanation = new String();
     if (isEligible(properties)){
        explanation += "The properties are eligible for the queue.\n";
     }
     else {
        explanation += "The properties are not eligible for the queue.\n";
     }
     
     //why so?
     if (isFullyWildcard) {
        explanation += "The queue is fully wildcard.\n";
        return explanation;
     }
     
     ImmutableSetMultimap.Builder<String, String> matched = ImmutableSetMultimap.builder();
     ImmutableSetMultimap.Builder<String, String> unmatched = ImmutableSetMultimap.builder();
     ImmutableSetMultimap.Builder<String, String> stillRequired = ImmutableSetMultimap.builder();
     
    Set<Map.Entry<String, String>> requirements = new HashSet<>(requiredProvisions);
    for (Map.Entry<String, String> property : properties.entries()) {
      // for each of the properties specified, we must match requirements
      if (!wildcardProvisions.contains(property.getKey()) && !requirements.remove(property)) {
        unmatched.put(property);
      }
      else{
        matched.put(property);
      }
    }
    
    
 
 
 
 
􏶳

􏷐get queue􏷏
􏶠obtain the internal queue􏶡
􏷘+􏷗􏴅Getters􏴆􏷒queue􏷑
􏶾BalancedRedisQueue􏶽􏶼queue􏶻􏶺the internal queue􏶹
􏶴
    return queue;
􏶳
