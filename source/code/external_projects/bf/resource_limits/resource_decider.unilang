􏶞o􏶟
􏷲Decide the resource limitations for a given command􏷱
􏷰platform properties from specified exec_properties are taken into account as well as global buildfarm configuration􏷯
􏷞build􏷝􏷞buildfarm􏷝􏷞worker􏷝

􏷤􏷣􏷦com.google.common.collect.LinkedHashMultimap􏷥
􏷤􏷣􏷦com.google.common.collect.Lists􏷥
􏷤􏷣􏷦com.google.common.collect.SetMultimap􏷥
􏷤􏷣􏷦java.util.List􏷥
􏷤􏷣􏷦build.buildfarm.common.redis.BalancedRedisQueue􏷥
􏷤􏷣􏷦redis.clients.jedis.JedisCluster􏷥
􏷤􏷣􏷦java.util.HashSet􏷥
􏷤􏷣􏷦java.util.Map􏷥
􏷤􏷣􏷦java.util.Set􏷥
􏷤􏷣􏷦com.google.common.collect.ImmutableSet􏷥
􏷤􏷣􏷦com.google.common.collect.ImmutableSetMultimap􏷥
􏷤􏷣􏷦java.util.stream.Collectors􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.Command􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.Platform.Property􏷥
􏷤􏷣􏷦com.google.common.collect.Iterables􏷥
􏷤􏷣􏷦java.util.Collections􏷥
􏷤􏷣􏷦org.json.simple.parser.JSONParser􏷥
􏷤􏷣􏷦org.json.simple.parser.ParseException􏷥
􏲏􏲐􏲍com.google.common.collect.LinkedHashMultimap􏲎
􏲏􏲐􏲍com.google.common.collect.Lists􏲎
􏲏􏲐􏲍com.google.common.collect.SetMultimap􏲎
􏲏􏲐􏲍java.util.List􏲎
􏲏􏲐􏲍build.buildfarm.common.redis.BalancedRedisQueue􏲎
􏲏􏲐􏲍redis.clients.jedis.JedisCluster􏲎
􏲏􏲐􏲍java.util.HashSet􏲎
􏲏􏲐􏲍java.util.Map􏲎
􏲏􏲐􏲍java.util.Set􏲎
􏲏􏲐􏲍com.google.common.collect.ImmutableSet􏲎
􏲏􏲐􏲍com.google.common.collect.ImmutableSetMultimap􏲎
􏲏􏲐􏲍java.util.stream.Collectors􏲎
􏲏􏲐􏲍build.bazel.remote.execution.v2.Command􏲎
􏲏􏲐􏲍build.bazel.remote.execution.v2.Platform􏲎
􏲏􏲐􏲍build.bazel.remote.execution.v2.Platform.Property􏲎
􏲏􏲐􏲍com.google.common.collect.Iterables􏲎
􏲏􏲐􏲍java.util.Collections􏲎
􏲏􏲐􏲍org.json.simple.parser.JSONParser􏲎
􏲏􏲐􏲍org.json.simple.parser.ParseException􏲎
􏲏􏲐􏲍redis.clients.jedis.JedisCluster􏲎
􏲏􏲐􏲍org.junit.Test􏲎
􏲏􏲐􏲍java.util.List􏲎
􏲏􏲐􏲍java.util.ArrayList􏲎
􏲏􏲐􏲍org.junit.runner.RunWith􏲎
􏲏􏲐􏲍org.junit.runners.JUnit4􏲎
􏲏􏲐􏲍java.lang.Thread􏲎
􏲏􏲐􏲍java.util.concurrent.TimeUnit􏲎
􏲏􏲐􏲍java.lang.RuntimeException􏲎
􏲏􏲐􏲍java.io.IOException􏲎
􏲏􏲐􏲍java.util.function.Supplier􏲎
􏲏􏲐􏲍org.mockito.Mock􏲎
􏲏􏲐􏲍org.mockito.MockitoAnnotations􏲎
􏲏􏲐􏲍java.util.Arrays􏲎
􏲏i􏲐􏲍com.google.common.truth.Truth.assertThat􏲎
􏲏i􏲐􏲍org.mockito.Mockito.eq􏲎
􏲏i􏲐􏲍org.mockito.Mockito.mock􏲎
􏲏i􏲐􏲍org.mockito.Mockito.times􏲎
􏲏i􏲐􏲍org.mockito.Mockito.verify􏲎
􏲏i􏲐􏲍org.mockito.Mockito.when􏲎
􏲏i􏲐􏲍org.mockito.Mockito.any􏲎
􏲏􏲐􏲍java.util.HashSet􏲎
􏲏􏲐􏲍java.util.Map􏲎
􏲏􏲐􏲍java.util.Set􏲎
􏲏􏲐􏲍com.google.common.collect.ImmutableList􏲎
􏲏􏲐􏲍build.buildfarm.common.redis.ProvisionedRedisQueue􏲎
􏲏􏲐􏲍com.google.common.collect.Maps􏲎
􏲏􏲐􏲍com.google.common.collect.HashMultimap􏲎
􏲏􏲐􏲍java.util.stream.Collectors􏲎
􏲏􏲐􏲍com.google.common.collect.SetMultimap􏲎
􏲏􏲐􏲍com.google.common.collect.Multimap􏲎
􏲏􏲐􏲍build.buildfarm.worker.ResourceLimits􏲎
􏲏􏲐􏲍build.buildfarm.worker.ResourceDecider􏲎

􏶨the exec_property and platform property name for setting min cores􏶧
􏶦this is decided between client and server􏶥
􏶘-s􏶙􏶰c􏶯􏶮String􏶭􏶬exec property min cores􏶫􏶪"min-cores"􏶩

􏶨the exec_property and platform property name for setting max cores􏶧
􏶦this is decided between client and server􏶥
􏶘-s􏶙􏶰c􏶯􏶮String􏶭􏶬exec property max cores􏶫􏶪"max-cores"􏶩

􏶨the exec_property and platform property name for providing additional environment variables􏶧
􏶦this is decided between client and server􏶥
􏶘-s􏶙􏶰c􏶯􏶮String􏶭􏶬exec property env vars􏶫􏶪"env-vars"􏶩

􏷐decide resource limitations for the given command􏷏
􏶠platform properties from specified exec_properties are taken into account as well as global buildfarm configuration􏶡
􏷘+s􏷗􏴅Observer􏴆􏷒decide resource limitations􏷑
􏶜􏶝􏷆Command􏷅􏷄command􏷃􏷀the command to decide resource limitations for􏶿
􏶜􏶝􏷆bool􏷅􏷄only multicore tests􏷃􏷀only allow ttests to be multicore􏶿
􏶜􏶝􏷆i􏷅􏷄execute stage width􏷃􏷀the maximum amount of cores available for the operation􏶿
􏶾ResourceLimits􏶽􏶼resource limits􏶻􏶺default resource limits􏶹
􏶴
    ResourceLimits limits = getDefaultLimitations();
    
    setCpuLimits(limits,command,onlyMulticoreTests,executeStageWidth);
    setEnvironmentVariables(limits,command,onlyMulticoreTests);
    
    return limits;

􏶳
􏴱test core setting􏴲􏴯regular􏴰
􏲝test that cores can be set􏲞
􏲛cores were not decided as expected􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder()
    .addProperties(Platform.Property.newBuilder()
    .setName("min-cores").setValue("7"))
    .addProperties(Platform.Property.newBuilder()
    .setName("max-cores").setValue("14")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,false,100);
    
    //ASSERT
    assertThat(limits.cpu.min).isEqualTo(7);
    assertThat(limits.cpu.max).isEqualTo(14);
􏴮
􏴱test core setting skipped on nontest􏴲􏴯regular􏴰
􏲝test that cores are skipped􏲞
􏲛cores were not decided as expected􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder()
    .addProperties(Platform.Property.newBuilder()
    .setName("min-cores").setValue("7"))
    .addProperties(Platform.Property.newBuilder()
    .setName("max-cores").setValue("14")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.cpu.min).isEqualTo(1);
    assertThat(limits.cpu.max).isEqualTo(1);
􏴮
􏴱test default environment parse􏴲􏴯regular􏴰
􏲝if the user does not pass extra environment variables via platform properties they appear empty􏲞
􏲛the parsing crashed or did not provide an empty map􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().build();
    
    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.isEmpty()).isTrue();
􏴮
􏴱test empty environment parse􏴲􏴯regular􏴰
􏲝if the user does not pass extra environment variables via platform properties they appear empty􏲞
􏲛the parsing crashed or did not provide an empty map􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder().addProperties(Platform.Property.newBuilder()
    .setName("env-vars")
    .setValue("")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.isEmpty()).isTrue();
􏴮
􏴱test single environment parse􏴲􏴯regular􏴰
􏲝if the user passes an extra environment variable via platform properties they should be parsed into the map􏲞
􏲛the parsing crashed or the map was not correctly populated􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder().addProperties(Platform.Property.newBuilder()
    .setName("env-vars")
    .setValue("{\"foo\": \"bar\"}")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.size()).isEqualTo(1);
    assertThat(limits.extraEnvironmentVariables.containsKey("foo")).isTrue();
    assertThat(limits.extraEnvironmentVariables.get("foo")).isEqualTo("bar");
􏴮
􏴱test double environment parse􏴲􏴯regular􏴰
􏲝if the user passes an extra environment variable via platform properties they should be parsed into the map􏲞
􏲛the parsing crashed or the map was not correctly populated􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder().addProperties(Platform.Property.newBuilder()
    .setName("env-vars")
    .setValue("{\"foo\": \"bar\", \"baz\": \"qux\"}")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.size()).isEqualTo(2);
    assertThat(limits.extraEnvironmentVariables.containsKey("foo")).isTrue();
    assertThat(limits.extraEnvironmentVariables.get("foo")).isEqualTo("bar");
    assertThat(limits.extraEnvironmentVariables.containsKey("baz")).isTrue();
    assertThat(limits.extraEnvironmentVariables.get("baz")).isEqualTo("qux");
􏴮
􏴱test malformed environment parse􏴲􏴯regular􏴰
􏲝when a user passes malformed json to the extra environment variables, safely ignore it􏲞
􏲛the parsing crashed or the map was not correctly populated􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder().addProperties(Platform.Property.newBuilder()
    .setName("env-vars")
    .setValue("{\"foo\": \"bar\", \"baz\": \"qux\"} xxxx")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.size()).isEqualTo(0);
􏴮
􏴱test environment mustache resolution􏴲􏴯regular􏴰
􏲝test that environment variables can have their values resolved􏲞
􏲛values were not resolved as expected􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder()
    .addProperties(Platform.Property.newBuilder()
    .setName("min-cores").setValue("7"))
    .addProperties(Platform.Property.newBuilder()
    .setName("max-cores").setValue("14"))
    
    .addProperties(Platform.Property.newBuilder()
    .setName("env-vars")
    .setValue("{\"foo\": \"{{limits.cpu.min}}\", \"bar\": \"{{limits.cpu.max}}\"}")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,false,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.size()).isEqualTo(2);
    assertThat(limits.extraEnvironmentVariables.containsKey("foo")).isTrue();
    assertThat(limits.extraEnvironmentVariables.get("foo")).isEqualTo("7");
    assertThat(limits.extraEnvironmentVariables.containsKey("bar")).isTrue();
    assertThat(limits.extraEnvironmentVariables.get("bar")).isEqualTo("14");
􏴮

􏷐decide CPU limitations􏷏
􏶠given a default set of limitations, use the command and global configuration to adjust CPU limitations􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒set cpu limits􏷑
􏶜􏶝􏷆ResourceLimits􏷅􏷄limits􏷃􏷀current limits to apply changes to􏶿
􏶜􏶝􏷆Command􏷅􏷄command􏷃􏷀the command to decide resource limitations􏶿
􏶜􏶝􏷆bool􏷅􏷄only multicore tests􏷃􏷀only allow ttests to be multicore􏶿
􏶜􏶝􏷆i􏷅􏷄execute stage width􏷃􏷀the maximum amount of cores available for the operation􏶿
􏶴
    
    // apply cpu limits specified on command
    limits.cpu.min = getIntegerPlatformValue(command,EXEC_PROPERTY_MIN_CORES,limits.cpu.min);
    limits.cpu.max = getIntegerPlatformValue(command,EXEC_PROPERTY_MAX_CORES,limits.cpu.max);
    
    // force limits on non-test actions
    if (onlyMulticoreTests && !commandIsTest(command)){
        limits.cpu.min = 1;
        limits.cpu.max = 1;
    }
    
    // claim core amount according to execute stage width
    limits.cpu.claimed =Math.min(limits.cpu.min, executeStageWidth);
􏶳

􏷐decide extra environment variables􏷏
􏶠given a default set of limitations, use the command and global configuration to adjust the extra environment variables􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒set environment variables􏷑
􏶜􏶝􏷆ResourceLimits􏷅􏷄limits􏷃􏷀current limits to apply changes to􏶿
􏶜􏶝􏷆Command􏷅􏷄command􏷃􏷀the command to decide resource limitations􏶿
􏶜􏶝􏷆bool􏷅􏷄only multicore tests􏷃􏷀only allow ttests to be multicore􏶿
􏶴
    
    // parse any user given environment variables into a map
    // if the json is malformed assume no environment variables were given
    try {
      JSONParser parser = new JSONParser();
      limits.extraEnvironmentVariables =
          (Map<String, String>)
              parser.parse(getStringPlatformValue(command, EXEC_PROPERTY_ENV_VARS, "{}"));
    } catch (ParseException pe) {
    }
    
    // resolve any template values
    limits.extraEnvironmentVariables.replaceAll((key, val) 
                    -> {
                    val = val.replace("{{limits.cpu.min}}",String.valueOf(limits.cpu.min));
                    val = val.replace("{{limits.cpu.max}}",String.valueOf(limits.cpu.max));
                    val = val.replace("{{limits.cpu.claimed}}",String.valueOf(limits.cpu.claimed));
                    return val;}
                    );
    
􏶳

􏷐get default resource limits􏷏
􏶠get the default resource limits before adjusting based on action's exec_properties global configuration􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒get default limitations􏷑
􏶾ResourceLimits􏶽􏶼resource limits􏶻􏶺default resource limits􏶹
􏶴
    // These can be moved to configuration in the future
    ResourceLimits limits = new ResourceLimits();
    
    // we usually prefer to isolate operations through some kind of visualization (cgroups)
    // and then limit their execution to a single core.  When necessary, user's request more cores.
    limits.cpu = new CpuLimits();
    limits.cpu.limit = true;
    limits.cpu.min = 1;
    limits.cpu.max = 1;
    limits.cpu.claimed = 1;
    
    // Sometimes a client needs to add extra environment variables to their execution.  
    // If they are unable to set these in their code, and --action_env is not sufficient,
    // they may choose to annotate extra environment variables this way.
    // these environment variables can be templated, which allows them to reference
    // other values related to their execution.
    // for example, a client may want certain rules to set environment variables
    // based on what buildfarm decides to limit the core count to.
    // that could look like this:  
    // "OMP_NUM_THREADS": "{limits.cpu.max}"
    // "MKL_NUM_THREADS": "{limits.cpu.max}"
    limits.extraEnvironmentVariables = Collections.emptyMap();
    
    return limits;
􏶳

􏷐get an integer value from a platform property􏷏
􏶠Get the first value of the property name given
If the property name does not exist the default provided is returned􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒get integer platform value􏷑
􏶜􏶝􏷆Command􏷅􏷄command􏷃􏷀the command to extract the platform value from􏶿
􏶜􏶝􏷆String􏷅􏷄name􏷃􏷀the platform property name􏶿
􏶜􏶝􏷆i􏷅􏷄default val􏷃􏷀the default value if the property name does not exist􏶿
􏶾i􏶽􏶼platform value􏶻􏶺the decided platform value􏶹
􏶴
    for (Property property : command.getPlatform().getPropertiesList()) {
        if (property.getName().equals(name)) {
            return Integer.parseInt(property.getValue());
        }
    }
    return defaultVal;
􏶳
􏷐get a string value from a platform property􏷏
􏶠Get the first value of the property name given
If the property name does not exist the default provided is returned􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒get string platform value􏷑
􏶜􏶝􏷆Command􏷅􏷄command􏷃􏷀the command to extract the platform value from􏶿
􏶜􏶝􏷆String􏷅􏷄name􏷃􏷀the platform property name􏶿
􏶜􏶝􏷆String􏷅􏷄default val􏷃􏷀the default value if the property name does not exist􏶿
􏶾String􏶽􏶼platform value􏶻􏶺the decided platform value􏶹
􏶴
    for (Property property : command.getPlatform().getPropertiesList()) {
        if (property.getName().equals(name)) {
            return property.getValue();
        }
    }
    return defaultVal;
􏶳

􏷐derive if command is a test run􏷏
􏶠find a reliable way to identify whether a command is a test or not􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒command is test􏷑
􏶜􏶝􏷆Command􏷅􏷄command􏷃􏷀the command to identify as a test command􏶿
􏶾bool􏶽􏶼exists􏶻􏶺whether the command is a test􏶹
􏶴
    // only tests are setting this currently - other mechanisms are unreliable
    return Iterables.any(
        command.getEnvironmentVariablesList(),
        (envVar) -> envVar.getName().equals("XML_OUTPUT_FILE"));
􏶳


