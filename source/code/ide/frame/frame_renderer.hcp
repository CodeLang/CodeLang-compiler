class
❪"code/ide/settings/ide_settings"❫
❪"code/utilities/graphics/imgui/mechanics"❫
❪"SDL.h"❫
⚯
❪"code/utilities/graphics/imgui/ui/ui_renders"❫
❪"code/utilities/graphics/imgui/ui/window/window_renderer"❫
❪"code/utilities/graphics/imgui/ui/window/window_position_finder"❫
❪"code/utilities/graphics/imgui/ui/draw/label/label_drawer"❫
❪"code/utilities/graphics/imgui/ui/draw/rectangle/rectangle_drawer"❫
❪"code/utilities/graphics/imgui/ui/draw/imgui_type_utility"❫
❪"code/ide/frame/cursor_mover"❫
❪"code/ide/frame/fullscreener"❫
❪"code/ide/frame/background_drawer"❫
⚞⚟



◀public: static▶ void ☀each_frame(Ide_Settings & settings,SDL_Window* window)❰

        ImGuiIO& io = ImGui::GetIO();
        io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
        io.WantCaptureKeyboard = true;
        io.WantTextInput = true;

    Fullscreener::Possibly_Fullscreen(settings,window);
    
    //Draw the main window and render everything inside of it
    Prepare_Window_Drawing_Surface(settings);
    Window_Renderer::render(settings.main_window,[&](){
        Draw_Everything(settings);
    });
        
   bool flag = true;
    ImGui::ShowDemoWindow(&flag);
    
❱

◀public: static▶ void ☀Prepare_Window_Drawing_Surface(Ide_Settings & settings)❰

    //create a giant window that spans the entire application
    //since we are using imgui, we have found it better to draw bitmaps on what imgui considers a window.  
    //it does not seem possible to draw directly on the background.  Additionally, an imgui window has some extra frills
    //that also prevent it from being colored everywhere.  We grow the window larger than the application window,
    //so that we have an entire drawable surface. You might be asking, "why even use imgui, if you are just going to be drawing pixels on a blank surface?"
    //that's a good question, imgui may not be strictly necessary.  For the time being, I like the "immediate-modeness" of it,
    //and seems to have a nice drawing abstraction over direct libraries like sdl and opengl, etc.
    Position window_end_position = Imgui_Type_Utility::Display_Size_Position();
    window_end_position.x += 8;
    Update_Background_For_Window_Size(settings,window_end_position);
    ImGui::SetNextWindowPos(Imgui_Type_Utility::To_ImVec2(settings.main_window_backdrop_starting_position));
    ImGui::SetNextWindowSize(Imgui_Type_Utility::To_ImVec2(window_end_position));
❱

◀private: static▶ void ☀Update_Background_For_Window_Size(Ide_Settings & settings, Position const& window_end_position)❰
    settings.main_window_backdrop.width = window_end_position.x;
    settings.main_window_backdrop.height = window_end_position.y;
❱
◀private: static▶ void ☀Draw_Everything(Ide_Settings & settings)❰
        
    //object for drawing everything
    ImDrawList *draw_list = ImGui::GetWindowDrawList();
    
    
    //draw the background for the entire application
    Background_Drawer::Draw_Background(draw_list,settings);
    
    //the closest to the corner we can get
    //this is basically used as our pseudo (0,0) for drawing anything in our application
    auto pos = Window_Position_Finder::attempted_perfect_top_left_corner();
    pos.x += 10;
    pos.y += 10;
        
    //auto time = ImGui::GetTime();
    //auto time = ImGui::GetFrameCount();
    //settings.test_label.message = std::to_string(time);
    Label_Drawer::Draw(draw_list,settings.unilang_font_lookup,pos,settings.test_label);
    for (auto & it: settings.test_label.cursors){
        Handle_Cursor_Selections(draw_list,settings,settings.test_label,it);
    }
    
    //Cursor_Drawer::Draw(draw_list,pos,settings.cursor);
    
    if (ImGui::IsMouseClicked(0)){
        auto mouse_pos = ImGui::GetMousePos();
        settings.mouse_selection_position.x = mouse_pos.x;
        settings.mouse_selection_position.y = mouse_pos.y;
    }
    
    if (ImGui::IsMouseDown(0)){
        auto mouse_pos = ImGui::GetMousePos();
        settings.mouse_selection.shape.width = mouse_pos.x - settings.mouse_selection_position.x;
        settings.mouse_selection.shape.height = mouse_pos.y - settings.mouse_selection_position.y;
        
        Rectangle_Drawer::draw_rectangle(draw_list,settings.mouse_selection_position,settings.mouse_selection.shape);
    }
    
    
    
    
    
    //draw custom mouse
    /*
    auto mouse_pos = ImGui::GetMousePos();
    Position pop;
    pop.x = mouse_pos.x;
    pop.y = mouse_pos.y;
    std::cout << pop.x << " " << pop.y << std::endl;
    auto s2 = settings.cursor.shape;
    s2.width = 100;
    ImGui::SetMouseCursor(ImGuiMouseCursor_None); 
    Rectangle_Drawer::draw_rectangle(draw_list,pop,s2);
    */
❱

◀private: static▶ void ☀Handle_Cursor_Selections(ImDrawList *draw_list, Ide_Settings const& settings, Label_Settings & label, Label_Cursor_Selection & selection)❰
    
    //std::cout << selection.label_index << " " << selection.recommended_cursor_pos.x << " " << selection.recommended_cursor_pos.y << std::endl;
    if (label.is_active){
        Handle_Backwards_Deletion(label,selection);
        Handle_Fowards_Insertion(label,selection);
        //TODO: more
        
        
        auto cursor_draw_pos = selection.recommended_cursor_pos;
        Rectangle_Drawer::draw_rectangle(draw_list,cursor_draw_pos,settings.cursor.shape);
    }
❱

◀private: static▶ void ☀Handle_Fowards_Insertion(Label_Settings & label, Label_Cursor_Selection & selection)❰

    for (auto const& c: Currently_Buffered_User_Input_Chars()){
        if (c != 0){
            if (isprint(c) || isspace(c))
            {
                label.message.insert(selection.label_index+1,1,c);
                selection.recommended_cursor_pos.x += 6;
                selection.label_index += 1;
            }
        }
    }
❱

◀private: static▶ std::vector<char> ☀Currently_Buffered_User_Input_Chars()❰
    std::vector<char> x;
    ImGuiIO& io = ImGui::GetIO();
    IM_ARRAYSIZE(io.InputCharacters);
    for (int i = 0; i < IM_ARRAYSIZE(io.InputCharacters); i++){
        x.emplace_back((unsigned char)io.InputCharacters[i]);
    }
    return x;
❱

◀private: static▶ void ☀Handle_Backwards_Deletion(Label_Settings & label, Label_Cursor_Selection & selection)❰
    if (Backspace_Pressed()){
        if (!label.message.empty()){
            if (selection.label_index > -1){
                label.message.erase(selection.label_index,1);
                selection.recommended_cursor_pos.x -= 6;
                selection.label_index -= 1;
            }
        }
    }
❱


◀private: static▶ bool ☀Backspace_Pressed()❰
    auto key_index = ImGui::GetKeyIndex(ImGuiKey_Backspace);
    if (ImGui::IsKeyPressed(key_index,true)){
        return true;
    }
    return false;
❱