class
❪"code/programs/repo_tools/graph_visualize/program_options/program_options"❫
⚯
⚞⚟


◀public: static▶ void ☀Execute_Needed_Tasks(Program_Options const& options) ❰


    // Get and Run
    auto repo_context = Build_Repo_Establisher::Establish_Repo_For_Building(options.Run_Dir(),options.Url(),options.Branch());
    
    // auto results = Bazel_Aquery_Runner::Run_Aquery(repo_context.program_to_run_build,options.Target());
    // std::cout << Protobuf_Message_To_Json(results.aquery_result) << std::endl;
    
    
    
    
    auto spawns = Bazel_Runner::Get_Spawn_Information_As_Cmd_Map(repo_context.program_to_run_build,
                                                                 repo_context.build_settings,
                                                                 repo_context.bazel_setup_settings.config_settings,
                                                                 options.Target());
    
    
    
    Gexf_Data gexf_data;
    gexf_data.metadata.creator = "luxe";
    gexf_data.metadata.description = "bazel graph";
    gexf_data.metadata.keywords.emplace_back("bazel");
    gexf_data.metadata.keywords.emplace_back("execution");
    
    Add_Nodes(gexf_data,spawns);
    Add_Edges(gexf_data,spawns);
    
    
    std::map<std::string,nlohmann::json> node_data;
    auto file_results = Gexf_Formatter::Format(gexf_data,node_data);
    Write_To_File("/home/luxe/Desktop/bazel_graph.gexf",file_results);
    
    
❱


◀private: static▶ void ☀Add_Nodes(Gexf_Data & gexf_data, std::unordered_map<std::string,tools::protos::SpawnExec> const& spawns) ❰

    for (auto const& it: spawns) {
        
        
        // record all input files as nodes
        for (auto input: it.second.inputs()){
            
            if (Should_Record_Path(input.path())){
                gexf_data.node_edge_data.nodes.insert(input.path());
            }
        }
        
        // record all output files as nodes
        for (auto output: it.second.actual_outputs()){
            
            if (Should_Record_Path(output.path())){
                gexf_data.node_edge_data.nodes.insert(output.path());
            }
        }
        
        //record all the hashes representing the unique action as nodes
        //gexf_data.node_edge_data.nodes.insert(it.second.digest().hash());
        gexf_data.node_edge_data.nodes.insert(it.second.target_label());
        
    }
    
❱

◀private: static▶ void ☀Add_Edges(Gexf_Data & gexf_data, std::unordered_map<std::string,tools::protos::SpawnExec> const& spawns) ❰

    for (auto const& it: spawns) {
        for (auto input: it.second.inputs()){
            if (Should_Record_Path(input.path())){
                Timed_Connection c;
                c.connection.source = input.path();
                c.connection.target = it.second.target_label();
                c.connection.type = Edge_Type::DIRECTED;
                gexf_data.node_edge_data.edges.Add(Type_To_Json_String::As_JSON_String(c));
            }
            
            
        }
        
        for (auto output: it.second.actual_outputs()){
            if (Should_Record_Path(output.path())){
                Timed_Connection c;
                c.connection.source = it.second.target_label();
                c.connection.target = output.path();
                c.connection.type = Edge_Type::DIRECTED;
                gexf_data.node_edge_data.edges.Add(Type_To_Json_String::As_JSON_String(c));
            }
            
            
        }
    }
    
    
    
❱

◀private: static▶ bool ☀Should_Record_Path(std::string const& path) ❰
    return !Begins_With(path,"external/ubuntu_20_04_clang_11_sysroot") && !Begins_With(path,"external/llvm_toolchain/");
❱