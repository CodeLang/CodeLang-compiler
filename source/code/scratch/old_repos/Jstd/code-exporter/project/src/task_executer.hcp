❪iostream❫
❪string❫
❪vector❫
❪"program_options"❫
⚯
❪"code_exporter"❫
❪"utilities"❫
❪"global"❫
⚞⚟

◀public: static▶ void ☀Do_Needed_Tasks(Program_Options const& program_options) ❰

	//make sure we are running the program in the right place
	if (!File_Exists(constant::NAME_OF_PSEUDO_LIBRARY_FOLDER)){
		Exit_With_Error("This program needs to be run above the folder: " + constant::NAME_OF_PSEUDO_LIBRARY_FOLDER);
	}

	//get the time we last ran the program
	auto last_run_time = Get_Last_Run_Time();

	//get the path where we will be exporting to.
	auto current_path = Current_Path();
	auto export_path = Current_Path() + "/export/code/";
	std::cout << export_path << std::endl;

	//avoid stepping into the .git repo by stepping into the root of the pseudo library
	Step_Into_Folder(constant::NAME_OF_PSEUDO_LIBRARY_FOLDER);
	Step_Into_Folder("root");

	//run scanner on all the files that are newer than the LAST_TIME_RAN_FILE
	Code_Exporter::Export_Pseudo_Library(program_options,export_path);

	//updates the "last modified" time, which was read in
	//at the beginning of the program.  this basically the same as touching the file
	Set_Path(current_path);
	Touch_Time_File();

	return;
❱


◀private: static▶ void ☀Create_Time_File_If_One_Does_Not_Exist() ❰
	if (!File_Exists(constant::LAST_TIME_RAN_FILE)){Touch_Time_File();}
	return;
❱

◀private: static▶ void ☀Touch_Time_File() ❰
	std::ofstream outfile(constant::LAST_TIME_RAN_FILE);
	outfile << "The time stamp of this file is looked at to determine when this tool was last run\n";
	return;
❱

◀private: static▶ std::time_t ☀Get_Last_Run_Time() ❰
	Create_Time_File_If_One_Does_Not_Exist();
	return boost::filesystem::last_write_time(constant::LAST_TIME_RAN_FILE);
❱
