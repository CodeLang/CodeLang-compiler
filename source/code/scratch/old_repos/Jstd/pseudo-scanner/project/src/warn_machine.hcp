❪iostream❫
❪string❫
❪vector❫
❪cstdlib❫
❪"warn_fixer"❫
⚯
❪"utilities"❫
❪"global"❫
⚞⚟

//constructor
◀public:▶ ☀Warn_Machine(int const& warn_amount):
m_warn_amount(warn_amount)
{}

//compacts (called by compact_scanner)
◀public:▶ bool ☀Record_Duplicate_Compact(std::string const& file, std::string const& compact) {

	m_warn_log.Record_Duplicate_Compact(boost::filesystem::current_path().string() + "/" + file, compact);
	Red_Message(boost::filesystem::current_path().string() + "/" + file + " contains the compact " + compact + " multiple times!\n");
	return Decide_If_Limit_Is_Reached();

  }
◀public:▶ bool ☀Record_Invalid_Compact(std::string const& file, int const& line_number, std::string const& problems) {

	m_warn_log.Record_Invalid_Compact(boost::filesystem::current_path().string() + "/" + file, line_number, problems);
	Red_Message(boost::filesystem::current_path().string() + "/" + file + " contains an invalid compact at line " + std::to_string(line_number) + "!  It has the following problems: " + problems + "\n");
	return Decide_If_Limit_Is_Reached();

  }

//fix all of the warnings or prompt to fix them all (called by the scanner)
◀public:▶ void ☀Fix_Warnings(bool const& prompt) {
	Warn_Fixer::Fix_Warnings(prompt, m_warn_log);
	return;
 }


◀private:▶bool ☀Decide_If_Limit_Is_Reached(){

	if (m_warn_amount >= 0){

	 if (m_warn_amount == 0){
	  return false;
	}
	 --m_warn_amount;

   }

	return true;
  }

◀
private:
int m_warn_amount; //negative anything is infinity
Warn_Log m_warn_log;
▶
