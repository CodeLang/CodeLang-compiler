class
❪"systems"❫
❪"utilities"❫
❪"component"❫
❪"settings"❫
⚯
❪"case_modifier"❫
❪"shared"❫


⚞⚟

◀public: static▶ void ☀Copy(Component & component, Settings const& settings)❰

    //generated folder name no matter what.
    //whether we only export one file, or many files, they appear in there.
    auto folder_name = Case_Modifier::As_Modified_Casing(Case_Format_Style::CAMEL_CASE,component.file_name);
    
    //store all the files discovered after the export
    component.list_of_exported_files = Get_Everything_At_Path(folder_name);
    
    //decide whether to copy over a directory, or just a file
    if (Folder_Has_C_Or_CPP_File(folder_name)){
        Green_Message_And_Flush("[multi]");
        Copy_Over_Multiple_Files(component,folder_name,settings);
    }
    else{
        Green_Message_And_Flush("[single]");
        Copy_Over_Single_File(component,folder_name,settings);
    }
❱

◀private: static▶ void ☀Copy_Over_Single_File(Component const& component, std::string folder_name, Settings const& settings)❰
    
    Shared::Wait_For_Directory_To_Exist(folder_name);
    execute("cp -rf " + folder_name + "/*.h " + settings.Full_Path_To_Code_Root() + component.path_to_export);
❱

◀private: static▶ void ☀Copy_Over_Multiple_Files(Component const& component, std::string folder_name, Settings const& settings)❰
    
    //base directory to transfer folder to
    std::string directory_to_copy_to = settings.Full_Path_To_Code_Root() + component.path_to_export;
    
    if (component.flatten){
        Flatten_Exported_Directory_During_Transfer(component,folder_name,directory_to_copy_to);
    }
    else{
        Transfer_Directory_During_Transfer(component,folder_name,directory_to_copy_to);
    }
❱

◀private: static▶ void ☀Flatten_Exported_Directory_During_Transfer(Component const& component, std::string folder_name, std::string directory_to_copy_to)❰
    Shared::Wait_For_Directory_To_Exist(folder_name);
    Copy_Folder_Contents_To_Path(folder_name,directory_to_copy_to);
❱
◀private: static▶ void ☀Transfer_Directory_During_Transfer(Component const& component, std::string folder_name, std::string directory_to_copy_to)❰

    //use a different folder name than the one derived
    if (!component.new_folder_name.empty()){
        directory_to_copy_to += "/" + component.new_folder_name;
        execute("mkdir -p " + directory_to_copy_to);
        
        Shared::Wait_For_Directory_To_Exist(folder_name);
        Copy_Folder_Contents_To_Path(folder_name,directory_to_copy_to);
    }
    else{
        Shared::Wait_For_Directory_To_Exist(folder_name);
        Copy_Folder_To_Path(folder_name,directory_to_copy_to);
    }
❱