class
❪"systems"❫
❪"utilities"❫
❪"component"❫
❪"settings"❫
❪"things_to_style"❫
❪"case_modifier"❫
⚯
⚞⚟

◀public: static▶ void ☀Style(Component const& component, Settings const& settings)❰

    auto things_to_style = Get_Things_To_Style(component,settings);
    
    Run_Clang_Format(settings,things_to_style);

    //TODO: clang-format partially formats things wrong.  It seems like it works on return types that are fundamental, but not ADTs and macro types
    //Run_Custom_Program("search-and-replace",things_to_style,"--target='__attribute__((warn_unused_result)) ' --replacement='__attribute__((warn_unused_result))\n'");
    Run_Custom_Program("remove-top-empty-lines",things_to_style,"");
    Run_Custom_Program("rtrim-lines",things_to_style,"");
    Run_Custom_Program("whitespace-lines-to-empty-lines",things_to_style,"");
    Run_Custom_Program("squeeze-whitespace-lines",things_to_style,"");
    Run_Custom_Program("macro-value-aligner",things_to_style,"");
    Run_Custom_Program("brace_breaker_for_typedefed_enums",things_to_style,"");
    Run_Custom_Program("set-a-single-blank-line-to-the-end-of-file",things_to_style,"");
❱

◀private: static▶ Things_To_Style ☀Get_Things_To_Style(Component const& component, Settings const& settings)❰
    
    Things_To_Style style;
    
    //base directory to transfer folder to
    style.path_to_dir = Decide_The_Directory_That_An_Object_Would_Get_Exported_To(component,settings);
    
    style.potential_header = style.path_to_dir + ".h";
    
    return style;
❱


◀private: static▶ std::string ☀Decide_The_Directory_That_An_Object_Would_Get_Exported_To(Component const& component, Settings const& settings)❰
  
    //We are either a directory deep from where we said we were going to put it.  
    //Or we are in the directory we said we were going to put it.

    //base directory to transfer folder to
    std::string exported_object_dir = settings.Full_Path_To_Code_Root() + component.path_to_export;
    
    //the directory the files were flattened into
    if (component.flatten){
      //use derived path
    }
    
    //use a different folder name than the one derived
    else if (!component.new_folder_name.empty()){
        exported_object_dir += "/" + component.new_folder_name;
    }
    
    //use the derived one
    else{
        exported_object_dir += "/" + Case_Modifier::As_Modified_Casing(Case_Format_Style::CAMEL_CASE,component.file_name);
    }
  
  
  
  return exported_object_dir;
❱


◀private: static▶ void ☀Run_Clang_Format(Settings const& settings, Things_To_Style things)❰
  execute(settings.clang_format_tool + " --style=file -i " + things.path_to_dir + "/*.h > /dev/null 2>&1;");
  execute(settings.clang_format_tool + " --style=file -i " + things.path_to_dir + "/*.c > /dev/null 2>&1;");
  execute(settings.clang_format_tool + " --style=file -i " + things.path_to_dir + "/*.hpp > /dev/null 2>&1;");
  execute(settings.clang_format_tool + " --style=file -i " + things.path_to_dir + "/*.cpp > /dev/null 2>&1;");
  execute(settings.clang_format_tool + " --style=file -i " + things.potential_header + " > /dev/null 2>&1;");
❱
◀private: static▶ void ☀Run_Custom_Program(std::string const& program_name, Things_To_Style things, std::string const& additional_arguments)❰
  execute(program_name + " -i " + additional_arguments + " " + things.path_to_dir + "/*.h > /dev/null 2>&1;");
  execute(program_name + " -i " + additional_arguments + " " + things.path_to_dir + "/*.c > /dev/null 2>&1;");
  execute(program_name + " -i " + additional_arguments + " " + things.path_to_dir + "/*.hpp > /dev/null 2>&1;");
  execute(program_name + " -i " + additional_arguments + " " + things.path_to_dir + "/*.cpp > /dev/null 2>&1;");
  execute(program_name + " -i " + additional_arguments + " " + things.potential_header + " > /dev/null 2>&1;");
❱

