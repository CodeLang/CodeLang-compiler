class
❪"systems"❫
❪"utilities"❫
❪"component"❫
❪"settings"❫
⚯
❪"case_modifier"❫
❪"shared"❫
⚞⚟


◀public: static▶ void ☀Transfer_Over_Any_Test_Wrappers(Component const& component, Settings const& settings) ❰

    
    /*
    switch(component.style){
        case Export_Style::OBJECT_GOOD:
        case Export_Style::OBJECT_BAD_WITH_BOOLS:
        case Export_Style::OBJECT_BAD_WITH_ENUMS:
        break;
        default:;
    }
    */
    
    //generated folder name no matter what.
    //whether we only export one file, or many files, they appear in there.
    auto folder_name = Case_Modifier::As_Modified_Casing(Case_Format_Style::CAMEL_CASE,component.file_name);
    
    //std::cout << "[" << folder_name << "]" << std::endl;
    //std::cout << Current_Path();

    std::string wrapper_name = folder_name + "Wrapper";
    if (Is_Directory(wrapper_name)){
        Purple_Message("[wrapper]");
        Copy_Over_Test_Wrapper(component,folder_name, settings);
    }
❱



◀private: static▶ void ☀Copy_Over_Test_Wrapper(Component const& component, std::string const& folder_name, Settings const& settings)❰

    
    std::string path_to_specific_test;
    
    //decide where to send test wrapper
    
    //use the specified test wrapper path if one is provided
    //if one is not provided, use the same relative path for testing that is used on the actual repo
    if (component.path_to_export_wrapper.empty()){
        path_to_specific_test = settings.Full_Path_To_Test_Root() + component.path_to_export + "/" + folder_name;
    }else{
        path_to_specific_test = settings.Full_Path_To_Test_Root() + component.path_to_export_wrapper + "/" + folder_name;
    }
    
    
    execute("mkdir -p " + path_to_specific_test + "/Linux/Src");
    Shared::Wait_For_Directory_To_Exist(folder_name + "Wrapper");
    execute("cp -rf " + folder_name + "Wrapper " + path_to_specific_test + "/Linux/Src");
    
    auto path_to_moved_test_wrapper = path_to_specific_test + "/Linux/Src/" + folder_name + "Wrapper/";
    //std::cout << path_to_moved_test_wrapper << "*.cpp" << std::endl;
    
    //format the files
    execute(settings.clang_format_tool + " --style=file -i " + path_to_moved_test_wrapper + "*.h > /dev/null 2>&1;");
    execute(settings.clang_format_tool + " --style=file -i " + path_to_moved_test_wrapper + "*.c > /dev/null 2>&1;");
    execute(settings.clang_format_tool + " --style=file -i " + path_to_moved_test_wrapper + "*.hpp > /dev/null 2>&1;");
    execute(settings.clang_format_tool + " --style=file -i " + path_to_moved_test_wrapper + "*.cpp > /dev/null 2>&1;");
❱