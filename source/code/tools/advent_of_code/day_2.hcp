class
❪"code/utilities/data_structures/compass_directions/compass_direction_diagnonal_movement"❫
❪"code/utilities/data_structures/point/point_line"❫
❪"code/utilities/data_structures/point/point_mover"❫
⚯
❪"code/utilities/types/general/lib"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/types/vectors/transformers/lib"❫
❪"code/utilities/types/vectors/converters/lib"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/types/strings/observers/converting/lib"❫
❪"code/utilities/types/strings/observers/splitting/lib"❫
❪"code/utilities/types/strings/transformers/removing/lib"❫
❪"code/utilities/exits/lib"❫
❪"code/utilities/web/lib"❫
❪"code/utilities/printers/prettyprint"❫
❪"code/utilities/web/automate/browser/default_browser_settings_getter"❫
❪"code/utilities/web/automate/browser/browser_creator"❫
❪"code/utilities/web/automate/navigation/browser_navigator"❫
❪"code/tools/advent_of_code/advent_of_code_input_getter"❫
❪"code/utilities/json/functions/lib"❫
❪"code/utilities/data_structures/point/point"❫
❪"code/utilities/data_structures/point/point_line_intersections_getter"❫
❪"code/utilities/data_structures/point/point_line_to_points"❫
⚞⚟

◀public: static▶ void ☀Part_1(std::vector<std::string> lines) ❰
    auto nums = Split_Into_Parts_From_Comma(lines[0]);
    auto result = Program_Result(nums,12,2);
    std::cout << result << std::endl;
❱

◀public: static▶ void ☀Part_2(std::vector<std::string> lines) ❰

    auto nums = Split_Into_Parts_From_Comma(lines[0]);
    
    
    auto seek_result = 19690720;
    size_t answer = 0;
    
    Nested_Loop(0,100,0,100,[&](size_t i, size_t j, bool & stop){
        if (Program_Result(nums,i,j) == seek_result){
            answer = 100 * i + j;
            stop = true;
        }
    });
    
    std::cout << answer << std::endl;
❱

◀public: static▶ int ☀Program_Result(std::vector<std::string> num_strs, int input1, int input2) ❰

    auto nums = VecStringToVecInt(num_strs);
    
    //99 means stop
    //1 means read next two, add and store in third
    //2 multiplies
    nums[1] = input1;
    nums[2] = input2;
    //std::cout << nums << std::endl;
    
    int opcode_stop = 99;
    int opcode_add = 1;
    int opcode_mul = 2;
    
    size_t pc = 0;
    while(nums[pc] != opcode_stop){
        if (nums[pc] == opcode_add){
            Position_Mode_Linear_Addition(nums,pc);
        }
        else if (nums[pc] == opcode_mul){
            Position_Mode_Linear_Multiply(nums,pc);
        }
    }
    return nums[0];
❱