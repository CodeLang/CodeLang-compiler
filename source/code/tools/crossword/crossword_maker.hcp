class
❪string❫
❪"code/utilities/data_structures/compass_direction"❫
❪"code/utilities/data_structures/compass_direction_diagnonal"❫
❪"code/utilities/data_structures/point/point"❫
❪"code/tools/crossword/settings/crossword_puzzle_settings"❫
❪"code/tools/crossword/word_try"❫
⚯
❪iostream❫
❪"code/utilities/types/vectors/creators/lib"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/printers/prettyprint"❫
❪"code/utilities/random/lib"❫
❪"code/utilities/filesystem/files/creating/lib"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
⚞⚟

◀public: static▶ void ☀Make()❰

    //puzzle settings
    auto settings = Get_Settings();

    //create grid
    auto grid = Create_N_By_N_Vector_Of_Question_Marks(settings.dimensions.x,settings.dimensions.y);
    
    //place words
    Randomly_Place_Each_Word(grid,settings);
    
    //take a peek
    std::cout << std::endl;
    std::cout << Table_As_Column_Aligned(grid) << std::endl;
    
    //fill empty spaces
    Fill_Remaining_Spaces_With_Random_Letters(grid);
    
    //create artifact
    auto str = As_Html_Format(grid,settings.words);
    Write_To_File(settings.file_name,str);
❱



◀private: static▶ Crossword_Puzzle_Settings ☀Get_Settings()❰
    Crossword_Puzzle_Settings settings;
    
    settings.file_name = "/home/laptop/Desktop/crossword.html";
    
    settings.dimensions.x = 40;
    settings.dimensions.y = 40;
    
    settings.words.emplace_back("angel");
    settings.words.emplace_back("snowman");
    settings.words.emplace_back("santa");
    settings.words.emplace_back("tree");
    settings.words.emplace_back("merry");
    settings.words.emplace_back("light");
    settings.words.emplace_back("snow");
    settings.words.emplace_back("candy cane");
    settings.words.emplace_back("candle");
    settings.words.emplace_back("cookie");
    settings.words.emplace_back("stocking");
    settings.words.emplace_back("sleigh");
    settings.words.emplace_back("reindeer");
    settings.words.emplace_back("presents");
    settings.words.emplace_back("winter");
    settings.words.emplace_back("holiday");
    settings.words.emplace_back("eggnog");
    settings.words.emplace_back("evergreen");
    settings.words.emplace_back("gingerbread");
    settings.words.emplace_back("ornament");
    settings.words.emplace_back("gingle");
    settings.words.emplace_back("star");
    settings.words.emplace_back("fireplace");
    settings.words.emplace_back("cider");
    settings.words.emplace_back("joy");
    settings.words.emplace_back("party");
    settings.words.emplace_back("rudolph");
    
    return settings;
❱

◀private: static▶ void ☀Randomly_Place_Each_Word(std::vector<std::vector<std::string>> & grid, Crossword_Puzzle_Settings const& settings)❰

    for (auto const& word: settings.words){
        
        //get random position and direction
        auto word_try = Random_Word_Try(grid);
        
        std::cout << "fitting " << word << std::endl;
        while (!Word_Fits(grid,word,word_try)){
            
            //try again
            word_try = Random_Word_Try(grid);
        }
        Fit_Word(grid,word,word_try);
    }
❱

◀private: static▶ Word_Try ☀Random_Word_Try(std::vector<std::vector<std::string>> const& grid)❰
    Word_Try x;
    x.point.x = Get_Random_Index(grid);
    x.point.y = Get_Random_Index(grid[0]);
    x.direction = static_cast<Compass_Direction_Diagnonal>(RandomIntFromRange(0,7));
    return x;
❱

◀private: static▶ void ☀Fill_Remaining_Spaces_With_Random_Letters(std::vector<std::vector<std::string>> & grid)❰
    std::string q_mark = "?";
    for (auto & x: grid){
        for (auto & y: x){
            if (y == q_mark){
                y = Random_Lowercase_Letter();
            }
        }
    }
❱


◀private: static▶ std::string ☀As_Html_Format(std::vector<std::vector<std::string>> const& grid, std::vector<std::string> const& words)❰
    std::string x;
    Append_With_Newline(x,"<!doctype html>");
    Append_With_Newline(x,"<html>");
    Append_With_Newline(x,"<head>");
    Append_With_Newline(x,"<style>");
    Append_With_Newline(x,"table, th, td { border: 0px solid black; }");
    Append_With_Newline(x,"table { padding-bottom: 60px; }");
    Append_With_Newline(x,"tr { text-align: center; }");
    Append_With_Newline(x,"</style>");
    Append_With_Newline(x,"</head>");
    Append_With_Newline(x,"<body>");
    
    Append_With_Newline(x,"<strong> T&T word search game </strong>");
    
    //puzzle box
    Append_With_Newline(x,"<table style=\"width:100%\">");
    for (auto const& a: grid){
        Append_With_Newline(x,"<tr>");
        for (auto const& b: a){
            Append_With_Newline(x,"<td>");
            Append_With_Newline(x,b);
            Append_With_Newline(x,"</td>");
        }
        Append_With_Newline(x,"</tr>");
    }
    Append_With_Newline(x,"</table>");
    
    
    
    
    //word bank
    Append_With_Newline(x,"<table style=\"width:100%\">");
    int count = 0;
    Append_With_Newline(x,"<tr>");
    for (auto const& word: words){
        if (count == 4){
            count = 0;
            Append_With_Newline(x,"</tr>");
            Append_With_Newline(x,"<tr>");
        }
        
            Append_With_Newline(x,"<td>");
            Append_With_Newline(x,word);
            Append_With_Newline(x,"</td>");
        
        ++count;
    }
    Append_With_Newline(x,"</tr>");
    Append_With_Newline(x,"</table>");
    
    Append_With_Newline(x,"</body>");
    Append_With_Newline(x,"</html>");
    
    return x;
❱

◀private: static▶ bool ☀Word_Fits(std::vector<std::vector<std::string>> const& grid, std::string const& word, Word_Try word_try)❰

    for (auto letter: word){
        if (!Position_In_Range(grid,word_try.point)){
            return false;
        }
        
        std::string str;
        str += letter;
        if (grid[word_try.point.x][word_try.point.y] != "?" && grid[word_try.point.x][word_try.point.y] != str){
            return false;
        }
        
        Move_Position_In_Direction(word_try.point,word_try.direction);
    }
    
    
    return true;
❱

◀private: static▶ void ☀Fit_Word(std::vector<std::vector<std::string>> & grid, std::string const& word, Word_Try word_try)❰
    for (auto letter: word){
        grid[word_try.point.x][word_try.point.y] = letter;
        Move_Position_In_Direction(word_try.point,word_try.direction);
    }
❱

◀private: static▶ bool ☀Position_In_Range(std::vector<std::vector<std::string>> const& grid, Point const& p)❰
    if (p.x < 0 || p.y < 0){
        return false;
    }
    if (p.x > grid.size()-1){
        return false;
    }
    
    if (p.y > grid[0].size()-1){
        return false;
    }
    return true;
❱


◀private: static▶ void ☀Move_Position_In_Direction(Point & point, Compass_Direction_Diagnonal const& dir)❰
    if (dir == Compass_Direction_Diagnonal::NORTH){
        point.y -= 1;
        return;
    }
    if (dir == Compass_Direction_Diagnonal::SOUTH){
        point.y += 1;
        return;
    }
    
    if (dir == Compass_Direction_Diagnonal::WEST){
        point.x -= 1;
        return;
    }
    if (dir == Compass_Direction_Diagnonal::EAST){
        point.x += 1;
        return;
    }
    
    if (dir == Compass_Direction_Diagnonal::NORTH_WEST){
        point.y -= 1;
        point.x -= 1;
        return;
    }
    if (dir == Compass_Direction_Diagnonal::SOUTH_WEST){
        point.y += 1;
        point.x -= 1;
        return;
    }
    if (dir == Compass_Direction_Diagnonal::NORTH_EAST){
        point.y -= 1;
        point.x += 1;
        return;
    }
    if (dir == Compass_Direction_Diagnonal::SOUTH_EAST){
        point.y += 1;
        point.x += 1;
        return;
    }
❱






