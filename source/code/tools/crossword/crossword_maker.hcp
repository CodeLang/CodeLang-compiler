class
❪string❫
❪"code/utilities/data_structures/compass_direction"❫
❪"code/utilities/data_structures/compass_direction_diagnonal"❫
❪"code/utilities/data_structures/point/point"❫
❪"code/tools/crossword/settings/crossword_puzzle_settings"❫
❪"code/tools/crossword/word_try"❫
⚯
❪iostream❫
❪"code/utilities/types/vectors/creators/lib"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/types/strings/transformers/removing/lib"❫
❪"code/utilities/printers/prettyprint"❫
❪"code/utilities/random/lib"❫
❪"code/utilities/filesystem/files/creating/lib"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
❪"code/tools/crossword/html_exporter"❫
⚞⚟

◀public: static▶ void ☀Make()❰

    //puzzle settings
    auto settings = Get_Settings();

    //create grid
    auto grid = Create_N_By_N_Vector_Of_Question_Marks(settings.dimensions.x,settings.dimensions.y);
    
    //place words
    Randomly_Place_Each_Word(grid,settings);
    
    //take a peek
    //std::cout << std::endl;
    //std::cout << Table_As_Column_Aligned(grid) << std::endl;
    Html_Exporter::Export(grid,settings,settings.answer_file_name);
    
    //fill empty spaces
    Fill_Remaining_Spaces_With_Random_Letters(grid);
    
    //create artifacts
    Html_Exporter::Export(grid,settings,settings.puzzle_file_name);
❱





◀private: static▶ Crossword_Puzzle_Settings ☀Get_Settings()❰
    Crossword_Puzzle_Settings settings;
    
    settings.puzzle_file_name = "/home/laptop/Desktop/crossword.html";
    settings.answer_file_name = "/home/laptop/Desktop/crossword_answer.html";
    
    settings.dimensions.x = 25;
    settings.dimensions.y = 30;
    
    settings.words = United_States_Words();
    
    return settings;
❱

◀private: static▶ std::vector<std::string> ☀Christmas_Words()❰
    std::vector<std::string> x;
    x.emplace_back("angel");
    x.emplace_back("snowman");
    x.emplace_back("santa");
    x.emplace_back("tree");
    x.emplace_back("merry");
    x.emplace_back("light");
    x.emplace_back("snow");
    x.emplace_back("candy cane");
    x.emplace_back("candle");
    x.emplace_back("cookie");
    x.emplace_back("stocking");
    x.emplace_back("sleigh");
    x.emplace_back("reindeer");
    x.emplace_back("presents");
    x.emplace_back("winter");
    x.emplace_back("holiday");
    x.emplace_back("eggnog");
    x.emplace_back("evergreen");
    x.emplace_back("gingerbread");
    x.emplace_back("ornament");
    x.emplace_back("gingle");
    x.emplace_back("star");
    x.emplace_back("fireplace");
    x.emplace_back("cider");
    x.emplace_back("joy");
    x.emplace_back("party");
    x.emplace_back("rudolph");
    return x;
❱

◀private: static▶ std::vector<std::string> ☀United_States_Words()❰
    std::vector<std::string> x;
    x.emplace_back("hamburger");
    x.emplace_back("cheese");
    x.emplace_back("frech fries");
    x.emplace_back("pierogi");
    x.emplace_back("pizza");
    x.emplace_back("pepperoni");
    x.emplace_back("fried chicken");
    x.emplace_back("turkey");
    x.emplace_back("pumpkin pie");
    x.emplace_back("barbecue");
    x.emplace_back("chowder");
    x.emplace_back("bagel");
    x.emplace_back("salad");
    x.emplace_back("jambalaya");
    x.emplace_back("gumbo");
    x.emplace_back("hot dog");
    x.emplace_back("parfait");
    x.emplace_back("pudding");
    x.emplace_back("tots");
    x.emplace_back("pancake");
    x.emplace_back("key lime");
    x.emplace_back("poboy");
    x.emplace_back("subway");
    x.emplace_back("hoagies");
    x.emplace_back("beignets");
    x.emplace_back("beer");
    x.emplace_back("etouffee");
    x.emplace_back("doughnut");
    x.emplace_back("salad");
    x.emplace_back("coke");
    return x;
❱

◀private: static▶ void ☀Randomly_Place_Each_Word(std::vector<std::vector<std::string>> & grid, Crossword_Puzzle_Settings const& settings)❰

    for (auto word: settings.words){
        
        Remove_Spaces(word);
        std::cout << word << std::endl;
        
        //get random position and direction
        auto word_try = Random_Word_Try(grid);
        
        std::cout << "fitting " << word << std::endl;
        while (!Word_Fits(grid,word,word_try)){
            
            //try again
            word_try = Random_Word_Try(grid);
        }
        Fit_Word(grid,word,word_try);
    }
❱

◀private: static▶ Word_Try ☀Random_Word_Try(std::vector<std::vector<std::string>> const& grid)❰
    Word_Try x;
    x.point.x = Get_Random_Index(grid);
    x.point.y = Get_Random_Index(grid[0]);
    x.direction = static_cast<Compass_Direction_Diagnonal>(RandomIntFromRange(0,7));
    return x;
❱

◀private: static▶ void ☀Fill_Remaining_Spaces_With_Random_Letters(std::vector<std::vector<std::string>> & grid)❰
    std::string q_mark = "?";
    for (auto & x: grid){
        for (auto & y: x){
            if (y == q_mark){
                y = Random_Lowercase_Letter();
            }
        }
    }
❱

◀private: static▶ bool ☀Word_Fits(std::vector<std::vector<std::string>> const& grid, std::string const& word, Word_Try word_try)❰

    for (auto letter: word){
        if (!Position_In_Range(grid,word_try.point)){
            return false;
        }
        
        std::string str;
        str += letter;
        if (grid[word_try.point.x][word_try.point.y] != "?" && grid[word_try.point.x][word_try.point.y] != str){
            return false;
        }
        
        Move_Position_In_Direction(word_try.point,word_try.direction);
    }
    
    
    return true;
❱

◀private: static▶ void ☀Fit_Word(std::vector<std::vector<std::string>> & grid, std::string const& word, Word_Try word_try)❰
    for (auto letter: word){
        grid[word_try.point.x][word_try.point.y] = letter;
        Move_Position_In_Direction(word_try.point,word_try.direction);
    }
❱

◀private: static▶ bool ☀Position_In_Range(std::vector<std::vector<std::string>> const& grid, Point const& p)❰
    if (p.x < 0 || p.y < 0){
        return false;
    }
    if (p.x > grid.size()-1){
        return false;
    }
    
    if (p.y > grid[0].size()-1){
        return false;
    }
    return true;
❱


◀private: static▶ void ☀Move_Position_In_Direction(Point & point, Compass_Direction_Diagnonal const& dir)❰
    if (dir == Compass_Direction_Diagnonal::NORTH){
        point.y -= 1;
        return;
    }
    if (dir == Compass_Direction_Diagnonal::SOUTH){
        point.y += 1;
        return;
    }
    
    if (dir == Compass_Direction_Diagnonal::WEST){
        point.x -= 1;
        return;
    }
    if (dir == Compass_Direction_Diagnonal::EAST){
        point.x += 1;
        return;
    }
    
    if (dir == Compass_Direction_Diagnonal::NORTH_WEST){
        point.y -= 1;
        point.x -= 1;
        return;
    }
    if (dir == Compass_Direction_Diagnonal::SOUTH_WEST){
        point.y += 1;
        point.x -= 1;
        return;
    }
    if (dir == Compass_Direction_Diagnonal::NORTH_EAST){
        point.y -= 1;
        point.x += 1;
        return;
    }
    if (dir == Compass_Direction_Diagnonal::SOUTH_EAST){
        point.y += 1;
        point.x += 1;
        return;
    }
❱






