class
❪string❫
❪"code/utilities/data_structures/point/point_mover"❫
❪"code/tools/crossword/settings/crossword_puzzle_settings"❫
❪"code/tools/crossword/word_try"❫
❪"code/tools/crossword/crossword_words"❫
⚯
❪iostream❫
❪"code/utilities/types/vectors/creators/lib"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/types/strings/transformers/removing/lib"❫
❪"code/utilities/printers/prettyprint"❫
❪"code/utilities/random/lib"❫
❪"code/utilities/filesystem/files/creating/lib"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
❪"code/tools/crossword/html_exporter"❫
⚞⚟

//TODO: make question mark symbol generic

◀public: static▶ void ☀Make()❰

    //puzzle settings
    auto settings = Get_Settings();

    //create grid
    auto grid = Create_N_By_N_Vector_Of_Strs(settings.dimensions.x,settings.dimensions.y,"?");
    
    //place words
    Randomly_Place_Each_Word(grid,settings);
    
    //take a peek
    //std::cout << std::endl;
    //std::cout << Table_As_Column_Aligned(grid) << std::endl;
    if (settings.create_answer_artifact){
        Html_Exporter::Export(grid,settings,settings.answer_file_name);
    }
    
    //fill empty spaces
    Fill_Remaining_Spaces_With_Random_Letters(grid);
    
    //create artifacts
    if (settings.create_puzzle_artifact){
        Html_Exporter::Export(grid,settings,settings.puzzle_file_name);
    }
❱





◀private: static▶ Crossword_Puzzle_Settings ☀Get_Settings()❰
    Crossword_Puzzle_Settings settings;
    
    settings.create_puzzle_artifact = true;
    settings.puzzle_file_name = "/home/laptop/Desktop/crossword.html";
    
    settings.create_answer_artifact = false;
    settings.answer_file_name = "/home/laptop/Desktop/crossword_answer.html";
    
    settings.dimensions.x = 25;
    settings.dimensions.y = 30;
    
    settings.words = Crossword_Words::Jungle_Words();
    
    return settings;
❱

◀private: static▶ void ☀Randomly_Place_Each_Word(std::vector<std::vector<std::string>> & grid, Crossword_Puzzle_Settings const& settings)❰

    for (auto word: settings.words){
        
        Remove_Spaces(word);
        
        //get random position and direction
        //auto word_try = Random_Word_Try(grid);
        
        auto word_try = Primed_Random_Word_Try(grid,word);
        
        std::cout << "fitting " << word << std::endl;
        while (!Word_Fits(grid,word,word_try)){
            
            //try again
            word_try = Random_Word_Try(grid);
        }
        Fit_Word(grid,word,word_try);
    }
❱

◀private: static▶ Word_Try ☀Primed_Random_Word_Try(std::vector<std::vector<std::string>> const& grid, std::string const& word)❰
    
    auto word_try = Random_Word_Try(grid);
    for (int i = 0; i < 20; ++i){
        if (Word_Fits_And_Has_Pass_Through(grid,word,word_try)){
            std::cout << "passthrough" << std::endl;
            return word_try;
        }
        word_try = Random_Word_Try(grid);
    }
    
    return word_try;
❱

◀private: static▶ Word_Try ☀Random_Word_Try(std::vector<std::vector<std::string>> const& grid)❰
    Word_Try x;
    x.point.x = Get_Random_Index(grid);
    x.point.y = Get_Random_Index(grid[0]);
    x.direction = static_cast<Compass_Direction_Diagnonal>(RandomIntFromRange(0,7));
    return x;
❱

◀private: static▶ void ☀Fill_Remaining_Spaces_With_Random_Letters(std::vector<std::vector<std::string>> & grid)❰
    std::string q_mark = "?";
    for (auto & x: grid){
        for (auto & y: x){
            if (y == q_mark){
                y = Random_Lowercase_Letter();
            }
        }
    }
❱

◀private: static▶ bool ☀Word_Fits(std::vector<std::vector<std::string>> const& grid, std::string const& word, Word_Try word_try)❰

    for (auto letter: word){
        if (!Position_In_Range(grid,word_try.point)){
            return false;
        }
        
        std::string str;
        str += letter;
        if (grid[word_try.point.x][word_try.point.y] != "?" && grid[word_try.point.x][word_try.point.y] != str){
            return false;
        }
        
        Point_Mover::Move_In_Direction(word_try.point,word_try.direction);
    }
    
    return true;
❱

◀private: static▶ bool ☀Word_Fits_And_Has_Pass_Through(std::vector<std::vector<std::string>> const& grid, std::string const& word, Word_Try word_try)❰


    bool has_pass_through = false;
    for (auto letter: word){
        if (!Position_In_Range(grid,word_try.point)){
            return false;
        }
        
        std::string str;
        str += letter;
        if (grid[word_try.point.x][word_try.point.y] != "?" && grid[word_try.point.x][word_try.point.y] != str){
            return false;
        }
        
        if (grid[word_try.point.x][word_try.point.y] != "?"){
            has_pass_through = true;
        }
        
        Point_Mover::Move_In_Direction(word_try.point,word_try.direction);
    }
    
    return has_pass_through;
❱

◀private: static▶ void ☀Fit_Word(std::vector<std::vector<std::string>> & grid, std::string const& word, Word_Try word_try)❰
    for (auto letter: word){
        grid[word_try.point.x][word_try.point.y] = letter;
        Point_Mover::Move_In_Direction(word_try.point,word_try.direction);
    }
❱

◀private: static▶ bool ☀Position_In_Range(std::vector<std::vector<std::string>> const& grid, Point const& p)❰
    if (p.x < 0 || p.y < 0){
        return false;
    }
    if (p.x > grid.size()-1){
        return false;
    }
    
    if (p.y > grid[0].size()-1){
        return false;
    }
    return true;
❱






