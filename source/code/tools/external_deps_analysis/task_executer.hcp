class
❪iostream❫
❪string❫
❪utility❫
❪"code/utilities/shell/lib"❫
❪"code/utilities/printers/prettyprint"❫
❪"code/tools/external_deps_analysis/settings"❫
❪"code/tools/external_deps_analysis/analysis_state"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/types/vectors/transformers/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/types/strings/transformers/removing/lib"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
❪"code/utilities/types/sets/lib"❫
❪"code/utilities/graphviz/graphviz_image_maker"❫
⚯
⚞⚟


◀public: static▶ void ☀Execute_Needed_Tasks() ❰

    //settings
    Settings settings;
    settings.run_path = "/home/thickey/Desktop/na";
    settings.result_path = "/home/thickey/Desktop/results/results";
    settings.bazel_wrapper = "./bazel";
    settings.dep_name = "cuda";
    settings.verbose = true;
    
    //move into bazel managed repo
    Set_Path(settings.run_path);
    
    //start the analysis at a particular dependency
    Analysis_State state;
    state.deps_to_explore.push(settings.dep_name);
    
    //build all the relationships
    while (!state.deps_to_explore.empty()){
        
        //since we are now exploring this dependency, remove it from the queue
        auto dep = Pop_Front(state.deps_to_explore);
        
        
        //if we haven't yet explored this dependency do so, and add it to the set so we don't do it again
        if (!Exists_In_Set(state.dep_explored,dep)){
            state.dep_explored.insert(dep);
            
            if (settings.verbose){
                std::cout << "querying " << dep << "... ";
                std::cout.flush();
            }
            Explore_The_Direct_Relationships(settings,state,dep);
        }
    }
    
    //remove cycles
    Remove_If(state.relationships,[&](std::pair<std::string,std::string> p){
        return p.first == p.second;
    });
    
    Output_Graphviz_Info(settings,state);
    
❱

◀private: static▶ void ☀Output_Graphviz_Info(Settings const& settings, Analysis_State const& state)❰

    std::vector<std::string> relationships_strs;
    for (auto const& it: state.relationships){
        std::string line = "";
        line += "\"";
        line += it.first;
        line += "\"";
        line += " -> ";
        line += "\"";
        line += it.second;
        line += "\"";
        relationships_strs.emplace_back(line);
    }
    
    std::string x;
    Append_With_Newline(x,"digraph results {");
    //Append_With_Newline(x,"splines=false;");
    Append_With_Newline(x,"node [");
    Append_With_Newline(x,"fontname=\"Arial\",");
    //Append_With_Newline(x,"shape = plaintext,");
    Append_With_Newline(x,"height=.1");
    Append_With_Newline(x,"]");
    for (auto const& it: relationships_strs){
        Append_With_Newline(x,it);
    }
    Append_With_Newline(x,"}");
    Graphviz_Image_Maker::Make(x,settings.result_path);
❱

◀private: static▶ void ☀Explore_The_Direct_Relationships(Settings const& settings, Analysis_State & state, std::string const& dep)❰

    //bazel query to get direct 3rd party dependencies
    auto results = Get_Direct_Dependencies(settings,dep);
    
    if (settings.verbose){
        std::cout << results << std::endl;
    }
    
    //add relationships
    for (auto const& it: results){state.relationships.emplace_back(dep,it);}
    
    //add deps to explore
    for (auto const& it: results){state.deps_to_explore.push(it);}
❱


◀private: static▶ std::string ☀Get_Bazel_Query_Command(Settings const& settings, std::string const& dep_name) ❰
    std::string command = settings.bazel_wrapper;
    command += " query 'rdeps(...,@" + dep_name + "//...)' ";
    command += "--implicit_deps ";
    command += "--keep_going 2> /dev/null ";
    return command;
❱

◀private: static▶ std::vector<std::string> ☀Get_Direct_Dependencies(Settings const& settings, std::string const& dep_name)❰

    auto command = Get_Bazel_Query_Command(settings,dep_name);
    auto results = Get_Each_Line_Of_Shell_Command(command);
    Remove_If(results,[&](std::string s){
        return !Begins_With(s,"@");
    });
    
    for (auto & it: results){
        Remove_Everything_After_Found_Instance(it,"//");
        Remove_First_Char(it);
    }
    
    Sort_And_Remove_Duplicates(results);
    return results;
❱

◀private: static▶ std::string ☀Pop_Front(std::queue<std::string> & q)❰
    std::string str = q.front();
    q.pop();
    return str;
❱




// #!/usr/bin/env bash
// #which external libraries directly rely on X

// for DEP in "$@"
// do
//     ./bazel query "rdeps(...,@$DEP//...)"        `#query reverse dependencies`\
//     --implicit_deps                              `#transitive/non-transitive`\
//     --keep_going 2> /dev/null                    `#rdeps fails on 3rd party projects that may have their own unused build rules`\
//     | grep "^@"                                  `#external targets only`\
//     | sed "/@$DEP/d"                             `#hide cycles`\
//     | sed 's|\//.*|//|'                          `#remove details after //`\
//     | sort | uniq                                `#remove duplicates`\
//     | cut -c2-                                   `#make it graphvizy`\
//     | sed 's/..$//'                              `#make it graphvizy`\
//     | sed 's/^/"/'                               `#make it graphvizy`\
//     | sed 's/$/" <- "'$DEP'"/'                   `#make it graphvizy`
// done
