class
❪string❫
❪iostream❫
❪vector❫
❪thread❫
❪"code/tools/games/word_build/gui/assets/assets"❫
❪SFML/Window.hpp❫
❪SFML/Window/Joystick.hpp❫
❪SFML/Graphics.hpp❫
❪SFML/Graphics/Transformable.hpp❫
❪"code/utilities/peripheral/keyboard/joycons/joycon_state_getter"❫
❪"code/utilities/peripheral/keyboard/F310_gamepad/functions/f310_gamepads_state_getter"❫
❪"code/utilities/formats/json/functions/lib"❫
❪"code/tools/games/word_build/gui/assets/assets_loader"❫
❪"code/tools/games/word_build/gui/state/game_state"❫
❪"code/utilities/math/math"❫
❪"code/utilities/types/vectors/observers/lib"❫
⚯
❪"code/utilities/peripheral/keyboard/joycons/joystick_rotating_checker"❫
❪"code/utilities/linguistics/build_word/game/puzzle_builder"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/types/vectors/transformers/lib"❫
❪"code/utilities/types/strings/observers/converting/lib"❫
❪"code/utilities/types/map/lib"❫
❪"code/utilities/types/vectors/observers/size_frequency_counter"❫
❪"code/utilities/linguistics/speak/word_speaker"❫
⚞⚟

◀public: static▶ void ☀Run_Frame_Logic(sf::RenderWindow & window, sf::Time const& TimePerFrame, Game_State & state, Assets & assets) ❰
    
    //make decisions based on user action

    auto controller_state = F310_Gamepads_State_Getter::Get();
    state.controller.left.current = controller_state.left;
    state.controller.right.current = controller_state.right;
    
    if (state.phase == Game_Phase::MAIN_MENU){
        //todo
    }
    else if (state.phase == Game_Phase::STARTING_GAME){
        Start_Game(state,assets);
        state.phase = Game_Phase::PLAYING_GAME;
    }
    else if(state.phase == Game_Phase::PLAYING_GAME){
        Regular_Game_Frame(state,assets);
    }
    else if(state.phase == Game_Phase::END_GAME){
        Game_Over(state,assets);
    }
    
    //store previous user actions
    state.controller.left.previous = controller_state.left;
    state.controller.right.previous = controller_state.right;
❱

◀private: static▶ void ☀Regular_Game_Frame(Game_State & state, Assets & assets) ❰

    //handle user input
    Handle_Player_Input(state,assets);

    Update_Game_State(state,assets);
❱

◀private: static▶ void ☀Start_Game(Game_State & state, Assets & assets) ❰

    //generate a new puzzle
    state.puzzle = Puzzle_Builder::Create_Puzzles(state.puzzle_build_settings)[0];
    
    //turn the new puzzle into assets
    assets.letters.clear();
    sf::Text temp;
    temp.setFont(assets.main_font);
    temp.setCharacterSize(150);
    for (auto const& letter: state.puzzle.letters){

        temp.setString(letter);
        assets.letters.emplace_back(temp);
    }
    
    int width = 200;
    for (auto & it: assets.letters){
        it.setPosition(width,300);
        width += 100;
    }
    
    //position the score
    assets.score.setPosition(width,335);
    
    //position the answers
    width += 250;
    assets.answers.clear();
    temp.setCharacterSize(25);
    temp.setFillColor(state.color);
    auto parts = Split_Every_N(state.puzzle.words,24);
    for (auto const& row: parts){
        
        int height = 100;
        for (auto const& col: row){
            temp.setPosition(width,height);
            temp.setString(col);
            assets.answers.emplace_back(temp);
            height += 40;
        }
        width += 180;
    }
    
    assets.p1.stats.setString("");
    assets.p2.stats.setString("");
    assets.p1.stats.setPosition(410,500);
    assets.p2.stats.setPosition(410,10);
    
    
    //reset the game timer
    state.countdown.restart();
    
    //reset the user state
    state.p1_state.current_letter_selection = 0;
    state.p1_state.selected_letters.clear();
    assets.p1.selections.clear();
    assets.p1.score.setString("0");
    state.p1_state.combo_countdown.restart();
    state.p1_state.current_combo = 0;
    state.p1_state.current_combo_timeout_ms = state.p1_state.start_combo_timeout_ms;
    
    state.p2_state.current_letter_selection = 0;
    state.p2_state.selected_letters.clear();
    assets.p2.selections.clear();
    assets.p2.score.setString("0");
    state.p2_state.combo_countdown.restart();
    state.p2_state.current_combo = 0;
    state.p2_state.current_combo_timeout_ms = state.p1_state.start_combo_timeout_ms;
    
    // assets.p1.combo_bar = sf::RectangleShape(sf::Vector2f(0, 20));
    // assets.p1.combo_bar.setPosition(325,assets.p1.pointer_y_offset+105);
    // assets.p1.combo_bar.setFillColor(p1_color);
    
    // assets.p2.combo_bar = sf::RectangleShape(sf::Vector2f(0, 20));
    // assets.p2.combo_bar.setPosition(325,assets.p2.pointer_y_offset-125);
    // assets.p2.combo_bar.setFillColor(p2_color);
    
    
    assets.p1.combo_bar.setSize(sf::Vector2f(0, 20));
    assets.p2.combo_bar.setSize(sf::Vector2f(0, 20));

❱


◀private: static▶ void ☀Handle_Player_Input(Game_State & state, Assets & assets)❰
    
    Handle_Player_Selections(state,state.controller.left,state.p1_state,assets.p1);
    Handle_Player_Selections(state,state.controller.right,state.p2_state,assets.p2);
    
    Player_Match_Check(state.p1_state,assets.p1,state,assets);
    Player_Match_Check(state.p2_state,assets.p2,state,assets);
    
    Handle_Player_Game_Changes(state,state.controller.left,assets);
    Handle_Player_Game_Changes(state,state.controller.right,assets);
    
    
❱


◀private: static▶ void ☀Handle_Player_Game_Changes(Game_State & state, F310_Gamepad_Phases const& phases, Assets & assets)❰

    //restart the game
    if (!phases.previous.center.start && phases.current.center.start){
        state.phase = Game_Phase::STARTING_GAME;
    }
    
    //end the game and show all the answers
    if (!phases.previous.center.back && phases.current.center.back){
        state.phase = Game_Phase::END_GAME;
        End_Game_Changes(state,assets);
    }
❱


◀private: static▶ void ☀Handle_Player_Selections(Game_State & state, F310_Gamepad_Phases const& phases, User_State & player_state, User_Assets & assets)❰

    //set player pointer
    if (!phases.previous.arrows.left && phases.current.arrows.left){
        Set_Previous_Index_In_Round_Robin(state.puzzle.letters,player_state.current_letter_selection);
        
        //was it a drag select?
        if (phases.current.buttons.right){
            Make_Selection(state,phases,player_state,assets);
        }
    }
    if (!phases.previous.arrows.right && phases.current.arrows.right){
        Set_Next_Index_In_Round_Robin(state.puzzle.letters,player_state.current_letter_selection);
        
        //was it a drag select?
        if (phases.current.buttons.right){
            Make_Selection(state,phases,player_state,assets);
        }
    }
    assets.pointer.setPosition((player_state.current_letter_selection*100) + assets.pointer_x_offset,assets.pointer_y_offset);
    
    //set player selection
    if (!phases.previous.buttons.right && phases.current.buttons.right){
        Make_Selection(state,phases,player_state,assets);
    }
    
    //drop player selection
    if (!phases.previous.buttons.down && phases.current.buttons.down){
        player_state.selected_letters.clear();
        assets.selections.clear();
    }
    
    //backspace selection
    if (!phases.previous.buttons.left && phases.current.buttons.left){
        Safe_Pop_Back(player_state.selected_letters);
        Safe_Pop_Back(assets.selections);
    }
❱

◀private: static▶ void ☀Make_Selection(Game_State & state, F310_Gamepad_Phases const& phases, User_State & player_state, User_Assets & assets)❰
    if (!In_Vector(player_state.selected_letters,player_state.current_letter_selection)){
        player_state.selected_letters.emplace_back(player_state.current_letter_selection);
        
        sf::RectangleShape rectangle(sf::Vector2f(80, 5));
        rectangle.setPosition(205 + (100 * player_state.current_letter_selection),assets.selection_y_offset);
        rectangle.setFillColor(player_state.color);
        assets.selections.emplace_back(rectangle);
    }
❱

◀private: static▶ void ☀Player_Match_Check(User_State & user, User_Assets & user_assets, Game_State & state, Assets & assets)❰
    std::string current_word;
    for (auto const& it: user.selected_letters){
        current_word += state.puzzle.letters[it];
    }
    
    auto found_index = Get_Index_Of_Element_If_Exists(state.puzzle.words,current_word);
    if (found_index != -1){
        if (assets.answers[found_index].getFillColor() == state.color){
            Player_Found_Answer(user,user_assets,assets,found_index);
        }
    }
❱

◀private: static▶ void ☀Player_Found_Answer(User_State & user, User_Assets & user_assets, Assets & assets, size_t index)❰

    // set the color
    assets.answers[index].setFillColor(user.color);
    
    //increment the player's score
    user_assets.score.setString(std::to_string(as_signed(user_assets.score.getString()) + 1));
    
    //clear the player's selection
    user.selected_letters.clear();
    user_assets.selections.clear();
    
    Handle_User_Combo_Behaviour(user,user_assets);
    
    
    //say the word (fire and forget style)
    //we take things by copy because the scope is about to end.
    // auto word_to_say = assets.answers[index].getString().toAnsiString();
    // std::thread([=](){ 
    //     Word_Speaker::Speak(word_to_say);
    // }).detach();
❱

◀private: static▶ void ☀Handle_User_Combo_Behaviour(User_State & user, User_Assets & user_assets)❰



    //adjust the user's current combo based on current combo meter
    sf::Time elapsed_time = user.combo_countdown.getElapsedTime();
    long since_last_combo = elapsed_time.asMilliseconds();
    if (since_last_combo <= user.current_combo_timeout_ms){
        ++user.current_combo;
        Adjust_Current_Combo_Timeout_By_Current_Combo(user);
    }
    else{
        user.current_combo = 1;
    }
    user.combo_countdown.restart();
    
    
    //play sound based on current combo
    if (user.current_combo == 1){
        user_assets.success1.sound.play();
        user_assets.combo1.sound.play();
    }
    else if (user.current_combo == 2){
        user_assets.success2.sound.play();
        user_assets.combo2.sound.play();
    }
    else if (user.current_combo == 3){
        user_assets.success3.sound.play();
        user_assets.combo3.sound.play();
    }
    else if (user.current_combo == 4){
        user_assets.success3.sound.play();
        user_assets.combo4.sound.play();
    }
    else if (user.current_combo == 5){
        user_assets.success3.sound.play();
        user_assets.combo5.sound.play();
    }
    else if (user.current_combo == 6){
        user_assets.success3.sound.play();
        user_assets.combo6.sound.play();
    }
    else if (user.current_combo == 7){
        user_assets.success3.sound.play();
        user_assets.combo7.sound.play();
    }
    else if (user.current_combo == 8){
        user_assets.success3.sound.play();
        user_assets.combo8.sound.play();
    }
    else if (user.current_combo == 9){
        user_assets.success3.sound.play();
        user_assets.combo9.sound.play();
    }
    else if (user.current_combo == 10){
        user_assets.success3.sound.play();
        user_assets.combo10.sound.play();
    }
    else if (user.current_combo == 11){
        user_assets.success3.sound.play();
        user_assets.combo11.sound.play();
    }
    else {
        user_assets.success3.sound.play();
        user_assets.combo11.sound.play();
    }
❱

◀private: static▶ void ☀Adjust_Current_Combo_Timeout_By_Current_Combo(User_State & user)❰
    auto added_ms = user.current_combo * 1000;
    user.current_combo_timeout_ms = user.start_combo_timeout_ms + added_ms;
❱

◀private: static▶ void ☀Update_Game_State(Game_State & state, Assets & assets) ❰

    int game_seconds = 180;
    
    //update timer
    sf::Time elapsed_time = state.countdown.getElapsedTime();
    long time_left = game_seconds - elapsed_time.asSeconds();
    assets.countdown.setString(std::to_string(time_left));
    
    //end the game if the time has run out
    if (time_left <= 0){
        assets.countdown.setString("0");
        
        End_Game_Changes(state,assets);
        
        state.phase = Game_Phase::END_GAME;
    }
    
    //update score
    std::string score = std::to_string(state.puzzle.words.size());
    assets.score.setString(+ "=" +score);
    
    //update the combo bars
    Update_Player_Combo_Bar(state.p1_state,assets.p1);
    Update_Player_Combo_Bar(state.p2_state,assets.p2);

❱

◀private: static▶ void ☀Update_Player_Combo_Bar(User_State const& state, User_Assets & asset) ❰

    if (state.current_combo != 0){
        sf::Time elapsed_time = state.combo_countdown.getElapsedTime();
        long since_last_combo = elapsed_time.asMilliseconds();
        auto bar_width = Math::map_value_across_range(since_last_combo,0,state.current_combo_timeout_ms,600,0);
        auto current_size = asset.combo_bar.getSize();
        
        //the bar has run out
        if (current_size.x != 0 && bar_width == 0){
            asset.combo_out.sound.play();
        }
        
        //resize the bar
        current_size.x = bar_width;
        asset.combo_bar.setSize(current_size);
    }
❱

◀private: static▶ void ☀End_Game_Changes(Game_State & state, Assets & assets) ❰

    Show_All_The_Answers(state,assets);
    Show_More_Stats(state,assets);
❱

◀private: static▶ void ☀Show_All_The_Answers(Game_State & state, Assets & assets) ❰
        for (auto & it: assets.answers){
            if (it.getFillColor() == state.color){
                it.setFillColor(sf::Color(189, 170, 176));
            }
            it.move(-600,0);
        }
❱

◀private: static▶ void ☀Show_More_Stats(Game_State & state, Assets & assets) ❰

    //get p1 words
    std::vector<std::string> p1_words;
    for (auto & it: assets.answers){
        if (it.getFillColor() == state.p1_state.color){
            p1_words.emplace_back(it.getString());
        }
    }
    
    //get p2 words
    std::vector<std::string> p2_words;
    for (auto & it: assets.answers){
        if (it.getFillColor() == state.p2_state.color){
            p2_words.emplace_back(it.getString());
        }
    }
    
    //get p1 and p2 frequencies
    auto p1_freq = Size_Frequency_Counter::Get(p1_words);
    auto p2_freq = Size_Frequency_Counter::Get(p2_words);
    
    auto p1_freq_str = To_String(p1_freq);
    auto p2_freq_str = To_String(p2_freq);
    
    p1_freq_str += "= " + assets.p1.score.getString();
    p2_freq_str += "= " + assets.p2.score.getString();
    
    assets.p1.stats.setString(p1_freq_str);
    assets.p2.stats.setString(p2_freq_str);
❱

◀private: static▶ void ☀Game_Over(Game_State & state, Assets & assets) ❰

    //restart the game when user is ready
    if (!state.controller.left.previous.center.start && state.controller.left.current.center.start){
        state.phase = Game_Phase::STARTING_GAME;
    }
    if (!state.controller.right.previous.center.start && state.controller.right.current.center.start){
        state.phase = Game_Phase::STARTING_GAME;
    }
    
    
    //allow the user to move the answers around
    // if (state.controller.right.current.arrows.up){
    //     for (auto & it: assets.answers){
    //         it.move(0,move_speed * -1);
    //     }
    // }
    // if (state.controller.right.current.arrows.down){
    //     for (auto & it: assets.answers){
    //         it.move(0,5);
    //     }
    // }
    
    int move_speed = 8;
    
    if (state.controller.right.current.arrows.left){
        for (auto & it: assets.answers){
            it.move(move_speed * -1,0);
        }
        assets.p1.stats.move(move_speed * -1,0);
        assets.p2.stats.move(move_speed * -1,0);
    }
    if (state.controller.right.current.arrows.right){
        for (auto & it: assets.answers){
            it.move(move_speed,0);
        }
        assets.p1.stats.move(move_speed,0);
        assets.p2.stats.move(move_speed,0);
        
    }
    
    // if (state.controller.left.current.arrows.up){
    //     for (auto & it: assets.answers){
    //         it.move(0,move_speed * -1);
    //     }
    // }
    // if (state.controller.left.current.arrows.down){
    //     for (auto & it: assets.answers){
    //         it.move(0,move_speed);
    //     }
    // }
    if (state.controller.left.current.arrows.left){
        for (auto & it: assets.answers){
            it.move(move_speed * -1,0);
        }
        assets.p1.stats.move(move_speed * -1,0);
        assets.p2.stats.move(move_speed * -1,0);
    }
    if (state.controller.left.current.arrows.right){
        for (auto & it: assets.answers){
            it.move(move_speed,0);
        }
        assets.p1.stats.move(move_speed,0);
        assets.p2.stats.move(move_speed,0);
    }
    
❱











