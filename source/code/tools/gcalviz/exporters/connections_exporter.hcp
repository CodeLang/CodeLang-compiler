class
❪iostream❫
❪string❫
❪set❫
❪"code/tools/gcalviz/exporters/data/node_edge_data"❫
❪"code/tools/gcalviz/exporters/data/edge_data"❫
❪"code/utilities/time/date/rfc333_datetime_to_epoch_converter"❫
❪"code/utilities/time/date/rfc333_datetime_within_range_checker"❫
❪"code/utilities/gcal/data/gcal_sorted_events"❫
❪"code/utilities/data_structures/unique_counter/unique_counter"❫
⚯
❪"code/utilities/types/strings/transformers/search_replace/lib"❫
❪"code/utilities/filesystem/files/creating/lib"❫
❪"code/utilities/json/functions/lib"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/types/strings/observers/comparing/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/tools/gcalviz/exporters/formatters/gexf_formatter"❫
❪"code/tools/gcalviz/exporters/formatters/graphml_formatter"❫
⚞⚟



◀public: static▶ void ☀CreateGraphML(std::string const& sorted_room_events_file, std::string const& sorted_room_event_connections_file) ❰

        //read in data
        Gcal_Sorted_Events pit_rooms;
        std::cout << "loading..." << std::endl;
        Read_Json_From_File(pit_rooms,sorted_room_events_file);
        
        
        Rfc333_Datetime_Range range;
        range.start = "2019-07-1T08:00:00-07:00";
        //range.end = "2019-07-4T08:00:00-07:00";
        range.end = "2019-07-7T08:00:00-07:00";
        
        auto node_edge_data = Extract_Node_Edge_Data(pit_rooms,range);
        auto file_results = Gexf_Formatter::Format(node_edge_data);
        Write_To_File(sorted_room_event_connections_file,file_results);
❱


◀private: static▶ Node_Edge_Data ☀Extract_Node_Edge_Data(Gcal_Sorted_Events const& rooms, Rfc333_Datetime_Range const& range)❰
    Node_Edge_Data result;
    
    for (auto const& y: rooms.events){
        
        std::string event_time = y["originalStartTime"]["dateTime"];
        if (Rfc333_Datetime_Within_Range_Checker::Is_Within(event_time,range)){
            for (size_t i = 0; i < y["attendees"].size(); ++i){
                
                std::string str = y["attendees"][i]["email"];
                if (Valid_Node_Name(str)){
                    result.nodes.insert(str);
                    for (size_t j = i+1; j < y["attendees"].size(); ++j){
                        Add_Edge(result.edges,y["attendees"][i]["email"],y["attendees"][j]["email"]);
                    }
                }
            }
        }
    }
    
    return result;
❱

◀private: static▶ void ☀Add_Edge(Unique_Counter<std::string> & edges, std::string a, std::string b)❰
    
    //make sure we aren't adding rooms and other miscellaneous node data
    //(things that might show up that aren't people)
    if (!Valid_Node_Name(a)){
        return;
    }
    if (!Valid_Node_Name(b)){
        return;
    }
    
    //you can't connect with yourself (in the context of this analysis)
    if (a == b){
        return;
    }
    
    if (Case_Insensitive_String_Compare(a,b)){
        std::swap(a,b);
    }

    std::string file_results = "";
    Edge_Data edge;
    edge.source = a;
    edge.target = b;
    edges.Add(As_Minified_JSON_String(edge));
❱

◀private: static▶ bool ☀Valid_Node_Name(std::string const& name)❰
    if (Begins_With(name,"uber.com_")){
        return false;
    }
    return true;
❱

◀private: static▶ std::string ☀Adjust_Node_Name(std::string str)❰
    return str;
❱