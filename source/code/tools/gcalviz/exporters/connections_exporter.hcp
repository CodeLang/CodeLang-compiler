class
❪iostream❫
❪string❫
❪set❫
❪"code/tools/gcalviz/exporters/node_edge_data"❫
❪"code/utilities/time/date/rfc333_datetime_to_epoch_converter"❫
❪"code/utilities/time/date/rfc333_datetime_within_range_checker"❫
❪"code/utilities/gcal/data/gcal_sorted_events"❫
⚯
❪"code/utilities/types/strings/transformers/search_replace/lib"❫
❪"code/utilities/filesystem/files/creating/lib"❫
❪"code/utilities/json/functions/lib"❫
❪"code/utilities/data_structures/unique_counter/unique_counter"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/types/strings/observers/comparing/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
⚞⚟



◀public: static▶ void ☀CreateGraphML(std::string const& sorted_room_events_file, std::string const& sorted_room_event_connections_file) ❰

        //read in data
        Gcal_Sorted_Events pit_rooms;
        std::cout << "loading..." << std::endl;
        Read_Json_From_File(pit_rooms,sorted_room_events_file);
        
        
        Rfc333_Datetime_Range range;
        range.start = "2019-07-1T08:00:00-07:00";
        //range.end = "2019-07-4T08:00:00-07:00";
        range.end = "2019-07-7T08:00:00-07:00";
        
        auto node_edge_data = Extract_Node_Edge_Data(pit_rooms,range);
        auto file_results = GraphML_Format(node_edge_data);
        Write_To_File(sorted_room_event_connections_file,file_results);
❱

◀public: static▶ std::string ☀GraphML_Format(Node_Edge_Data const& node_edge_data)❰
    std::string file_results = GraphML_Start();
    for (auto const& edge: node_edge_data.edges){
        Append(file_results,edge);
    }
        
    for (auto const& node: node_edge_data.nodes){
        Append(file_results,"<node id=\"");
        Append(file_results,node);
        Append_With_Newline(file_results,"\"/>");
    }
    
    Append(file_results,GraphML_End());
    return file_results;
❱

◀public: static▶ std::string ☀Gexf_Start()❰
        std::string str;
        Append_With_Newline(str,"<gexf xmlns=\"http://www.gexf.net/1.1draft\"");
        Append_With_Newline(str,"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"");
        Append_With_Newline(str,"xsi:schemaLocation=\"http://www.gexf.net/1.1draft");
        Append_With_Newline(str,"http://www.gexf.net/1.1draft/gexf.xsd\"");
        Append_With_Newline(str,"version=\"1.1\">");
        return str;
❱
◀public: static▶ std::string ☀GraphML_Start()❰
        std::string str;
        Append_With_Newline(str,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
        Append_With_Newline(str,"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\""); 
        Append_With_Newline(str,"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"");
        Append_With_Newline(str,"xsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns");
        Append_With_Newline(str,"http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\">");
        Append_With_Newline(str,"<graph id=\"G\" edgedefault=\"undirected\">");
        return str;
❱

◀public: static▶ std::string ☀GraphML_End()❰
    std::string str;
    Append_With_Newline(str,"</graph>");
    Append_With_Newline(str,"</graphml>");
    return str;
❱
◀public: static▶ std::string ☀Gexf_End()❰
    std::string str;
    Append_With_Newline(str,"</graph>");
    Append_With_Newline(str,"</gexf>");
    return str;
❱


◀private: static▶ Node_Edge_Data ☀Extract_Node_Edge_Data(Gcal_Sorted_Events const& rooms, Rfc333_Datetime_Range const& range)❰
    Node_Edge_Data result;
    
    for (auto const& y: rooms.events){
        
        std::string event_time = y["originalStartTime"]["dateTime"];
        if (Rfc333_Datetime_Within_Range_Checker::Is_Within(event_time,range)){
            for (size_t i = 0; i < y["attendees"].size(); ++i){
                
                std::string str = y["attendees"][i]["email"];
                if (Valid_Node_Name(str)){
                    result.nodes.insert(str);
                    for (size_t j = i+1; j < y["attendees"].size(); ++j){
                        Add_Edge(result.edges,y["attendees"][i]["email"],y["attendees"][j]["email"]);
                    }
                }
            }
        }
    }
    
    return result;
❱

◀private: static▶ void ☀Add_Edge(std::set<std::string> & edges, std::string a, std::string b)❰
    
    //make sure we aren't adding rooms and other miscellaneous node data
    //(things that might show up that aren't people)
    if (!Valid_Node_Name(a)){
        return;
    }
    if (!Valid_Node_Name(b)){
        return;
    }
    
    //you can't connect with yourself (in the context of this analysis)
    if (a == b){
        return;
    }
    
    if (Case_Insensitive_String_Compare(a,b)){
        std::swap(a,b);
    }

    std::string file_results = "";
    Append(file_results,"<edge source=\"");
    Append(file_results,a);
    Append(file_results,"\" target=\"");
    Append(file_results,b);
    Append_With_Newline(file_results,"\"/>");
    edges.insert(file_results);
❱

◀private: static▶ bool ☀Valid_Node_Name(std::string const& name)❰
    if (Begins_With(name,"uber.com_")){
        return false;
    }
    return true;
❱

◀private: static▶ std::string ☀Adjust_Node_Name(std::string str)❰
    return str;
❱