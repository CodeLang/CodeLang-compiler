class
❪iostream❫
❪string❫
❪set❫
⚯
❪"code/utilities/gcal/data/gcal_sorted_events"❫
❪"code/utilities/types/strings/transformers/search_replace/lib"❫
❪"code/utilities/filesystem/files/creating/lib"❫
❪"code/utilities/json/functions/lib"❫
❪"code/utilities/time/date/rfc333_datetime_to_epoch_converter"❫
❪"code/utilities/time/date/rfc333_datetime_within_range_checker"❫
❪"code/utilities/data_structures/unique_counter/unique_counter"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/types/strings/observers/comparing/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
⚞⚟



◀public: static▶ void ☀CreateGraphML(std::string const& sorted_room_events_file, std::string const& sorted_room_event_connections_file) ❰

        //read in data
        Gcal_Sorted_Events pit_rooms;
        std::cout << "loading..." << std::endl;
        Read_Json_From_File(pit_rooms,sorted_room_events_file);
        
        //std::ofstream outfile(sorted_room_event_connections_file);
        std::string file_results;
        Append_With_Newline(file_results,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
        Append_With_Newline(file_results,"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\""); 
        Append_With_Newline(file_results,"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"");
        Append_With_Newline(file_results,"xsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns");
        Append_With_Newline(file_results,"http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\">");
        Append_With_Newline(file_results,"<graph id=\"G\" edgedefault=\"undirected\">");
        
        Rfc333_Datetime_Range range;
        range.start = "2019-07-1T08:00:00-07:00";
        range.end = "2019-07-4T08:00:00-07:00";
        //range.end = "2019-08-1T08:00:00-07:00";
        
        std::set<std::string> nodes;
        std::set<std::string> edges;
        for (auto const& y: pit_rooms.events){
            
            std::string event_time = y["originalStartTime"]["dateTime"];
            if (Rfc333_Datetime_Within_Range_Checker::Is_Within(event_time,range)){
                for (size_t i = 0; i < y["attendees"].size(); ++i){
                    
                    std::string str = y["attendees"][i]["email"];
                    if (Valid_Node_Name(str)){
                        nodes.insert(str);
                        for (size_t j = i+1; j < y["attendees"].size(); ++j){
                            Add_Edge(edges,y["attendees"][i]["email"],y["attendees"][j]["email"]);
                        }
                    }
                }
            }
        }
        
        for (auto const& edge: edges){
            Append(file_results,edge);
        }
        
        for (auto const& node: nodes){
            Append(file_results,"<node id=\"");
            Append(file_results,node);
            Append_With_Newline(file_results,"\"/>");
        }
        
        Append_With_Newline(file_results,"</graph>");
        Append_With_Newline(file_results,"</graphml>");
        
        Write_To_File(sorted_room_event_connections_file,file_results);
❱

◀private: static▶ void ☀Add_Edge(std::set<std::string> & edges, std::string a, std::string b)❰
    
    //make sure we aren't adding rooms and other miscellaneous node data
    //(things that might show up that aren't people)
    if (!Valid_Node_Name(a)){
        return;
    }
    if (!Valid_Node_Name(b)){
        return;
    }
    
    if (Case_Insensitive_String_Compare(a,b)){
        std::swap(a,b);
    }

    std::string file_results = "";
    Append(file_results,"<edge source=\"");
    Append(file_results,a);
    Append(file_results,"\" target=\"");
    Append(file_results,b);
    Append_With_Newline(file_results,"\"/>");
    edges.insert(file_results);
❱

◀private: static▶ bool ☀Valid_Node_Name(std::string const& name)❰
    if (Begins_With(name,"uber.com_")){
        return false;
    }
    return true;
❱

◀private: static▶ std::string ☀Adjust_Node_Name(std::string str)❰
    return str;
❱