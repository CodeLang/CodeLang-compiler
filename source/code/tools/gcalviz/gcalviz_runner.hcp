class
❪"code/tools/gcalviz/meta_settings"❫
❪iostream❫
❪set❫
⚯
❪"code/utilities/gcal/gcal_getter"❫
❪"code/utilities/gcal/gcal_credentials"❫
❪"code/utilities/gcal/data/gcal_sorted_events"❫
❪"code/tools/gcalviz/settings/default_settings_getter"❫
❪"code/utilities/types/strings/transformers/search_replace/lib"❫
❪"code/utilities/filesystem/files/creating/lib"❫
❪"code/utilities/json/functions/lib"❫
❪"code/utilities/time/date/rfc333_datetime_to_epoch_converter"❫
❪"code/utilities/time/date/rfc333_datetime_within_range_checker"❫
❪"code/utilities/data_structures/unique_counter/unique_counter"❫
❪"code/utilities/filesystem/files/creating/lib"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/types/strings/observers/comparing/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/json/attribute_check/json_attribute_check_settings"❫
❪"code/utilities/json/attribute_check/json_attribute_checker"❫
⚞⚟

◀public: static▶ void ☀Run(Meta_Settings const& meta) ❰
    
    //load in all of the settings
    auto settings = Default_Settings_Getter::Get();
    
    //std::cout << Rfc333_Datetime_To_Epoch_Converter::Convert("2016-03-29T08:00:00-07:00") << std::endl;
    //std::cout << Rfc333_Datetime_To_Epoch_Converter::Convert("2016-05-17T08:00:00-07:00") << std::endl;
    //exit(0);
    
    
    //"2019-07-1T08:00:00-07:00"
    //"2019-08-1T08:00:00-07:00"
    
    
    //scrape all the meetings
    if (settings.exports.pit_rooms.do_export){
        auto pit_rooms = Gcal_Getter::Get_All_Pittsburgh_Room_Events(settings.credentials);
        Write_Json_To_File(pit_rooms,settings.exports.pit_rooms.path);
    }
    
    if (settings.exports.pit_events.do_export){
        Filter_Sort_By_Original_Start_Time(settings.exports.pit_rooms.path,settings.exports.pit_events.path);
    }
    
    if (settings.exports.pit_connections.do_export){
        CreateGraphGML(settings.exports.pit_events.path,settings.exports.pit_connections.path);
    }
    
    //Collect_Status_Metrics(all_pit_room_events_file);
    //Collect_Atendee_Metrics(all_pit_room_events_file);
    
    /*
    size_t total_events = 0;
    for (auto const& it: pit_rooms.rooms){
        total_events += it.events.size();
    }
    std::cout << "total events: " << total_events << std::endl;
    */
    
    /*
    for (auto const& it: pit_rooms){
        auto events = Gcal_Getter::Get_All_Events_Of_Calendar(settings.credentials, it["id"]);
        std::string file_name = "/home/thickey/Desktop/events/";
        std::string summary = it["summary"];
        replace_spaces_with_underscore(summary);
        file_name += summary;
        
        std::cout << "writing " << file_name << std::endl;
        //Write_To_File(file_name,events);
        Write_Json_To_File(events,file_name);
    }
    */
    
    //auto sfo_rooms = Gcal_Getter::Get_San_Francisco_Rooms(creds);
    //std::cout << sfo_rooms.size() << std::endl;
    
    //https://gephi.org/
    //socnetv
    
    
    //Calculating The Betweenness Centrality In Gephi
    //tells us the importance of an individual as an inter-mediator
    //https://www.youtube.com/watch?v=PuWNYB0u_gM
    
    //Identifying Influencers Using Pagerank Analysis.
    //https://www.youtube.com/watch?v=OzyPZwSisZ0
    
    //centrality - a general term for how close a node is relative to the network as a whole
    //degree = the number of links connected to a node (two types of directed networks)
    //closeness = average length of the shortest path between the node and al    
    
    //centrality - a general term for how close a nl other nodes in the graph
    //betweenness = based on the number of times a node is crossed by each of the least cost paths (shortest route between nodes)
    
    //clustering
    //clustering coefficient = compares the number of connections to other nodes
    //compared to the potential number of connections to the other nodes in the group
    //a clustering coefficient of 1 indicates a clique; a set where each node is connected all others in the set
    
    
❱
◀public: static▶ void ☀Filter_Sort_By_Original_Start_Time(std::string const& all_pit_room_events_file, std::string const& sorted_room_events_file) ❰

        //read in all the room data
        Gcal_Rooms pit_rooms;
        std::cout << "loading..." << std::endl;
        Read_Json_From_File(pit_rooms,all_pit_room_events_file);
        
        
        //filter out anything that doesn't have these attributes
        Json_Attribute_Check_Settings check_settings;
        check_settings.attributes = {
            {"originalStartTime","dateTime"},
            {"attendees"}
        };
        
        //flatten away the rooms and only keep events that have certain attributes
        std::cout << "flattening..." << std::endl;
        Gcal_Sorted_Events sorted;
        for (auto const& x: pit_rooms.rooms){
            for (auto const& y: x.events){
                if (Json_Attribute_Checker::Has_Attributes(y,check_settings)){
                    sorted.events.emplace_back(y);
                }
            }
        }
        
        //sort them chronologically
        std::cout << "sorting..." << std::endl;
        std::sort(sorted.events.begin(),sorted.events.end(),[](nlohmann::json const& a, nlohmann::json const& b){
            
            auto result = Rfc333_Datetime_To_Epoch_Converter::Convert(a["originalStartTime"]["dateTime"])
            < Rfc333_Datetime_To_Epoch_Converter::Convert(b["originalStartTime"]["dateTime"]);
            
            return result;
        });
        
        //write the events back
        std::cout << "writing..." << std::endl;
        Write_Json_To_File(sorted,sorted_room_events_file);
❱

◀public: static▶ void ☀Collect_Status_Metrics(std::string const& all_pit_room_events_file) ❰

        //read in data
        Gcal_Rooms pit_rooms;
        std::cout << "loading..." << std::endl;
        Read_Json_From_File(pit_rooms,all_pit_room_events_file);
        
        //flatten it
        Unique_Counter<std::string> counter;
        std::cout << "collecting..." << std::endl;
        for (auto const& x: pit_rooms.rooms){
            for (auto const& y: x.events){
                if (y.find("status") != y.end()){
                    counter.Add(y["status"]);
                }
            }
        }
        
        for (auto const& it: counter.hash_table){
            std::cout << it.second << " " << it.first << std::endl;
        }
❱
◀public: static▶ void ☀Collect_Atendee_Metrics(std::string const& all_pit_room_events_file) ❰

        //read in data
        Gcal_Rooms pit_rooms;
        std::cout << "loading..." << std::endl;
        Read_Json_From_File(pit_rooms,all_pit_room_events_file);
        
        //flatten it
        Unique_Counter<std::string> counter;
        std::cout << "collecting..." << std::endl;
        for (auto const& x: pit_rooms.rooms){
            for (auto const& y: x.events){
                    counter.Add("total");
                    counter.Add(std::to_string(y["attendees"].size()));
            }
        }
        
        for (auto const& it: counter.hash_table){
            std::cout << it.second << " " << it.first << std::endl;
        }
❱

◀public: static▶ void ☀CreateGraphGML(std::string const& sorted_room_events_file, std::string const& sorted_room_event_connections_file) ❰

        //read in data
        Gcal_Sorted_Events pit_rooms;
        std::cout << "loading..." << std::endl;
        Read_Json_From_File(pit_rooms,sorted_room_events_file);
        
        //std::ofstream outfile(sorted_room_event_connections_file);
        std::string file_results;
        Append_With_Newline(file_results,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
        Append_With_Newline(file_results,"<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\""); 
        Append_With_Newline(file_results,"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"");
        Append_With_Newline(file_results,"xsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns");
        Append_With_Newline(file_results,"http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\">");
        Append_With_Newline(file_results,"<graph id=\"G\" edgedefault=\"undirected\">");
        
        Rfc333_Datetime_Range range;
        range.start = "2019-07-1T08:00:00-07:00";
        range.end = "2019-07-4T08:00:00-07:00";
        //range.end = "2019-08-1T08:00:00-07:00";
        
        std::set<std::string> nodes;
        std::set<std::string> edges;
        for (auto const& y: pit_rooms.events){
            
            std::string event_time = y["originalStartTime"]["dateTime"];
            if (Rfc333_Datetime_Within_Range_Checker::Is_Within(event_time,range)){
                for (size_t i = 0; i < y["attendees"].size(); ++i){
                    std::string str = y["attendees"][i]["email"];
                    nodes.insert(str);
                    for (size_t j = i+1; j < y["attendees"].size(); ++j){
                        Add_Edge(edges,y["attendees"][i]["email"],y["attendees"][j]["email"]);
                    }
                }
            }
        }
        
        for (auto const& edge: edges){
            Append(file_results,edge);
        }
        
        for (auto const& node: nodes){
            Append(file_results,"<node id=\"");
            Append(file_results,node);
            Append_With_Newline(file_results,"\"/>");
        }
        
        Append_With_Newline(file_results,"</graph>");
        Append_With_Newline(file_results,"</graphml>");
        
        Write_To_File(sorted_room_event_connections_file,file_results);
❱

◀public: static▶ void ☀Add_Edge(std::set<std::string> & edges, std::string a, std::string b)❰
    
    //make sure we aren't adding rooms and other miscellaneous node data
    //(things that might show up that aren't people)
    if (!Valid_Node_Name(a)){
        return;
    }
    if (!Valid_Node_Name(b)){
        return;
    }
    
    if (Case_Insensitive_String_Compare(a,b)){
        std::swap(a,b);
    }

    std::string file_results = "";
    Append(file_results,"<edge source=\"");
    Append(file_results,a);
    Append(file_results,"\" target=\"");
    Append(file_results,b);
    Append_With_Newline(file_results,"\"/>");
    edges.insert(file_results);
❱

◀private: static▶ bool ☀Valid_Node_Name(std::string const& name)❰
    if (Begins_With(name,"uber.com_")){
        return false;
    }
    return true;
❱

◀private: static▶ std::string ☀Adjust_Node_Name(std::string str)❰
    return str;
❱
