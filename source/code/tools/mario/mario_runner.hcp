class
❪"code/utilities/x11/events/global_event_listener"❫
⚯
❪"code/utilities/sound/music_player"❫
❪iostream❫
❪string❫
❪cstdlib❫
❪unistd.h❫
❪X11/Xlib.h❫
❪X11/Xutil.h❫
❪X11/xpm.h❫
❪X11/extensions/shape.h❫
❪sys/time.h❫
❪signal.h❫
❪"code/utilities/x11/main_state/x11_main_state_creator"❫
❪"code/utilities/x11/loop/x11_looper"❫
❪"code/utilities/x11/sprite/sprite_loader"❫
❪"code/utilities/x11/sprite/sprite_window_creator"❫
❪"code/utilities/x11/sprite/sprite_window_drawer"❫
❪"code/tools/mario/sprites/sprites_loader"❫
❪"code/utilities/types/booleans/lib"❫
⚞⚟

◀public: static▶ void ☀Run() ❰

    //auto m = Music_Player::Play("/home/laptop/Desktop/main.mp3");
    
    //create the main display (connect to the X Server). Basically just get everything setup to use X11.
    //hoping this is all typical x11 boilerplate.
    //I'm not sure I did it all correctly, but wanted to abstract it away.
    //hopefully customizable enough for most use cases and I don't have to dig into this much.
    Setup_Display_Settings settings;
    settings.syncronize_debug_mode = false;
    settings.set_error_handler = false;
    settings.check_for_shape_extension = true;
    auto state = X11_Main_State_Creator::Create(settings);
    
    //load all the sprites
    auto sprites = Sprites_Loader::Load(state);
    
    Global_Event_Listener::Enable_Events(state);
    
    auto mario = Sprite_Window_Creator::Create(state,sprites.mario_stand);
    
    
    //X11 is notorious for image tearing i guess
    //originally, I had one giant window, and I used PutImage each cycle to put the sprite in a different place.
    //this flickered and looked bad.  So Now I make little windows for each sprite, and place the sprite in the window at 0,0 always.
    //instead of moving the images each cycle, we move the entire window instead.  This looks clean but feels wrong.
    //I'm not sure if there are any ramifications to doing this.
    //It basically means that my mario game will have an X11 window for every sprite being shown.
    //unless i totally missed something in terms of writing images and moving them around in x11, this is the best I can do.
    //And based on the various complaints I've heard about X this may actually be a correct way to go about this.
    //fwiw, I see everyone on the internet talking about how X11 tears because its old, and its one of the reasons for wayland.
    //so I don't know. This model can be revised later.
    
    
    bool right_button = false;
    bool left_button = false;
    mario.x = 100;
    mario.y = 200;
    X11_Looper::typical_x11_game_loop(state,[&](){
        
    Sprite_Window_Drawer::Draw(state,mario);
    
    
    auto cookie = Global_Event_Listener::Get_Cookie(state);
     if (cookie){
        //std::cout << "handling" << std::endl;
        Handle_Events(cookie,right_button,left_button);
        XFreeEventData(state.d, cookie);
     }
     else{
        //std::cout << "skipped" << std::endl;
     }
     //XFreeEventData(state.d, cookie);
     
     if (right_button){
        mario.x += 1;
     }
     if (left_button){
        mario.x -= 1;
     }
      
    });
❱

◀private: static▶ void ☀Handle_Events(XGenericEventCookie* cookie, bool &right_button, bool &left_button) ❰

    //printf("EVENT type %d \n", cookie->evtype);
            switch (cookie->evtype)
            {
                case XI_DeviceChanged:
                std::cout << "qqqq" << std::endl;
                    //print_devicechangedevent(display, cookie->data);
                    break;
                case XI_HierarchyChanged:
                std::cout << "qqqq2" << std::endl;
                    //print_hierarchychangedevent(cookie->data);
                    break;
                case XI_RawKeyPress:
                case XI_RawKeyRelease:
                case XI_RawButtonPress:
                case XI_RawButtonRelease:
                case XI_RawMotion:
                case XI_RawTouchBegin:
                case XI_RawTouchUpdate:
                case XI_RawTouchEnd:
                    //std::cout << cookie->evtype << std::endl;
                    //Handle_Raw_Event(static_cast<XIRawEvent *>(cookie->data),cookie->evtype,right_button,left_button);
                break;
                case XI_Enter:
                case XI_Leave:
                case XI_FocusIn:
                case XI_FocusOut:
                std::cout << "qqqq4" << std::endl;
                    //print_enterleave(cookie->data);
                    break;
                case XI_PropertyEvent:
                     std::cout << "pp" << std::endl;
                    //print_propertyevent(display, cookie->data);
                    break;
                default:
                //std::cout << "OOO" << std::endl;
                    Handle_Raw_Event(static_cast<XIRawEvent *>(cookie->data),cookie->evtype,right_button,left_button);
                break;
            }
❱


◀private: static▶ void ☀Handle_Raw_Event(XIRawEvent *event, int const& evtype, bool &right_button, bool &left_button)❰


    if (event->detail == 114){
        if (evtype == 2){
            //std::cout << "right down" << std::endl;
            Make_True(right_button);
        }
        else{
            //std::cout << "right dup" << std::endl;
            Make_False(right_button);
        }
    }
    else if (event->detail == 113){
        if (evtype == 2){
            //std::cout << "left down" << std::endl;
            Make_True(left_button);
        }
        else{
            //std::cout << "left dup" << std::endl;
            Make_False(left_button);
        }
    }
    //std::cout << "sss" << std::endl;
    return ;
    
    
    /*
    if (event->detail == 114){
        std::cout << event->evtype << std::endl;
        switch(event->evtype) {
            case XI_RawButtonPress:
            case XI_RawButtonRelease:
            case XI_RawMotion:
            default:
            if (evtype == 2){
                //std::cout << "down" << std::endl;
                Make_True(right_button);
                return;
            }
            Make_False(right_button);
            //std::cout << "up" << std::endl;
            return;
        }
    }
    else{
        //Make_False(right_button);
    }
    
    if (event->detail == 113){
        std::cout << event->evtype << std::endl;
        switch(event->evtype) {
            case XI_RawButtonPress:
            case XI_RawButtonRelease:
            case XI_RawMotion:
            default:
            if (evtype == 2){
                //std::cout << "down" << std::endl;
                Make_True(left_button);
                return;
            }
            Make_False(left_button);
            //std::cout << "up" << std::endl;
            return;
        }
    }
    else{
        //Make_False(left_button);
    }
    */
❱

