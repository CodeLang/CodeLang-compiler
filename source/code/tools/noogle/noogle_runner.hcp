class
❪"code/tools/noogle/meta_settings"❫
❪"code/utilities/web/automate/browser/browser_settings"❫
❪"code/tools/noogle/settings/noogle_settings"❫
❪"code/utilities/data_structures/queue/safe_queue.h"❫
❪"code/utilities/data_structures/queue/finishable_safe_queue.h"❫
❪"code/tools/noogle/noogle_running_stats"❫
❪"code/tools/noogle/noogle_result"❫
❪atomic❫
❪unordered_set❫
❪"code/tools/noogle/program_options/program_options"❫
⚯
❪iostream❫
❪thread❫
❪"code/utilities/web/chrome/driver/chrome_driver_selector"❫
❪pybind11/embed.h❫
❪"code/utilities/web/automate/browser/browser_creator"❫
❪"code/utilities/web/automate/navigation/browser_navigator"❫
❪"code/tools/noogle/default_settings_getter"❫
❪"code/utilities/types/strings/transformers/search_replace/lib"❫
❪"code/utilities/types/strings/transformers/squeeze/lib"❫
❪"code/utilities/time/sleeping/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/web/google/google_search_url_deviser"❫
❪"code/utilities/web/google/google_json_url_deviser"❫
❪"code/utilities/web/bing/bing_json_url_deviser"❫
❪"code/utilities/web/lib"❫
❪"code/utilities/exits/lib"❫
❪boost/asio/thread_pool.hpp❫
❪boost/asio/post.hpp❫
❪"code/utilities/printers/lib"❫
❪"code/utilities/types/strings/observers/splitting/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/types/strings/observers/characteristic/spirit_numeric_checker"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/types/strings/observers/char/lib"❫
❪"code/utilities/types/vectors/transformers/lib"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/types/strings/transformers/casing/lib"❫
❪"code/utilities/chart/ascii/chart_getter"❫
❪"url.hpp"❫
❪"code/utilities/types/sets/lib"❫
❪"code/utilities/types/strings/observers/characteristic/english_number_to_integral_converter"❫
❪"code/utilities/types/strings/observers/characteristic/is_english_number_checker"❫
❪"code/tools/noogle/results_shower"❫
❪"code/utilities/filesystem/files/creating/lib"❫
❪"code/utilities/types/strings/transformers/html/html_raw_text_getter"❫
⚞⚟

//apt-get install python3-bs4

//can you noogle a googol?
//should return a very large number (mpz support)


//most data is time (points & durations)
//points = dates (June 2019)
//durations =  (3 years)

◀public: static▶ void ☀Run(Meta_Settings const& meta, Program_Options const& options) ❰


    //when the python scoped interpreter exists, I can't ctrl+c the program
    //we'll remedy that with a custom signal handler.
    //find out why this is, maybe we can do something better.
    //https://github.com/pybind/pybind11/issues/1813
    signal(SIGINT,[](int signum){
        exit(signum);
    });
    
    //make sure we have a python environment going for the duration of the program (RAII)
    pybind11::scoped_interpreter guard{};
    
    //add python implementations
    Html_Raw_Text_Getter::add_beautiful_soup_function();
    
    //create a browser to automate queries on
    //Browser_Creator::Create(settings.browser);
    
    //catch crashes
    // signal(SIGSEGV,[](int signum){
    //     ::signal(signum, SIG_DFL);
    //     boost::stacktrace::safe_dump_to("./backtrace.dump");
    //     ::raise(SIGABRT);
    // });
    // signal(SIGABRT,[](int signum){
    //     ::signal(signum, SIG_DFL);
    //     boost::stacktrace::safe_dump_to("./backtrace.dump");
    //     ::raise(SIGABRT);
    // });


    //settings
    auto settings = Default_Settings_Getter::Get();
    Noogle_Running_Stats stats;
    stats.sites.name = "sites";
    stats.htmls.name = "htmls";
    stats.sanitized.name = "sanitized";
    
    //expand the user's query to many enriched queries to help increase our search
    auto queries = expand_query(settings.query_expand,options.Query());
    
    
    
    
    //auto google_search_urls = Google_Search_Url_Deviser::Devise(settings.devise_google_search_urls,options.Query());
    //auto google_query_urls = Google_Json_Url_Deviser::Devise(settings.devise_google_query_urls,options.Query());
    
    std::vector<std::string> bing_urls;
    for (auto const& query: queries){
        bing_urls += Bing_Json_Url_Deviser::Devise(settings.devise_bing_query_urls,query);
    }
    
    
    
    //for (auto const& it: bing_urls){
    //    std::cout << it << std::endl;
    //}
    //exit(0);
    
    //all of the shared queues involved in the pipeline of converting
    //queries into noogle results
    FinishableSafeQueue<std::string> result_urls;
    FinishableSafeQueue<std::string> html_results;
    FinishableSafeQueue<std::string> sanitized_text;
    FinishableSafeQueue<Noogle_Result> noogle_results;
    
    // construct and run the jobs communicating over shared queues
    std::vector<std::thread> jobs;
    jobs.emplace_back(Results_Shower::Show_Results,std::cref(stats),std::ref(noogle_results));
    //jobs.emplace_back(Google_Search_Urls_To_Google_Result_Urls,settings.browser,std::ref(stats),google_search_urls,std::ref(result_urls));
    //jobs.emplace_back(Google_Query_Urls_To_Google_Result_Urls,settings.browser,std::ref(stats),google_query_urls,std::ref(result_urls));
    jobs.emplace_back(Bing_Query_Urls_To_Result_Urls,std::ref(stats),bing_urls,std::ref(result_urls));
    jobs.emplace_back(Convert_Result_Urls_To_Html,settings.browser,std::ref(stats),std::ref(result_urls),std::ref(html_results));
    jobs.emplace_back(Sanitize_Html,std::ref(stats),std::ref(html_results),std::ref(sanitized_text));
    jobs.emplace_back(Parse_For_Noogle_Results,std::ref(settings),std::ref(stats),std::ref(sanitized_text),std::ref(noogle_results));
    for (auto & it: jobs){
        it.join();
    }
    
❱

◀private: static▶ std::vector<std::string> ☀expand_query(Query_Expand_Settings const& settings, std::string const& query)❰
    std::vector<std::string> queries;
    
    //default user given
    if (settings.use_given_search_query){
        queries.emplace_back(query);
    }
    
    //user given with some extra search terms added
    if (settings.add_extra_search_terms){
        for (auto const& it: settings.extra_search_terms){
            queries.emplace_back(query + " " + it);
        }
    }
    
    
    return queries;
❱


//STEP 1 (A)
◀private: static▶ void ☀Google_Search_Urls_To_Google_Result_Urls(Browser_Settings const& settings, Noogle_Running_Stats & stats, std::vector<std::string> const& google_search_urls, FinishableSafeQueue<std::string> & q)❰

    std::unordered_set<std::string> seen_hosts;
    
    for (auto const& search_url: google_search_urls){
        auto result_urls = Browser_Navigator::Get_Google_Result_Urls(settings,search_url);
        for (auto const& result_url: result_urls){
            if (Google_Result_Url_Is_Valid_For_Exploring(result_url,seen_hosts)){
                ++stats.sites.total;
                q.add(result_url);
                ++stats.sites.current;
            }
        }
    }
    q.mark_finished();
    stats.sites.finished = true;
❱

◀private: static▶ bool ☀Google_Result_Url_Is_Valid_For_Exploring(std::string const& url,std::unordered_set<std::string> & seen_hosts)❰
   
   try {
       std::string new_host_name = url_as_hostname(url);
       
        if (Begins_With(url,"https://www.google.com/search?")){
            return false;
        }
        
        if (Begins_With(url,"mailto:")){
            return false;
        }
        
        if (seen_hosts.find(new_host_name) != seen_hosts.end()){
            //std::cout << "dropping " << new_host_name << std::endl;
            return false;
        }
        
        //std::cout << new_host_name << std::endl;
        seen_hosts.insert(new_host_name);
    }
    catch(...){
    }
    return true;
❱

◀private: static▶ std::string ☀url_as_hostname(std::string const& url)❰
       Url parsed_url(url);
       auto host_name = parsed_url.host();
       auto parts = Split_Into_Parts_From_Dot(host_name);
       while (parts.size() > 2){
            Remove_First_Element(parts);
       }
       std::string new_host_name = "";
       if (!parts.empty()){
            new_host_name = parts[0];
       }
       return new_host_name;
❱


//STEP 1 (B)
◀private: static▶ void ☀Google_Query_Urls_To_Google_Result_Urls(Browser_Settings const& settings, Noogle_Running_Stats & stats, std::vector<std::string> const& google_query_urls, FinishableSafeQueue<std::string> & q)❰
    
    std::unordered_set<std::string> seen_hosts;
    for (auto const& search_url: google_query_urls){
        
        //query json endpoint
        Html_Fetch_Settings fetch_settings;
        fetch_settings.url = search_url;
        auto response = Get_Html_Of_Site(fetch_settings);
        
        auto j = nlohmann::json::parse(response);
        for (auto it: j["items"]){
            auto result_url = it["link"].get<std::string>();
            if (Google_Result_Url_Is_Valid_For_Exploring(result_url,seen_hosts)){
                ++stats.sites.total;
                q.add(result_url);
                ++stats.sites.current;
            }
        }
    }
    q.mark_finished();
    stats.sites.finished = true;
❱

//STEP 1 (C)
◀private: static▶ void ☀Bing_Query_Urls_To_Result_Urls(Noogle_Running_Stats & stats, std::vector<std::string> const& urls, FinishableSafeQueue<std::string> & q)❰
    std::unordered_set<std::string> seen_hosts;
    for (auto const& search_url: urls){
        
        //query json endpoint
        Html_Fetch_Settings fetch_settings;
        fetch_settings.url = search_url;
        fetch_settings.headers.emplace_back("Ocp-Apim-Subscription-Key: 20bb843162f847609f93b7f509ba7645"); 
        auto response = Get_Html_Of_Site(fetch_settings);
        
        auto j = nlohmann::json::parse(response);
        for (auto it: j["webPages"]["value"]){
            auto result_url = it["url"].get<std::string>();
            if (Google_Result_Url_Is_Valid_For_Exploring(result_url,seen_hosts)){
                ++stats.sites.total;
                q.add(result_url);
                ++stats.sites.current;
            }
        }
    }
    q.mark_finished();
    stats.sites.finished = true;
❱

//STEP 2
◀private: static▶ void ☀Convert_Result_Urls_To_Html(Browser_Settings const& settings, Noogle_Running_Stats & stats, FinishableSafeQueue<std::string> & urls_in, FinishableSafeQueue<std::string> & html_out)❰
    
    
    std::unordered_set<std::string> duplicate_htmls;
    bool write_html_files = false;
    std::string dump_html_location = "/home/laptop/Desktop/html_dump/";
    
    
    //int threadNumbers = std::thread::hardware_concurrency();
    int threadNumbers = 10;
    boost::asio::thread_pool pool(threadNumbers);
    while(!urls_in.is_finished() || !urls_in.is_empty()){
        
        if (!urls_in.is_empty()){
            auto str = urls_in.get();
            ++stats.htmls.total;
            boost::asio::post(pool, [&,str]() {
                Html_Fetch_Settings fetch_settings;
                fetch_settings.url = str;
                auto html = Get_Html_Of_Site(fetch_settings);
                
                if (duplicate_htmls.find(html) == duplicate_htmls.end()){
                    html_out.add(html);
                    duplicate_htmls.insert(html);
                    
                   if (write_html_files){
                        Write_To_File(dump_html_location + url_as_hostname(fetch_settings.url),html);
                    }
                }
                ++stats.htmls.current;
                
                if (html.empty()){
                    //std::cout << fetch_settings.url << std::endl;
                }
            });
        }
    }
    pool.join();
    html_out.mark_finished();
    stats.htmls.finished = true;
❱

//STEP 3
◀private: static▶ void ☀Sanitize_Html(Noogle_Running_Stats & stats, FinishableSafeQueue<std::string> & html_results, FinishableSafeQueue<std::string> & sanitized_text)❰

    int i = 0;
    bool write_html_files = true;
    std::string dump_html_location = "/home/laptop/Desktop/html_dump/";
    
    while(!html_results.is_finished() || !html_results.is_empty()){
        auto str = html_results.get();
            ++stats.sanitized.total;
            sanitized_text.add(parse_out_text_from_html(str));
            ++stats.sanitized.current;
            
           if (write_html_files){
                Write_To_File(dump_html_location + std::to_string(i),parse_out_text_from_html(str));
                ++i;
            }
            
            
    }
    sanitized_text.mark_finished();
    stats.sanitized.finished = true;
❱

◀private: static▶ std::string ☀parse_out_text_from_html(std::string str)❰
    try{
        auto result = Html_Raw_Text_Getter::parse_away_html_tags(str);
        return result;
    }
    catch(...){
        //sanitized_text.add(str);
    }
    return "empty";
❱


//STEP 4
◀private: static▶ void ☀Parse_For_Noogle_Results(Noogle_Settings const& settings, Noogle_Running_Stats & stats, FinishableSafeQueue<std::string> & sanitized_text, FinishableSafeQueue<Noogle_Result> & noogle_results)❰
    while(!sanitized_text.is_finished() || !sanitized_text.is_empty()){
        
        auto blob = sanitized_text.get();
        Parse_Html_Blob(blob,stats,noogle_results,settings);
    }
    
    noogle_results.mark_finished();
❱

◀private: static▶ void ☀Parse_Html_Blob(std::string const& blob, Noogle_Running_Stats & stats, FinishableSafeQueue<Noogle_Result> & noogle_results, Noogle_Settings const& settings)❰



    std::unordered_set<std::string> local_site_results;
    auto tokens = Default_Boost_Tokenize(blob);
    for (size_t i = 0; i < tokens.size(); ++i){
        Decide_If_Token_Is_A_Result(stats,tokens[i],tokens,i,local_site_results,settings);
    }
    
    //add local site results to global
    for (auto const& it: local_site_results){
        Noogle_Result result;
        result.number = it;
        noogle_results.add(result);
        stats.currated_results.Add(result.number);
        ++stats.results;
        
    }
❱



◀private: static▶ void ☀Decide_If_Token_Is_A_Result(Noogle_Running_Stats & stats, std::string const& token, std::vector<std::string> const& tokens, size_t index,  std::unordered_set<std::string> & local_site_results, Noogle_Settings const& settings)❰

    
    if (Spirit_Numeric_Checker::Is_Numeric(token) || Is_English_Number_Checker::Check(token)){
        
        auto as_number = English_Number_To_Integral_Converter::Convert(token);
        
        Add_Left_Window(stats,as_number,tokens,index,local_site_results,settings);
        Add_Right_Window(stats,as_number,tokens,index,local_site_results,settings);
    }
❱

◀private: static▶ void ☀Add_Left_Window(Noogle_Running_Stats & stats, std::string const& token, std::vector<std::string> const& tokens, size_t index, std::unordered_set<std::string> & local_site_results, Noogle_Settings const& settings)❰
    if (index != 0){
        auto window_word = tokens[index-1];
        if (Word_Passes_Filter(settings.word_filter,window_word)){
            local_site_results.insert(window_word + " " + token);
        }
    }
❱
◀private: static▶ void ☀Add_Right_Window(Noogle_Running_Stats & stats, std::string const& token, std::vector<std::string> const& tokens, size_t index, std::unordered_set<std::string> & local_site_results, Noogle_Settings const& settings)❰
    if (index+1 < tokens.size()){
        auto window_word = tokens[index+1];
        if (Word_Passes_Filter(settings.word_filter,window_word)){
            local_site_results.insert(token + " " + window_word);
        }
    }
❱
◀private: static▶ void ☀Add_Exact(Noogle_Running_Stats & stats, std::string const& token, std::vector<std::string> const& tokens, size_t index, std::unordered_set<std::string> & local_site_results)❰
    local_site_results.insert(token);
❱

◀private: static▶ bool ☀Word_Passes_Filter(Word_Filter_Settings const& settings, std::string const& word)❰
    

    if (settings.use_spirit_numerical){
        if (Spirit_Numeric_Checker::Is_Numeric(word)){
            return false;
        }
    }
    
    if (settings.use_blacklisted){
        if (Word_Is_Blacklisted(word,settings.blacklisted_words)){
            return false;
        }
    }
    
    if (settings.use_has_numeric){
        if (Has_A_Numeric_Character(word)){
            return false;
        }
    }
    
    return true;
❱



◀private: static▶ bool ☀Word_Is_Blacklisted(std::string const& word, std::vector<std::string> const& blist)❰
    return String_In_Vector(blist,As_Lowercase(word));
❱

◀private: static▶ std::vector<std::string> ☀Get_Blacklisted_Words()❰
    std::vector<std::string> words;
    words += Get_Webish_Words();
    words += Get_Boring_Words();
    return words;
❱

◀private: static▶ std::vector<std::string> ☀Get_Webish_Words()❰
    std::vector<std::string> web_words;
    web_words.emplace_back("25rem");
    web_words.emplace_back("2n");
    web_words.emplace_back("625rem");
    web_words.emplace_back("cdata");
    web_words.emplace_back("chrome");
    web_words.emplace_back("chromium");
    web_words.emplace_back("domready");
    web_words.emplace_back("element");
    web_words.emplace_back("gmt");
    web_words.emplace_back("navbar");
    web_words.emplace_back("utc");
    web_words.emplace_back("video");
    web_words.emplace_back("a");
    web_words.emplace_back("abort");
    web_words.emplace_back("aborted");
    web_words.emplace_back("about");
    web_words.emplace_back("addpageaction");
    web_words.emplace_back("addservice");
    web_words.emplace_back("adjust");
    web_words.emplace_back("align");
    web_words.emplace_back("api");
    web_words.emplace_back("appendchild");
    web_words.emplace_back("applicationtime");
    web_words.emplace_back("arguments");
    web_words.emplace_back("assetduration");
    web_words.emplace_back("async");
    web_words.emplace_back("auto");
    web_words.emplace_back("automax");
    web_words.emplace_back("b");
    web_words.emplace_back("background");
    web_words.emplace_back("body");
    web_words.emplace_back("border");
    web_words.emplace_back("bottom");
    web_words.emplace_back("c");
    web_words.emplace_back("calc");
    web_words.emplace_back("call");
    web_words.emplace_back("called");
    web_words.emplace_back("catch");
    web_words.emplace_back("cbtime");
    web_words.emplace_back("cd");
    web_words.emplace_back("char");
    web_words.emplace_back("charat");
    web_words.emplace_back("characterdata");
    web_words.emplace_back("clear");
    web_words.emplace_back("clearrect");
    web_words.emplace_back("cn");
    web_words.emplace_back("cnn");
    web_words.emplace_back("cnnsans");
    web_words.emplace_back("color");
    web_words.emplace_back("commentcount");
    web_words.emplace_back("containers");
    web_words.emplace_back("count");
    web_words.emplace_back("css");
    web_words.emplace_back("d");
    web_words.emplace_back("data");
    web_words.emplace_back("datemodified");
    web_words.emplace_back("datepublished");
    web_words.emplace_back("density");
    web_words.emplace_back("deskstop");
    web_words.emplace_back("dev");
    web_words.emplace_back("display");
    web_words.emplace_back("div");
    web_words.emplace_back("document");
    web_words.emplace_back("e");
    web_words.emplace_back("el");
    web_words.emplace_back("else");
    web_words.emplace_back("enable");
    web_words.emplace_back("enumerable");
    web_words.emplace_back("err");
    web_words.emplace_back("everythingexceptflag");
    web_words.emplace_back("exp");
    web_words.emplace_back("f");
    web_words.emplace_back("false");
    web_words.emplace_back("flex");
    web_words.emplace_back("fn");
    web_words.emplace_back("font");
    web_words.emplace_back("for");
    web_words.emplace_back("frameborder");
    web_words.emplace_back("front");
    web_words.emplace_back("full");
    web_words.emplace_back("function");
    web_words.emplace_back("g");
    web_words.emplace_back("googletag");
    web_words.emplace_back("gt");
    web_words.emplace_back("h");
    web_words.emplace_back("head");
    web_words.emplace_back("height");
    web_words.emplace_back("html");
    web_words.emplace_back("i");
    web_words.emplace_back("id");
    web_words.emplace_back("ids");
    web_words.emplace_back("idx");
    web_words.emplace_back("if");
    web_words.emplace_back("important");
    web_words.emplace_back("index");
    web_words.emplace_back("indexof");
    web_words.emplace_back("insert");
    web_words.emplace_back("ishidden");
    web_words.emplace_back("isoutstream");
    web_words.emplace_back("isprivate");
    web_words.emplace_back("item");
    web_words.emplace_back("j");
    web_words.emplace_back("jpg");
    web_words.emplace_back("js");
    web_words.emplace_back("k");
    web_words.emplace_back("l");
    web_words.emplace_back("left");
    web_words.emplace_back("length");
    web_words.emplace_back("line");
    web_words.emplace_back("listener");
    web_words.emplace_back("load");
    web_words.emplace_back("loaded");
    web_words.emplace_back("loader");
    web_words.emplace_back("m");
    web_words.emplace_back("margin");
    web_words.emplace_back("max");
    web_words.emplace_back("md");
    web_words.emplace_back("media");
    web_words.emplace_back("mode");
    web_words.emplace_back("n");
    web_words.emplace_back("nav");
    web_words.emplace_back("networkid");
    web_words.emplace_back("new");
    web_words.emplace_back("ngcontent");
    web_words.emplace_back("nrdev");
    web_words.emplace_back("null");
    web_words.emplace_back("o");
    web_words.emplace_back("onload");
    web_words.emplace_back("onloadcalled");
    web_words.emplace_back("opacity");
    web_words.emplace_back("order");
    web_words.emplace_back("outline");
    web_words.emplace_back("overflow");
    web_words.emplace_back("p");
    web_words.emplace_back("padding");
    web_words.emplace_back("page");
    web_words.emplace_back("passive");
    web_words.emplace_back("pg");
    web_words.emplace_back("port");
    web_words.emplace_back("position");
    web_words.emplace_back("px");
    web_words.emplace_back("r");
    web_words.emplace_back("radius");
    web_words.emplace_back("readystate");
    web_words.emplace_back("rem");
    web_words.emplace_back("return");
    web_words.emplace_back("rgb");
    web_words.emplace_back("rgba");
    web_words.emplace_back("right");
    web_words.emplace_back("routename");
    web_words.emplace_back("s");
    web_words.emplace_back("scale");
    web_words.emplace_back("script");
    web_words.emplace_back("search");
    web_words.emplace_back("shadow");
    web_words.emplace_back("sites");
    web_words.emplace_back("size");
    web_words.emplace_back("sizes");
    web_words.emplace_back("solid");
    web_words.emplace_back("spacing");
    web_words.emplace_back("split");
    web_words.emplace_back("src");
    web_words.emplace_back("status");
    web_words.emplace_back("stn");
    web_words.emplace_back("substr");
    web_words.emplace_back("substring");
    web_words.emplace_back("supersection");
    web_words.emplace_back("svg");
    web_words.emplace_back("t");
    web_words.emplace_back("text");
    web_words.emplace_back("this");
    web_words.emplace_back("thrown");
    web_words.emplace_back("title");
    web_words.emplace_back("to");
    web_words.emplace_back("tostring");
    web_words.emplace_back("top");
    web_words.emplace_back("totalcbs");
    web_words.emplace_back("transform");
    web_words.emplace_back("translate");
    web_words.emplace_back("translatex");
    web_words.emplace_back("translatey");
    web_words.emplace_back("translatez");
    web_words.emplace_back("true");
    web_words.emplace_back("try");
    web_words.emplace_back("type");
    web_words.emplace_back("typename");
    web_words.emplace_back("u");
    web_words.emplace_back("uc");
    web_words.emplace_back("undefined");
    web_words.emplace_back("utf");
    web_words.emplace_back("v");
    web_words.emplace_back("value");
    web_words.emplace_back("var");
    web_words.emplace_back("visibility");
    web_words.emplace_back("void");
    web_words.emplace_back("w");
    web_words.emplace_back("webkit");
    web_words.emplace_back("weight");
    web_words.emplace_back("wgaddriverabtestidtargeting");
    web_words.emplace_back("wgaddriverdelaytimeout");
    web_words.emplace_back("wgaddrivermoattrackingforfeaturedvideoadsampling");
    web_words.emplace_back("wgaddriverplayadsonnextfvfrequency");
    web_words.emplace_back("wgaddriverporvatamoattrackingsampling");
    web_words.emplace_back("wgaddriverstickyslotslines");
    web_words.emplace_back("wgenabletrackingoptinmodal");
    web_words.emplace_back("wgfollowedpagespagerlimit");
    web_words.emplace_back("wgfollowedpagespagerlimitajax");
    web_words.emplace_back("wgmaxuploadsize");
    web_words.emplace_back("wgminimalpasswordlength");
    web_words.emplace_back("wgmobilequalaroo");
    web_words.emplace_back("wgnamespacenumber");
    web_words.emplace_back("wgstyleversion");
    web_words.emplace_back("wgtrackid");
    web_words.emplace_back("wgwikiamaxnamechars");
    web_words.emplace_back("widget");
    web_words.emplace_back("width");
    web_words.emplace_back("widthtype");
    web_words.emplace_back("window");
    web_words.emplace_back("wllimit");
    web_words.emplace_back("writable");
    web_words.emplace_back("x");
    web_words.emplace_back("xfbml");
    web_words.emplace_back("xhr");
    web_words.emplace_back("y");
    web_words.emplace_back("you");
    web_words.emplace_back("z");
    web_words.emplace_back("zn");
    web_words.emplace_back("zoom");
    web_words.emplace_back("©");
    return web_words;
❱

◀private: static▶ std::vector<std::string> ☀Get_Boring_Words()❰
    std::vector<std::string> web_words;
    web_words.emplace_back("of");
    web_words.emplace_back("is");
    web_words.emplace_back("the");
    web_words.emplace_back("in");
    web_words.emplace_back("than");
    web_words.emplace_back("at");
    web_words.emplace_back("and");
    web_words.emplace_back("or");
    web_words.emplace_back("but");
    web_words.emplace_back("was");
    web_words.emplace_back("ver");
    web_words.emplace_back("now");
    web_words.emplace_back("as");
    web_words.emplace_back("only");
    web_words.emplace_back("that");
    web_words.emplace_back("this");
    web_words.emplace_back("with");
    web_words.emplace_back("them");
    web_words.emplace_back("by");
    return web_words;
❱

