class
❪"code/tools/noogle/meta_settings"❫
❪"code/utilities/web/automate/browser/browser_settings"❫
❪"code/tools/noogle/settings/noogle_settings"❫
❪"code/utilities/data_structures/queue/safe_queue.h"❫
❪"code/utilities/data_structures/queue/finishable_safe_queue.h"❫
❪"code/tools/noogle/noogle_running_stats"❫
❪"code/tools/noogle/noogle_result"❫
❪atomic❫
❪unordered_set❫
❪"code/tools/noogle/program_options/program_options"❫
⚯
❪iostream❫
❪thread❫
❪"code/utilities/web/chrome/driver/chrome_driver_selector"❫
❪pybind11/embed.h❫
❪"code/utilities/web/automate/browser/browser_creator"❫
❪"code/utilities/web/automate/navigation/browser_navigator"❫
❪"code/tools/noogle/default_settings_getter"❫
❪"code/utilities/types/strings/transformers/search_replace/lib"❫
❪"code/utilities/types/strings/transformers/squeeze/lib"❫
❪"code/utilities/time/sleeping/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/web/google/google_search_url_deviser"❫
❪"code/utilities/web/google/google_json_url_deviser"❫
❪"code/utilities/web/bing/bing_json_url_deviser"❫
❪"code/utilities/web/lib"❫
❪"code/utilities/exits/lib"❫
❪boost/asio/thread_pool.hpp❫
❪boost/asio/post.hpp❫
❪"code/utilities/printers/lib"❫
❪"code/utilities/types/strings/observers/splitting/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/types/strings/observers/characteristic/spirit_numeric_checker"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/types/strings/observers/char/lib"❫
❪"code/utilities/types/vectors/transformers/lib"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/types/strings/transformers/casing/lib"❫
❪"code/utilities/chart/ascii/chart_getter"❫
❪"url.hpp"❫
❪"code/utilities/types/sets/lib"❫
❪"code/utilities/types/strings/observers/characteristic/english_number_to_integral_converter"❫
❪"code/utilities/types/strings/observers/characteristic/is_english_number_checker"❫
❪"code/tools/noogle/results_shower"❫
❪"code/utilities/filesystem/files/creating/lib"❫
❪"code/utilities/types/strings/transformers/html/html_raw_text_getter"❫
❪"code/tools/noogle/token_adder"❫
❪"code/tools/noogle/query_extender"❫
⚞⚟

//apt-get install python3-bs4

//can you noogle a googol?
//should return a very large number (mpz support)


//most data is time (points & durations)
//points = dates (June 2019)
//durations =  (3 years)

◀public: static▶ void ☀Run(Meta_Settings const& meta, Program_Options const& options) ❰


    //when the python scoped interpreter exists, I can't ctrl+c out of the program
    //we'll remedy that with a custom signal handler.
    //find out why this is though, maybe we can do something better.
    //https://github.com/pybind/pybind11/issues/1813
    //it would be nice to not even embed the python interpreter for selenium usage.
    //I'm not sure how feasible that is (apart from spawning a whole other process (undesirable)).
    signal(SIGINT,[](int signum){
        exit(signum);
    });
    
    //make sure we have a python environment going for the duration of the program (RAII)
    pybind11::scoped_interpreter guard{};
    
    //add python implementations
    Html_Raw_Text_Getter::add_beautiful_soup_function();
    
    //create a browser to automate queries on
    //Browser_Creator::Create(settings.browser);
    
    //catch crashes
    // signal(SIGSEGV,[](int signum){
    //     ::signal(signum, SIG_DFL);
    //     boost::stacktrace::safe_dump_to("./backtrace.dump");
    //     ::raise(SIGABRT);
    // });
    // signal(SIGABRT,[](int signum){
    //     ::signal(signum, SIG_DFL);
    //     boost::stacktrace::safe_dump_to("./backtrace.dump");
    //     ::raise(SIGABRT);
    // });


    //settings
    auto settings = Default_Settings_Getter::Get();
    Noogle_Running_Stats stats;
    stats.sites.name = "sites";
    stats.htmls.name = "htmls";
    stats.sanitized.name = "sanitized";
    
    //expand the user's query to many enriched queries to help increase our search
    auto queries = Query_Extender::Expand_Query(settings.query_expand,options.Query());
    
    
    
    
    //auto google_search_urls = Google_Search_Url_Deviser::Devise(settings.devise_google_search_urls,options.Query());
    //auto google_query_urls = Google_Json_Url_Deviser::Devise(settings.devise_google_query_urls,options.Query());
    
    std::vector<std::string> bing_urls;
    for (auto const& query: queries){
        bing_urls += Bing_Json_Url_Deviser::Devise(settings.devise_bing_query_urls,query);
    }
    
    
    
    //for (auto const& it: bing_urls){
    //    std::cout << it << std::endl;
    //}
    //exit(0);
    
    //all of the shared queues involved in the pipeline of converting
    //queries into noogle results
    FinishableSafeQueue<std::string> result_urls;
    FinishableSafeQueue<std::string> html_results;
    FinishableSafeQueue<std::string> sanitized_text;
    FinishableSafeQueue<Noogle_Result> noogle_results;
    
    // construct and run the jobs communicating over shared queues
    std::vector<std::thread> jobs;
    jobs.emplace_back(Results_Shower::Show_Results,std::cref(stats),std::ref(noogle_results));
    //jobs.emplace_back(Google_Search_Urls_To_Google_Result_Urls,settings.browser,std::ref(stats),google_search_urls,std::ref(result_urls));
    //jobs.emplace_back(Google_Query_Urls_To_Google_Result_Urls,settings.browser,std::ref(stats),google_query_urls,std::ref(result_urls));
    jobs.emplace_back(Bing_Query_Urls_To_Result_Urls,std::ref(stats),bing_urls,std::ref(result_urls));
    jobs.emplace_back(Convert_Result_Urls_To_Html,settings.browser,std::ref(stats),std::ref(result_urls),std::ref(html_results));
    jobs.emplace_back(Sanitize_Html,std::ref(stats),std::ref(html_results),std::ref(sanitized_text));
    jobs.emplace_back(Parse_For_Noogle_Results,std::ref(settings),std::ref(stats),std::ref(sanitized_text),std::ref(noogle_results));
    for (auto & it: jobs){
        it.join();
    }
    
❱


//STEP 1 (A)
◀private: static▶ void ☀Google_Search_Urls_To_Google_Result_Urls(Browser_Settings const& settings, Noogle_Running_Stats & stats, std::vector<std::string> const& google_search_urls, FinishableSafeQueue<std::string> & q)❰

    std::unordered_set<std::string> seen_hosts;
    
    for (auto const& search_url: google_search_urls){
        auto result_urls = Browser_Navigator::Get_Google_Result_Urls(settings,search_url);
        for (auto const& result_url: result_urls){
            if (Google_Result_Url_Is_Valid_For_Exploring(result_url,seen_hosts)){
                ++stats.sites.total;
                q.add(result_url);
                ++stats.sites.current;
            }
        }
    }
    q.mark_finished();
    stats.sites.finished = true;
❱

◀private: static▶ bool ☀Google_Result_Url_Is_Valid_For_Exploring(std::string const& url,std::unordered_set<std::string> & seen_hosts)❰
   
   try {
       std::string new_host_name = url_as_hostname(url);
       
        if (Begins_With(url,"https://www.google.com/search?")){
            return false;
        }
        
        if (Begins_With(url,"mailto:")){
            return false;
        }
        
        if (seen_hosts.find(new_host_name) != seen_hosts.end()){
            //std::cout << "dropping " << new_host_name << std::endl;
            return false;
        }
        
        //std::cout << new_host_name << std::endl;
        seen_hosts.insert(new_host_name);
    }
    catch(...){
    }
    return true;
❱

◀private: static▶ std::string ☀url_as_hostname(std::string const& url)❰
       Url parsed_url(url);
       auto host_name = parsed_url.host();
       auto parts = Split_Into_Parts_From_Dot(host_name);
       while (parts.size() > 2){
            Remove_First_Element(parts);
       }
       std::string new_host_name = "";
       if (!parts.empty()){
            new_host_name = parts[0];
       }
       return new_host_name;
❱


//STEP 1 (B)
◀private: static▶ void ☀Google_Query_Urls_To_Google_Result_Urls(Browser_Settings const& settings, Noogle_Running_Stats & stats, std::vector<std::string> const& google_query_urls, FinishableSafeQueue<std::string> & q)❰
    
    std::unordered_set<std::string> seen_hosts;
    for (auto const& search_url: google_query_urls){
        
        //query json endpoint
        Html_Fetch_Settings fetch_settings;
        fetch_settings.url = search_url;
        auto response = Get_Html_Of_Site(fetch_settings);
        
        auto j = nlohmann::json::parse(response);
        for (auto it: j["items"]){
            auto result_url = it["link"].get<std::string>();
            if (Google_Result_Url_Is_Valid_For_Exploring(result_url,seen_hosts)){
                ++stats.sites.total;
                q.add(result_url);
                ++stats.sites.current;
            }
        }
    }
    q.mark_finished();
    stats.sites.finished = true;
❱

//STEP 1 (C)
◀private: static▶ void ☀Bing_Query_Urls_To_Result_Urls(Noogle_Running_Stats & stats, std::vector<std::string> const& urls, FinishableSafeQueue<std::string> & q)❰
    std::unordered_set<std::string> seen_hosts;
    for (auto const& search_url: urls){
        
        //query json endpoint
        Html_Fetch_Settings fetch_settings;
        fetch_settings.url = search_url;
        fetch_settings.headers.emplace_back("Ocp-Apim-Subscription-Key: 20bb843162f847609f93b7f509ba7645"); 
        auto response = Get_Html_Of_Site(fetch_settings);
        
        auto j = nlohmann::json::parse(response);
        for (auto it: j["webPages"]["value"]){
            auto result_url = it["url"].get<std::string>();
            if (Google_Result_Url_Is_Valid_For_Exploring(result_url,seen_hosts)){
                ++stats.sites.total;
                q.add(result_url);
                ++stats.sites.current;
            }
        }
    }
    q.mark_finished();
    stats.sites.finished = true;
❱

//STEP 2
◀private: static▶ void ☀Convert_Result_Urls_To_Html(Browser_Settings const& settings, Noogle_Running_Stats & stats, FinishableSafeQueue<std::string> & urls_in, FinishableSafeQueue<std::string> & html_out)❰
    
    
    std::unordered_set<std::string> duplicate_htmls;
    bool write_html_files = false;
    std::string dump_html_location = "/home/laptop/Desktop/html_dump/";
    
    
    //int threadNumbers = std::thread::hardware_concurrency();
    int threadNumbers = 10;
    boost::asio::thread_pool pool(threadNumbers);
    while(!urls_in.is_finished() || !urls_in.is_empty()){
        
        if (!urls_in.is_empty()){
            auto str = urls_in.get();
            ++stats.htmls.total;
            boost::asio::post(pool, [&,str]() {
                Html_Fetch_Settings fetch_settings;
                fetch_settings.url = str;
                auto html = Get_Html_Of_Site(fetch_settings);
                
                if (duplicate_htmls.find(html) == duplicate_htmls.end()){
                    html_out.add(html);
                    duplicate_htmls.insert(html);
                    
                   if (write_html_files){
                        Write_To_File(dump_html_location + url_as_hostname(fetch_settings.url),html);
                    }
                }
                ++stats.htmls.current;
                
                if (html.empty()){
                    //std::cout << fetch_settings.url << std::endl;
                }
            });
        }
    }
    pool.join();
    html_out.mark_finished();
    stats.htmls.finished = true;
❱

//STEP 3
◀private: static▶ void ☀Sanitize_Html(Noogle_Running_Stats & stats, FinishableSafeQueue<std::string> & html_results, FinishableSafeQueue<std::string> & sanitized_text)❰

    int i = 0;
    bool write_html_files = true;
    std::string dump_html_location = "/home/laptop/Desktop/html_dump/";
    
    while(!html_results.is_finished() || !html_results.is_empty()){
        auto str = html_results.get();
            ++stats.sanitized.total;
            sanitized_text.add(parse_out_text_from_html(str));
            ++stats.sanitized.current;
            
           if (write_html_files){
                Write_To_File(dump_html_location + std::to_string(i),parse_out_text_from_html(str));
                ++i;
            }
            
            
    }
    sanitized_text.mark_finished();
    stats.sanitized.finished = true;
❱

◀private: static▶ std::string ☀parse_out_text_from_html(std::string str)❰
    try{
        auto result = Html_Raw_Text_Getter::parse_away_html_tags(str);
        return result;
    }
    catch(...){
        //sanitized_text.add(str);
    }
    return "empty";
❱


//STEP 4
◀private: static▶ void ☀Parse_For_Noogle_Results(Noogle_Settings const& settings, Noogle_Running_Stats & stats, FinishableSafeQueue<std::string> & sanitized_text, FinishableSafeQueue<Noogle_Result> & noogle_results)❰
    while(!sanitized_text.is_finished() || !sanitized_text.is_empty()){
        
        auto blob = sanitized_text.get();
        Parse_Html_Blob(blob,stats,noogle_results,settings);
    }
    
    noogle_results.mark_finished();
❱

◀private: static▶ void ☀Parse_Html_Blob(std::string const& blob, Noogle_Running_Stats & stats, FinishableSafeQueue<Noogle_Result> & noogle_results, Noogle_Settings const& settings)❰



    std::unordered_set<std::string> local_site_results;
    auto tokens = Default_Boost_Tokenize(blob);
    for (size_t i = 0; i < tokens.size(); ++i){
        Token_Adder::Decide_If_Token_Is_A_Result(stats,tokens[i],tokens,i,local_site_results,settings);
    }
    
    //add local site results to global
    for (auto const& it: local_site_results){
        Noogle_Result result;
        result.number = it;
        noogle_results.add(result);
        stats.currated_results.Add(result.number);
        ++stats.results;
        
    }
❱









