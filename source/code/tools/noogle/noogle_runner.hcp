class
❪"code/tools/noogle/meta_settings"❫
❪"code/utilities/web/automate/browser/browser_settings"❫
❪"code/tools/noogle/settings/noogle_settings"❫
❪"code/utilities/data_structures/queue/safe_queue.h"❫
❪"code/utilities/data_structures/queue/finishable_safe_queue.h"❫
❪"code/tools/noogle/noogle_running_stats"❫
❪"code/tools/noogle/noogle_result"❫
❪atomic❫
❪"code/tools/noogle/program_options/program_options"❫
⚯
❪iostream❫
❪thread❫
❪"code/utilities/web/chrome/driver/chrome_driver_selector"❫
❪pybind11/embed.h❫
❪"code/utilities/web/automate/browser/browser_creator"❫
❪"code/utilities/web/automate/navigation/browser_navigator"❫
❪"code/tools/noogle/default_settings_getter"❫
❪"code/utilities/types/strings/transformers/search_replace/lib"❫
❪"code/utilities/types/strings/transformers/squeeze/lib"❫
❪"code/utilities/time/sleeping/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/web/google/google_search_url_deviser"❫
❪"code/utilities/web/google/google_json_url_deviser"❫
❪"code/utilities/web/lib"❫
❪"code/utilities/exits/lib"❫
❪boost/asio/thread_pool.hpp❫
❪boost/asio/post.hpp❫
❪"code/utilities/printers/lib"❫
❪"code/utilities/types/strings/observers/splitting/lib"❫
❪"code/utilities/types/strings/observers/characteristic/spirit_numeric_checker"❫
⚞⚟

//apt-get install python3-bs4

//can you noogle a googol?
//should return a very large number (mpz support)

◀public: static▶ void ☀Run(Meta_Settings const& meta, Program_Options const& options) ❰


    //when the python scoped interpreter exists, I can't ctrl+c the program
    //we'll remedy that with a custom signal handler.
    //find out why this is, maybe we can do something better.
    //https://github.com/pybind/pybind11/issues/1813
    signal(SIGINT,[](int signum){
        exit(signum);
    });


    //settings
    auto settings = Default_Settings_Getter::Get();
    Noogle_Running_Stats stats;
    
    //make sure we have a python environment going for the duration of the program (RAII)
    pybind11::scoped_interpreter guard{};
    
    //add python implementations
    add_beautiful_soup_function();
    
    //create a browser to automate queries on
    //Browser_Creator::Create(settings.browser);
    
    //get all of the google urls to search with
    auto google_search_urls = Google_Search_Url_Deviser::Devise(settings.devise_google_search_urls,options.Query());
    auto google_query_urls = Google_Json_Url_Deviser::Devise(settings.devise_google_query_urls,options.Query());
    
    
    FinishableSafeQueue<std::string> result_urls;
    FinishableSafeQueue<std::string> html_results;
    FinishableSafeQueue<std::string> sanitized_text;
    FinishableSafeQueue<Noogle_Result> noogle_results;
    
    std::vector<std::thread> jobs;
    jobs.emplace_back(Show_Results,std::cref(stats),std::ref(noogle_results));
    //jobs.emplace_back(Google_Search_Urls_To_Google_Result_Urls,settings.browser,std::ref(stats),google_search_urls,std::ref(result_urls));
    jobs.emplace_back(Google_Query_Urls_To_Google_Result_Urls,settings.browser,std::ref(stats),google_query_urls,std::ref(result_urls));
    jobs.emplace_back(Convert_Result_Urls_To_Html,settings.browser,std::ref(stats),std::ref(result_urls),std::ref(html_results));
    jobs.emplace_back(Sanitize_Html,std::ref(stats),std::ref(html_results),std::ref(sanitized_text));
    jobs.emplace_back(Parse_For_Noogle_Results,std::ref(stats),std::ref(sanitized_text),std::ref(noogle_results));
    
    for (auto & it: jobs){
        it.join();
    }
    
❱


◀private: static▶ std::string ☀parse_away_html_tags(std::string & html)❰
    make_python_str(html);
    auto parsed = pybind11::eval("parse_html(" + html + ")").cast<std::string>();
    return parsed;
❱

◀private: static▶ void ☀make_python_str(std::string & str)❰
    str += "\"\"\"\n";
    str = std::string("\"\"\"\n") + str;
❱

◀private: static▶ void ☀add_beautiful_soup_function()❰
    pybind11::exec("from bs4 import BeautifulSoup");
    pybind11::exec(R"(
def parse_html(x):
    soup = BeautifulSoup(x, 'html.parser')
    return soup.get_text()
)");
❱



//STEP 1 (A)
◀private: static▶ void ☀Google_Search_Urls_To_Google_Result_Urls(Browser_Settings const& settings, Noogle_Running_Stats & stats, std::vector<std::string> const& google_search_urls, FinishableSafeQueue<std::string> & q)❰
    for (auto const& search_url: google_search_urls){
        auto result_urls = Browser_Navigator::Get_Google_Result_Urls(settings,search_url);
        for (auto const& result_url: result_urls){
            if (Google_Result_Url_Is_Valid_For_Exploring(result_url)){
                ++stats.sites_total;
                q.add(result_url);
                ++stats.sites_current;
            }
        }
    }
    q.mark_finished();
❱

◀private: static▶ bool ☀Google_Result_Url_Is_Valid_For_Exploring(std::string const& url)❰
    if (Begins_With(url,"https://www.google.com/search?")){
        return false;
    }
    return true;
❱

//STEP 1 (B)
◀private: static▶ void ☀Google_Query_Urls_To_Google_Result_Urls(Browser_Settings const& settings, Noogle_Running_Stats & stats, std::vector<std::string> const& google_query_urls, FinishableSafeQueue<std::string> & q)❰
    for (auto const& search_url: google_query_urls){
        
        //query json endpoint
        Html_Fetch_Settings fetch_settings;
        fetch_settings.url = search_url;
        auto response = Get_Html_Of_Site(fetch_settings);
        
        auto j = nlohmann::json::parse(response);
        for (auto it: j["items"]){
            auto result_url = it["link"].get<std::string>();
            ++stats.sites_total;
            q.add(result_url);
            ++stats.sites_current;
        }
    }
    q.mark_finished();
❱

//STEP 2
◀private: static▶ void ☀Convert_Result_Urls_To_Html(Browser_Settings const& settings, Noogle_Running_Stats & stats, FinishableSafeQueue<std::string> & urls_in, FinishableSafeQueue<std::string> & html_out)❰
    
    //int threadNumbers = std::thread::hardware_concurrency();
    int threadNumbers = 10;
    boost::asio::thread_pool pool(threadNumbers);
    while(!urls_in.is_finished() || !urls_in.is_empty()){
        auto str = urls_in.get();
        ++stats.htmls_total;
        boost::asio::post(pool, [&,str]() {
            Html_Fetch_Settings fetch_settings;
            fetch_settings.url = str;
            auto html = Get_Html_Of_Site(fetch_settings);
            html_out.add(html);
            ++stats.htmls_current;
            
            if (html.empty()){
                //std::cout << fetch_settings.url << std::endl;
            }
        });
    }
    pool.join();
    html_out.mark_finished();
❱

//STEP 3
◀private: static▶ void ☀Sanitize_Html(Noogle_Running_Stats & stats, FinishableSafeQueue<std::string> & html_results, FinishableSafeQueue<std::string> & sanitized_text)❰
    while(!html_results.is_finished() || !html_results.is_empty()){
        auto str = html_results.get();
            ++stats.sanitized_total;
            sanitized_text.add(str);
            ++stats.sanitized_current;
    }
    sanitized_text.mark_finished();
❱

//STEP 4
◀private: static▶ void ☀Parse_For_Noogle_Results(Noogle_Running_Stats & stats, FinishableSafeQueue<std::string> & sanitized_text, FinishableSafeQueue<Noogle_Result> & noogle_results)❰
    while(!sanitized_text.is_finished() || !sanitized_text.is_empty()){
        
        auto str = sanitized_text.get();
        auto tokens = Default_Boost_Tokenize(str);
        for (size_t i = 0; i < tokens.size(); ++i){
            Decide_If_Token_Is_A_Result(stats,tokens[i],tokens,i,noogle_results);
        }
    }
    
    noogle_results.mark_finished();
❱
◀private: static▶ void ☀Decide_If_Token_Is_A_Result(Noogle_Running_Stats & stats, std::string const& token, std::vector<std::string> const& tokens, size_t index, FinishableSafeQueue<Noogle_Result> & noogle_results)❰

    if (Spirit_Numeric_Checker::Is_Numeric(token)){
        Add_Left_Window(stats,token,tokens,index,noogle_results);
        Add_Right_Window(stats,token,tokens,index,noogle_results);
    }
❱

◀private: static▶ void ☀Add_Left_Window(Noogle_Running_Stats & stats, std::string const& token, std::vector<std::string> const& tokens, size_t index, FinishableSafeQueue<Noogle_Result> & noogle_results)❰
    if (index-1 > 0){
        if (!Spirit_Numeric_Checker::Is_Numeric(tokens[index-1])){
            Noogle_Result result;
            result.number = tokens[index-1] + " " + token;
            noogle_results.add(result);
            stats.currated_results.Add(result.number);
            ++stats.results;
        }
    }
❱
◀private: static▶ void ☀Add_Right_Window(Noogle_Running_Stats & stats, std::string const& token, std::vector<std::string> const& tokens, size_t index, FinishableSafeQueue<Noogle_Result> & noogle_results)❰
    if (index+1 < tokens.size()){
        if (!Spirit_Numeric_Checker::Is_Numeric(tokens[index+1])){
            Noogle_Result result;
            result.number = token + " " + tokens[index+1];
            noogle_results.add(result);
            stats.currated_results.Add(result.number);
            ++stats.results;
        }
    }
❱
◀private: static▶ void ☀Add_Exact(Noogle_Running_Stats & stats, std::string const& token, std::vector<std::string> const& tokens, size_t index, FinishableSafeQueue<Noogle_Result> & noogle_results)❰
    Noogle_Result result;
    result.number = token;
    noogle_results.add(result);
    stats.currated_results.Add(result.number);
    ++stats.results;
❱



//SHOW STEP
◀private: static▶ void ☀Show_Results(Noogle_Running_Stats const& stats, FinishableSafeQueue<Noogle_Result> & noogle_results)❰

    int height = 0;
    while(!noogle_results.is_finished()){
        Clear_Terminal_Up_N_Lines(height);
        
        auto results = stats.currated_results.Top_N_Most_Common(30);
        height = results.size();
        std::cout << Build_Progress_Message(stats,results);
        std::cout.flush();
        Sleep_For_N_Milliseconds(1000);
    }
❱

◀private: static▶ std::string ☀Build_Progress_Message(Noogle_Running_Stats const& stats, std::vector<std::pair<int,std::string>> const& results)❰
        std::string progress;
        progress += " ";
        progress += "urls [" + std::to_string(stats.sites_current) + "/" + std::to_string(stats.sites_total) + "]";
        progress += " ";
        progress += "htmls [" + std::to_string(stats.htmls_current) + "/" + std::to_string(stats.htmls_total) + "]";
        progress += " ";
        progress += "texts [" + std::to_string(stats.sanitized_current) + "/" + std::to_string(stats.sanitized_total) + "]";
        progress += " ";
        progress += "results: " + std::to_string(stats.results);
        
        for (auto const& it: results){
            progress += "\n";
            progress += it.second + " " + std::to_string(it.first);
        }
        
        return progress;
❱

