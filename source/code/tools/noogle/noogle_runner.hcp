class
❪"code/tools/noogle/meta_settings"❫
❪"code/utilities/web/automate/browser/browser_settings"❫
❪"code/tools/noogle/settings/noogle_settings"❫
❪"code/utilities/data_structures/queue/safe_queue.h"❫
⚯
❪iostream❫
❪thread❫
❪"code/utilities/web/chrome/driver/chrome_driver_selector"❫
❪pybind11/embed.h❫
❪"code/utilities/web/automate/browser/browser_creator"❫
❪"code/tools/noogle/default_settings_getter"❫
❪"code/utilities/types/strings/transformers/search_replace/lib"❫
❪"code/utilities/types/strings/transformers/squeeze/lib"❫
❪"code/utilities/time/sleeping/lib"❫
⚞⚟


◀public: static▶ void ☀Run(Meta_Settings const& meta) ❰

    //settings
    auto settings = Default_Settings_Getter::Get();
    
    //make sure we have a python environment going for the duration of the program (RAII)
    pybind11::scoped_interpreter guard{};
    
    //create a browser to automate queries on
    Browser_Creator::Create(settings.browser);
    
    
    //get all of the google urls to search with
    auto google_search_urls = Devise_Google_Search_Urls(settings,"test");

    
    //add result urls to a queue
    SafeQueue<std::string> result_urls;
    std::thread t1(Google_Search_Urls_To_Google_Result_Urls,settings.browser,google_search_urls,std::ref(result_urls));
    
    SafeQueue<std::string> html_results;
    std::thread t2(Convert_Result_Urls_To_Html,settings.browser,std::ref(result_urls),std::ref(html_results));
    
    t1.join();
    t2.join();
    
    //auto urls = Get_Google_Result_Urls(settings.browser,google_search_urls[0]);
    //for (auto it: urls){
    //     std::cout << it << std::endl;
    //}
    
    /*
    Go_To_Google_And_Search_Something(settings.browser,"test");
    
    auto urls = Get_Google_Next_Prev_Pages(settings.browser);
    //auto urls = Get_Search_Result_Urls_From_Page(settings.browser);
    for (auto it: urls){
        std::cout << it << std::endl;
    }
    
    */
❱


◀private: static▶ void ☀Google_Search_Urls_To_Google_Result_Urls(Browser_Settings const& settings, std::vector<std::string> const& google_search_urls, SafeQueue<std::string> & q)❰
    for (auto const& search_url: google_search_urls){
        auto result_urls = Get_Google_Result_Urls(settings,search_url);
        for (auto const& result_url: result_urls){
            q.add(result_url);
        }
    }
❱

◀private: static▶ void ☀Convert_Result_Urls_To_Html(Browser_Settings const& settings, SafeQueue<std::string> & urls_in, SafeQueue<std::string> & html_out)❰
    
    while(true){
        auto str = urls_in.get();
        std::cout << str << std::endl;
    }
❱

◀private: static▶ std::vector<std::string> ☀Get_Google_Result_Urls(Browser_Settings const& settings, std::string const& url)❰
    Go_To_Url(settings,url);
    return Get_Search_Result_Urls_From_Page(settings);
❱


◀private: static▶ std::vector<std::string> ☀Devise_Google_Search_Urls(Noogle_Settings const& settings, std::string query)❰
    
    std::string base_url = "https://www.google.com/search?q=";
    int page_count = 5;
    int results_per_page = 100; //max 100
    
    Squeeze_Away_Spaces(query);
    replace_spaces_with_plus(query);
    base_url += query;
    
    std::vector<std::string> urls;
    for (size_t i = 0; i < page_count; ++i){
        auto new_url = base_url;
        new_url += "&num=" + std::to_string(results_per_page);
        new_url += "&start=";
        new_url += std::to_string((i*results_per_page));
        urls.emplace_back(new_url);
    }
    return urls;

❱



//browser navigating
◀private: static▶ void ☀Go_To_Google_And_Search_Something(Browser_Settings const& settings, std::string const& search_query)❰
    Go_To_Google_And_Search_Something_Go_To_Page_First(settings,search_query);
❱

◀private: static▶ void ☀Go_To_Google_And_Search_Something_Go_To_Page_First(Browser_Settings const& settings, std::string const& search_query)❰
    Go_To_Google(settings);
    pybind11::exec("thing = " + settings.browser_name + ".find_element_by_name('q')");
    pybind11::exec("thing.send_keys('" + search_query + "')");
    pybind11::exec("thing.send_keys(Keys.RETURN)");
    //pybind11::exec("thing.submit()");
❱

◀private: static▶ void ☀Go_To_Google(Browser_Settings const& settings)❰
    Go_To_Url(settings,"http://google.com");
❱

◀private: static▶ void ☀Go_To_Url(Browser_Settings const& browser, std::string const& url)❰
    
    pybind11::exec(browser.browser_name + ".get('" + url + "')");
❱

◀private: static▶ std::vector<std::string> ☀Convert_Python_Strings_To_Vec(std::string const& var_name)❰
    auto py_obj = pybind11::eval("linkList").cast<pybind11::list>();
    std::vector<std::string> results;
    for (pybind11::handle o : py_obj) {
        std::string str = pybind11::cast<std::string>(o);
        results.emplace_back(str);
    }
    return results;
❱

◀private: static▶ std::vector<std::string> ☀Get_Google_Next_Prev_Pages(Browser_Settings const& browser)❰

    //this way didn't work
    //pybind11::exec("RESULTS_LOCATOR = '//div/h3/a'");
    //pybind11::exec("WebDriverWait(" + browser.browser_name + ", 10).until(EC.visibility_of_element_located((By.XPATH, RESULTS_LOCATOR)))");
    //pybind11::exec("page1_results = " + browser.browser_name + ".find_elements(By.XPATH, RESULTS_LOCATOR)");
    //pybind11::exec("print page1_results");

    //but this way does
    pybind11::exec("linkBox = " + browser.browser_name + ".find_element_by_xpath('//*[@id=\"nav\"]/tbody/tr')");
    pybind11::exec("links = linkBox.find_elements_by_css_selector('a')");
    pybind11::exec("linkList = []");
    pybind11::exec("for link in links: linkList.append(link.get_attribute('href'))");
    auto result = Convert_Python_Strings_To_Vec("linkList");
    return result;
    
❱

◀private: static▶ std::vector<std::string> ☀Get_Search_Result_Urls_From_Page(Browser_Settings const& browser)❰

    pybind11::exec("results = " + browser.browser_name + ".find_elements_by_css_selector('div.g')");
    pybind11::exec("linkList = []");
    pybind11::exec("for link in results: linkList.append(link.find_element_by_tag_name('a').get_attribute('href'))");
    auto result = Convert_Python_Strings_To_Vec("linkList");
    
    
    //import urlparse
    //print(urlparse.parse_qs(urlparse.urlparse(href).query)["q"])
    
    return result;
❱