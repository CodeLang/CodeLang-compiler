class
❪"code/tools/noogle/meta_settings"❫
❪"code/utilities/web/automate/browser/browser_settings"❫
⚯
❪iostream❫
❪"code/utilities/web/chrome/driver/chrome_driver_selector"❫
❪pybind11/embed.h❫
❪"code/utilities/web/automate/browser/browser_creator"❫
⚞⚟

◀public: static▶ void ☀Run(Meta_Settings const& meta) ❰
    
    //RAII stuff.  make sure we have a python environment going for the duration of the program
    pybind11::scoped_interpreter guard{};
    
    //create a browser to automate queries on
    auto settings = Default_Browser_Settings();
    Browser_Creator::Create(settings);
    Go_To_Google_And_Search_Something(settings,"test");
    Get_Google_Page_Links(settings);
❱


◀private: static▶ Browser_Settings ☀Default_Browser_Settings() ❰

    Browser_Settings settings;
    settings.headless = true;
    settings.ignore_certificate_errors = true;
    settings.disable_notifications = true;
    settings.disable_extensions = true;
    settings.start_maximized = true;
    settings.use_user_agent = true;
    settings.user_agent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/601.7.7 (KHTML, like Gecko) Version/9.1.2 Safari/601.7.7";
    
    //waiting
    settings.set_implicit_wait = true;
    settings.implicit_wait_s = 10;
    
    //names
    settings.browser_name = "browser";
    
    // other settings
    auto driver_settings = Chrome_Driver_Selector::Default_Settings();
    settings.driver_path = Chrome_Driver_Selector::Get_Driver_Path(driver_settings);
    std::cout << settings.driver_path << std::endl;
    return settings;
❱




//browser navigating
◀private: static▶ void ☀Go_To_Google_And_Search_Something(Browser_Settings const& settings, std::string const& search_query)❰
    Go_To_Google(settings);
    pybind11::exec("thing = " + settings.browser_name + ".find_element_by_name('q')");
    pybind11::exec("thing.send_keys('" + search_query + "')");
    pybind11::exec("thing.send_keys(Keys.RETURN)");
    //pybind11::exec("thing.submit()");
❱

◀private: static▶ void ☀Go_To_Google(Browser_Settings const& settings)❰
    Go_To_Url(settings,"http://google.com");
❱

◀private: static▶ void ☀Go_To_Url(Browser_Settings const& browser, std::string const& url)❰
    
    pybind11::exec(browser.browser_name + ".get('" + url + "')");
❱

◀private: static▶ std::vector<std::string> ☀Convert_Python_Strings_To_Vec(std::string const& var_name)❰
    auto py_obj = pybind11::eval("linkList").cast<pybind11::list>();
    std::vector<std::string> results;
    for (pybind11::handle o : py_obj) {
        std::string str = pybind11::cast<std::string>(o);
        results.emplace_back(str);
    }
    return results;
❱

◀private: static▶ void ☀Get_Google_Page_Links(Browser_Settings const& browser)❰

    //this way didn't work
    //pybind11::exec("RESULTS_LOCATOR = '//div/h3/a'");
    //pybind11::exec("WebDriverWait(" + browser.browser_name + ", 10).until(EC.visibility_of_element_located((By.XPATH, RESULTS_LOCATOR)))");
    //pybind11::exec("page1_results = " + browser.browser_name + ".find_elements(By.XPATH, RESULTS_LOCATOR)");
    //pybind11::exec("print page1_results");

    //but this way does
    pybind11::exec("linkBox = " + browser.browser_name + ".find_element_by_xpath('//*[@id=\"nav\"]/tbody/tr')");
    pybind11::exec("links = linkBox.find_elements_by_css_selector('a')");
    pybind11::exec("linkList = []");
    pybind11::exec("for link in links: linkList.append(link.get_attribute('href'))");
    //pybind11::exec("print(linkList)");
    
    
    auto result = Convert_Python_Strings_To_Vec("linkList");
    
    for (auto const& it: result){
        std::cout << it << std::endl;
    }

    
❱