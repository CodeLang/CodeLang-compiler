class
❪"code/utilities/web/automate/browser/browser_settings"❫
❪"code/tools/noogle/settings/noogle_settings"❫
❪"code/utilities/data_structures/queue/finishable_safe_queue.h"❫
❪"code/tools/noogle/state/noogle_running_stats"❫
❪unordered_set❫
❪"code/utilities/web/search_engines/search_engine_fetch_settings"❫
⚯
❪iostream❫
❪pybind11/embed.h❫
❪"code/utilities/web/automate/browser/browser_creator"❫
❪"code/utilities/web/automate/navigation/browser_navigator"❫
❪"code/tools/noogle/settings/default_settings_getter"❫
❪"code/utilities/types/strings/transformers/search_replace/lib"❫
❪"code/utilities/types/strings/transformers/squeeze/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/web/google/google_search_url_deviser"❫
❪"code/utilities/web/google/google_json_url_deviser"❫
❪"code/utilities/web/bing/bing_json_url_deviser"❫
❪"code/utilities/web/lib"❫
❪"code/utilities/exits/lib"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/types/strings/observers/char/lib"❫
❪"code/utilities/types/vectors/transformers/lib"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/types/strings/transformers/casing/lib"❫
❪"code/utilities/chart/ascii/chart_getter"❫
❪"code/utilities/web/url/url_parser"❫
❪"code/utilities/types/sets/lib"❫
❪"code/utilities/types/strings/observers/characteristic/english_number_to_integral_converter"❫
❪"code/utilities/types/strings/observers/characteristic/is_english_number_checker"❫
❪"code/tools/noogle/results_shower"❫
❪"code/utilities/filesystem/files/creating/lib"❫
❪"code/utilities/types/strings/transformers/html/html_raw_text_getter"❫
❪"code/utilities/web/search_engines/search_engine_url_deviser"❫
❪"code/utilities/json/functions/lib"❫
⚞⚟

◀public: static▶ void ☀Derive_From_Search_Engine_Urls(Noogle_Running_Stats & stats, std::vector<Search_Engine_Fetch_Settings> search_urls, FinishableSafeQueue<std::string> & q)❰
    for (auto const& it: search_urls){
        if (it.search_provider == Search_Engine_Type::GOOGLE_BROWSER){
        }
        else if (it.search_provider == Search_Engine_Type::GOOGLE_API){
        }
        else if (it.search_provider == Search_Engine_Type::BING_API){
        }
    }
❱


//STEP 1 (A)
◀private: static▶ void ☀Google_Search_Urls_To_Google_Result_Urls(Browser_Settings const& settings, Noogle_Running_Stats & stats, std::vector<std::string> const& google_search_urls, FinishableSafeQueue<std::string> & q)❰

    std::unordered_set<std::string> seen_hosts;
    for (auto const& search_url: google_search_urls){
        auto result_urls = Browser_Navigator::Get_Google_Result_Urls(settings,search_url);
        for (auto const& result_url: result_urls){
            if (Google_Result_Url_Is_Valid_For_Exploring(result_url,seen_hosts)){
                ++stats.sites.total;
                q.add(result_url);
                ++stats.sites.current;
            }
        }
    }
    q.mark_finished();
    stats.sites.finished = true;
❱
◀private: static▶ bool ☀Google_Result_Url_Is_Valid_For_Exploring(std::string const& url,std::unordered_set<std::string> & seen_hosts)❰
   
   //settings
   std::vector<std::string> blacklist_urls_start_with;
   blacklist_urls_start_with.emplace_back("https://www.google.com/search?");
   blacklist_urls_start_with.emplace_back("mailto:");
   bool dont_traverse_host_more_than_once = true;
   
   
   try {
       std::string new_host_name = Url_Parser::Get_Hostname(url);
       
        if (Begins_With_Any(url,blacklist_urls_start_with)){
            return false;
        }
        
        if (dont_traverse_host_more_than_once){
            if (seen_hosts.find(new_host_name) != seen_hosts.end()){
                return false;
            }
        }
        
        //std::cout << new_host_name << std::endl;
        seen_hosts.insert(new_host_name);
    }
    catch(...){
    }
    return true;
❱


//STEP 1 (B)
◀private: static▶ void ☀Google_Query_Urls_To_Google_Result_Urls(Browser_Settings const& settings, Noogle_Running_Stats & stats, std::vector<std::string> const& google_query_urls, FinishableSafeQueue<std::string> & q)❰
    
    std::unordered_set<std::string> seen_hosts;
    for (auto const& search_url: google_query_urls){
        
        //query json endpoint
        Html_Fetch_Settings fetch_settings;
        fetch_settings.url = search_url;
        auto response = Get_Html_Of_Site(fetch_settings);
        
        auto j = nlohmann::json::parse(response);
        for (auto it: j["items"]){
            auto result_url = it["link"].get<std::string>();
            if (Google_Result_Url_Is_Valid_For_Exploring(result_url,seen_hosts)){
                ++stats.sites.total;
                q.add(result_url);
                ++stats.sites.current;
            }
        }
    }
    q.mark_finished();
    stats.sites.finished = true;
❱

//STEP 1 (C)
◀private: static▶ void ☀Bing_Query_Urls_To_Result_Urls(Noogle_Running_Stats & stats, std::vector<std::string> const& urls, FinishableSafeQueue<std::string> & q)❰
    std::unordered_set<std::string> seen_hosts;
    for (auto const& search_url: urls){
        
        //query json endpoint
        Html_Fetch_Settings fetch_settings;
        fetch_settings.url = search_url;
        fetch_settings.headers.emplace_back("Ocp-Apim-Subscription-Key: 20bb843162f847609f93b7f509ba7645"); 
        auto response = Get_Html_Of_Site(fetch_settings);
        
        auto j = nlohmann::json::parse(response);
        for (auto it: j["webPages"]["value"]){
            auto result_url = it["url"].get<std::string>();
            if (Google_Result_Url_Is_Valid_For_Exploring(result_url,seen_hosts)){
                ++stats.sites.total;
                q.add(result_url);
                ++stats.sites.current;
            }
        }
    }
    q.mark_finished();
    stats.sites.finished = true;
❱