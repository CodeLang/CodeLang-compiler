class
❪vector❫
❪string❫
❪"code/utilities/types/vectors/converters/lib"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/types/vectors/transformers/lib"❫
❪"code/utilities/types/strings/observers/splitting/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/types/strings/observers/counters/lib"❫
❪"code/utilities/types/strings/transformers/removing/lib"❫
❪"code/utilities/types/strings/observers/char/lib"❫
❪"code/utilities/types/char/lib"❫
❪"code/utilities/output/printers/lib"❫
❪"code/utilities/types/string_grid/string_grid_builder"❫
❪"code/utilities/data_structures/compass_directions/compass_direction_diagnonal_movement"❫
❪"code/utilities/data_structures/compass_directions/compass_direction_diagnonal_movements"❫
❪"code/utilities/data_structures/graph/object_to_counted_objects"❫
❪"Graph.h"❫
❪"code/utilities/data_structures/graph/unique_str_vertex_graph/lib"❫
⚯
❪"code/utilities/data_structures/point/point"❫
❪"code/utilities/data_structures/point/point_mover"❫
❪"code/utilities/types/strings/transformers/trimming/lib"❫
❪"code/utilities/types/range/range_shrinker"❫
❪"code/utilities/data_structures/range/range"❫
❪"code/utilities/data_structures/counters/unique_counter/unique_counter"❫
❪"code/utilities/types/vectors/transformers/lib"❫
❪"code/utilities/linguistics/counted_object/counted_object_parser"❫
❪"code/utilities/formats/json/converters/type_to_json_string"❫
❪"code/utilities/types/strings/transformers/inflection/inflection_converter"❫
❪"code/utilities/types/strings/transformers/inflection/getters/inflection_settings_getter"❫
❪"code/utilities/types/strings/transformers/search_replace/lib"❫
⚞⚟

◀public: static▶ void ☀Part_1(std::vector<std::string> lines) ❰

    auto rels = Create_Relationships(lines);
    auto graph = Build_Graph(rels);
    
    //std::cout << graph.As_Graphviz() << std::endl;
    auto reachable = graph.explore("shiny gold bag");
    
    //-1 because we don't want to count ourselves
    std::cout << reachable.size()-1 << std::endl;
    
❱
◀public: static▶ void ☀Part_2(std::vector<std::string> lines) ❰
    auto rels = Create_Relationships(lines);
    auto graph = Build_Graph(rels);
    
    //std::cout << graph.As_Graphviz() << std::endl;
    auto reachable = graph.reachableDists("shiny gold bag");
    
    int total = 0;
    for (auto const& it: reachable){
        total += it.second;
    }
    std::cout << total << std::endl;
❱


◀private: static▶ std::vector<Object_To_Counted_Objects> ☀Create_Relationships(std::vector<std::string> const& lines) ❰
    std::vector<Object_To_Counted_Objects> results;

    for (auto const& it: lines){
        auto split = Split_Into_Parts_From_Delimiter(it,"contain");
        auto counted_objects = Counted_Object_Parser::Parse_Statement_Into_Counted_Objects(split[1]);
        
            trim(split[0]);
            
            
            auto settings = Inflection_Settings_Getter::Get();
            auto from = Inflection_Converter::As_Singular_Simple(split[0],settings);
            
            
            Object_To_Counted_Objects temp;
            temp.from = from;
            temp.to = counted_objects;
            results.emplace_back(temp);
    }
    
    return results;
❱

◀private: static▶ Graph ☀Build_Graph(std::vector<Object_To_Counted_Objects> const& rels)❰


    Graph G;
    
    for (auto const& it: rels){
        G.addNode(it.from);
        for (auto const& it2: it.to){
            G.addNode(it2.object);
            G.addEdge(it2.object,it.from,it2.count);
            //G.addEdge(it.from,it2.object,it2.count);
        }
    }
    
    return G;
❱

◀private: static▶ Unique_Str_Vertex_Graph ☀Build_Graph2(std::vector<Object_To_Counted_Objects> const& rels)❰
    Unique_Str_Vertex_Graph G;
    
    for (auto const& it: rels){
        for (auto const& it2: it.to){
            G.Connect(it2.object,it.from);
        }
    }
    
    return G;
❱