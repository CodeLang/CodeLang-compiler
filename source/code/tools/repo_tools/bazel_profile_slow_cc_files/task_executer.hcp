class
❪iostream❫
❪algorithm❫
❪"code/utilities/output/printers/lib"❫
❪"code/tools/repo_tools/bazel_profile_slow_cc_files/program_options/program_options"❫
❪"code/utilities/program/wrappers/bazel/bazel_runner"❫
❪"code/utilities/data_structures/counters/unique_counter/unique_counter"❫
❪"code/utilities/types/strings/observers/path/lib"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/filesystem/files/creating/lib"❫
❪"code/utilities/types/strings/observers/splitting/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/build/parse_profile/file_duration_extractor"❫
❪"code/utilities/build/build_repo_establisher/build_repo_establisher"❫
⚯
❪"code/utilities/web/honeycomb/honeycomb_poster"❫
⚞⚟


◀public: static▶ void ☀Execute_Needed_Tasks(Program_Options const& options) ❰

    auto profile_file = Create_Proile_File(options);
    std::cout << profile_file << std::endl;

    //extract compilation file durations from profile-file
    auto durations = File_Duration_Extractor::Extract(profile_file);
    
    //filter out ones we don't want
    
    //any of the external file compilations:
    Remove_If(durations,[&](Duration_File const& x){
        return Begins_With(x.file,"external");
    });
    
    //any of the compilations that are fast:
    Remove_If(durations,[&](Duration_File const& x){
        return x.duration_s < 60;
    });
    
    Sort_Slowest_To_Fastest(durations);
    
    //print them
    auto results = As_Printable_List(durations);
    std::cout << results << std::endl;
    Write_To_File(options.Output(),results);
    
    //upload them to honeycomb
    Upload_To_Honeycomb(options,durations);

❱

◀private: static▶ std::string ☀Create_Proile_File(Program_Options const& options) ❰

    //it was passed in
    if (!options.Profile_File().empty()){
        return options.Profile_File();
    }
    
    //use the other program options to build it
    return Create_Proile_File_By_Building(options);
❱


◀private: static▶ std::string ☀Create_Proile_File_By_Building(Program_Options const& options) ❰

    //get repo and context
    auto x = Build_Repo_Establisher::Establish_Repo_For_Building(options.Run_Dir(),options.Url(),options.Branch());
    
    auto profile_file = Bazel_Runner::Get_Profile_Information(x.program_to_run_build,
                                                              x.build_settings,
                                                              x.bazel_setup_settings.config_settings,
                                                              options.Target());
    return profile_file;
❱



//utility
◀private: static▶ void ☀Upload_To_Honeycomb(Program_Options const& options, std::vector<Duration_File> & durations)❰

    std::cout << "posting to honeycomb" << std::endl;
    for (auto const& it: durations){
        
        //data for sending
        std::string dataset = "https://api.honeycomb.io/1/events/" + options.Honeycomb_Dataset();
        std::string api_key = options.Honeycomb_API_Key();
        std::string data = As_Minified_JSON_String(it);
        
        //send and report errors
        auto result = Honeycomb_Poster::Post(dataset,api_key,data);
        if (!result.empty()){
            std::cerr << result << std::endl;
        }
    }
❱

◀private: static▶ void ☀Sort_Slowest_To_Fastest(std::vector<Duration_File> & durations)❰
    std::sort(durations.begin(),durations.end(),[&](Duration_File const& a, Duration_File const& b){
        return b.duration_s < a.duration_s;
    });
❱

◀private: static▶ std::string ☀As_Printable_List(std::vector<Duration_File> const& durations)❰
    std::stringstream ss;
    
    for (auto const& it: durations){
        ss << it.duration_s << " " << it.file << std::endl;
    }
    
    return ss.str();
❱