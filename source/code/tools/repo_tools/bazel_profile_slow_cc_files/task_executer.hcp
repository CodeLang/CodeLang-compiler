class
❪iostream❫
❪algorithm❫
❪"code/utilities/output/printers/lib"❫
❪"code/tools/repo_tools/bazel_profile_slow_cc_files/program_options/program_options"❫
❪"code/utilities/program/wrappers/bazel/bazel_runner"❫
❪"code/utilities/data_structures/counters/unique_counter/unique_counter"❫
❪"code/utilities/types/strings/observers/path/lib"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/filesystem/files/creating/lib"❫
❪"code/utilities/types/strings/observers/splitting/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/build/parse_profile/file_duration_extractor"❫
❪"code/utilities/build/build_repo_establisher/build_repo_establisher"❫
⚯
❪"code/tools/repo_tools/bazel_profile_slow_cc_files/results_publisher"❫
❪"code/tools/repo_tools/bazel_profile_slow_cc_files/results_filter"❫
❪"code/utilities/filesystem/files/deleting/lib"❫
❪"code/utilities/types/vectors/converters/lib"❫
❪"code/utilities/types/vectors/transformers/lib"❫
❪"code/utilities/filesystem/files/getting/lib"❫
⚞⚟


◀public: static▶ void ☀Execute_Needed_Tasks(Program_Options const& options) ❰


    //get repo and context
    auto repo_context = Build_Repo_Establisher::Establish_Repo_For_Building(options.Run_Dir(),options.Url(),options.Branch());
    
    //decide which targets to profile
    auto targets = Decide_Targets(repo_context,options.Target());
    Sort(targets);
    
    //show user those targets
    std::cout << "the targets to build: " << std::endl;
    std::cout << Get_As_String_With_Element_On_Each_Line(targets) << std::endl;


    //run analysis on each target
    for (auto const& it: targets){
        Run_Analysis_For_Target(repo_context,options,it);
    }


❱


◀private: static▶ std::vector<std::string> ☀Decide_Targets(Build_Repo_Settings const& x, std::string target)❰

    std::vector<std::string> results;
    if (!Ends_With(target,"...")){
        results.emplace_back(target);
        return results;
    }
    
    //since no target was specified, we will try to intelligently decide what bazel targets to build
    //the reason we don't want to just build all (...) is because we might run out of disk space.
    //So we want to build parts of the repository, clean, build different parts, clean, and repeat.
    
    //trim off what was given to us so that we have the folder name
    Remove_Last_N_Chars(target,3);
    Remove_First_N_Chars(target,2);
    
    //get the folders that are under it
    auto nested_dirs = Get_Dirs_Of_Path(x.repo.path + "/" + target);
    
    //rebuild all these more specific target names
    for (auto const& it: nested_dirs){
        std::string new_target_name;
        new_target_name += "//";
        new_target_name += target;
        new_target_name += it;
        new_target_name += "/...";
        results.emplace_back(new_target_name);
    }
    
    return results;
    

❱

◀private: static▶ void ☀Run_Analysis_For_Target(Build_Repo_Settings const& repo_context, Program_Options const& options, std::string const& target)❰

    auto profile_file = Create_Proile_File(repo_context, target, options.Profile_In(), options.Profile_Out());
    
    if (!profile_file.empty()){

        //extract compilation file durations from profile-file
        auto durations = File_Duration_Extractor::Extract(profile_file);
        
        //filter out ones we don't want
        Results_Filter::Filter_Results(durations);
        
        Results_Publisher::Publish(options,durations);
        
        Delete_File(profile_file);
    }
    
    Bazel_Runner::Clean(repo_context.program_to_run_build);

❱


◀private: static▶ std::string ☀Create_Proile_File(Build_Repo_Settings const& x, std::string const& target, std::string const& profile_in, std::string const& profile_out) ❰

    //it was passed in
    if (!profile_in.empty()){
        return profile_in;
    }
    
    //use the other program options to build it
    return Create_Proile_File_By_Building(x,target,profile_out);
❱


◀private: static▶ std::string ☀Create_Proile_File_By_Building(Build_Repo_Settings const& x, std::string const& target, std::string const& profile_out) ❰

    
    auto profile_file = Bazel_Runner::Get_Profile_Information(x.program_to_run_build,
                                                              x.build_settings,
                                                              x.bazel_setup_settings.config_settings,
                                                              target,
                                                              profile_out);
    return profile_file;
❱


