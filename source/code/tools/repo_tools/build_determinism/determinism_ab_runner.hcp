class
❪iostream❫
❪string❫
❪utility❫
❪thread❫
❪"code/utilities/printers/lib"❫
❪"code/utilities/bazel/bazel_runner"❫
❪"code/tools/repo_tools/build_determinism/data/spawn_pairings"❫
❪"code/tools/repo_tools/build_determinism/spawn_pairer"❫
❪"code/tools/repo_tools/build_determinism/spawn_pair_determinism_checker"❫
❪"code/tools/repo_tools/build_determinism/settings/settings"❫
❪"code/utilities/random/lib"❫
❪"code/utilities/shell/lib"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/types/strings/transformers/removing/lib"❫
❪"code/utilities/types/strings/observers/path/lib"❫
⚯
⚞⚟


◀public: static▶ Determinism_Pairings ☀Do_AB_Test(Settings const& settings) ❰
    
    //get pairings based on a specified concurrency model
    Spawn_Pairings pairings;
    if (settings.concurrency == Concurrency::SEQUENTIAL){
        pairings = Run_AB_Test_Sequentially(settings);
    }
    else {
        pairings = Run_AB_Test_In_Parallel(settings);
    }
    
    std::string pair_results_message = "subcommands: " + std::to_string(pairings.pairs.size()) + " matches " + std::to_string(pairings.unpaired1.size() + pairings.unpaired2.size()) + " non-matches";
    Maybe_Output_And_Flush_With_Newline(settings.verbose,pair_results_message);
    
    Maybe_Output_And_Flush_With_Newline(settings.verbose,"Finding nondeterminism across paired subcommands...");
    auto matches = Spawn_Pair_Determinism_Checker::Get_Nondeterminism_Matches(pairings);
    std::string determinism_matches_message = "matched subcommands: " + std::to_string(matches.deterministic.size()) + " deterministic " + std::to_string(matches.nondeterministic.size()) + " nondeterministic";
    Maybe_Output_And_Flush_With_Newline(settings.verbose,determinism_matches_message);
    
    return matches;
❱

◀private: static▶ Spawn_Pairings ☀Run_AB_Test_Sequentially(Settings const& settings) ❰

    Maybe_Output_And_Flush_With_Newline(settings.verbose,"(Test A) building target...");
    auto bazel_1 = Prepend_Path_To_Program_Execution_Unless_Global_Call(settings.bazel_wrapper.program_name,settings.a_path);
    auto spawns1 = Bazel_Runner::Get_Spawn_Information_As_Cmd_Map(bazel_1,settings.a_strategy,settings.target_name);
    
    Maybe_Output_And_Flush_With_Newline(settings.verbose,"(Test B) building target...");
    auto bazel_2 = Prepend_Path_To_Program_Execution_Unless_Global_Call(settings.bazel_wrapper.program_name,settings.b_path);
    auto spawns2 = Bazel_Runner::Get_Spawn_Information_As_Cmd_Map(settings.bazel_wrapper.program_name,settings.b_strategy,settings.target_name);
    
    Maybe_Output_And_Flush_With_Newline(settings.verbose,"Pairing together subcommands...");
    auto pairings = Spawn_Pairer::Build_Matches_And_Unpairable_Spawns(spawns1,spawns2);
    
    return pairings;
❱

◀private: static▶ Spawn_Pairings ☀Run_AB_Test_In_Parallel(Settings const& settings) ❰

    
    Maybe_Output_And_Flush_With_Newline(settings.verbose,"Building in parallel...");
    std::unordered_map<std::string,tools::protos::SpawnExec> spawns1;
    std::unordered_map<std::string,tools::protos::SpawnExec> spawns2;
    
    std::thread t1([&](){
        auto bazel_1 = Prepend_Path_To_Program_Execution_Unless_Global_Call(settings.bazel_wrapper.program_name,settings.a_path);
        spawns1 = Bazel_Runner::Get_Spawn_Information_As_Cmd_Map(bazel_1,settings.a_strategy,settings.target_name);
    });
    
    std::thread t2([&](){
        auto bazel_2 = Prepend_Path_To_Program_Execution_Unless_Global_Call(settings.bazel_wrapper.program_name,settings.b_path);
        spawns2 = Bazel_Runner::Get_Spawn_Information_As_Cmd_Map(bazel_2,settings.b_strategy,settings.target_name);
    });
    
    t1.join();
    t2.join();
    
    Maybe_Output_And_Flush_With_Newline(settings.verbose,"Pairing together subcommands...");
    auto pairings = Spawn_Pairer::Build_Matches_And_Unpairable_Spawns(spawns1,spawns2);
    
    return pairings;
    
❱