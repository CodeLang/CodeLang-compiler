class
❪"code/tools/repo_tools/build_determinism/settings/settings_getter"❫
❪"code/utilities/printers/lib"❫
❪"code/utilities/printers/prettyprint"❫
❪"code/utilities/git-related/repo_establisher/repo_establisher"❫
❪"code/utilities/bazel/wrapper/bazel_wrapper_deriver"❫
❪"code/tools/repo_tools/build_determinism/determinism_ab_runner"❫
❪"code/tools/repo_tools/build_determinism/reporter"❫
❪"code/tools/repo_tools/build_determinism/subcommand_filter"❫
❪"code/tools/repo_tools/build_determinism/determinism_problem_getter"❫
❪"code/utilities/random/lib"❫
❪"code/utilities/filesystem/files/observers/lstat_wrap/lib"❫
❪"code/utilities/bazel/bazel_runner"❫
❪"code/utilities/filesystem/files/moving/lib"❫
❪"code/tools/repo_tools/build_determinism/file_isolator"❫
❪"code/tools/repo_tools/build_determinism/environment_scan/environment_scan_results"❫
⚯
⚞⚟

◀public: static▶ void ☀Do_Multi_Environment_AB_Test(Settings settings) ❰
    
    Environment_Scan_Results results;
    
    for (size_t i = 0; i < settings.environment_scan; ++i){
        Maybe_Output_And_Flush_With_Newline(settings.verbose,"on iteration " + std::to_string(i));
        
        Maybe_Output_And_Flush_With_Newline(settings.verbose,"doing local/local test");
        {
            settings.a_strategy = Spawn_Strategy::LOCAL;
            settings.b_strategy = Spawn_Strategy::LOCAL;
            auto d_results = Determinism_Ab_Runner::Do_AB_Test(settings);
            if (d_results.nondeterministic.empty()){
                ++results.local_local.first;
            }
            else{
                ++results.local_local.second;
            }
        }
        
        Maybe_Output_And_Flush_With_Newline(settings.verbose,"doing remote/remote test");
        {
            settings.a_strategy = Spawn_Strategy::REMOTE;
            settings.b_strategy = Spawn_Strategy::REMOTE;
            auto d_results = Determinism_Ab_Runner::Do_AB_Test(settings);
            if (d_results.nondeterministic.empty()){
                ++results.remote_remote.first;
            }
            else{
                ++results.remote_remote.second;
            }
        }

        Maybe_Output_And_Flush_With_Newline(settings.verbose,"doing local/remote test");
        {
            settings.a_strategy = Spawn_Strategy::LOCAL;
            settings.b_strategy = Spawn_Strategy::REMOTE;
            auto d_results = Determinism_Ab_Runner::Do_AB_Test(settings);
            if (d_results.nondeterministic.empty()){
                ++results.local_remote.first;
            }
            else{
                ++results.local_remote.second;
            }
        }
    }
    
    //show results
    std::cout << "                 D  ND" << std::endl;
    std::cout << "LOCAL  | LOCAL  " << results.local_local << std::endl;
    std::cout << "REMOTE | REMOTE " << results.remote_remote << std::endl;
    std::cout << "LOCAL  | REMOTE " << results.local_remote << std::endl;
    
    //synthesize results
    
    //understanding local builds
    if (results.local_local.first > 0 && results.local_local.second == 0){
        std::cout << "building locally is always deterministic." << std::endl;
    }
    else if (results.local_local.first > 0 && results.local_local.second > 0){
        std::cout << "building locally is sometimes nondeterministic." << std::endl;
    }
    else if (results.local_local.first == 0 && results.local_local.second > 0){
        std::cout << "building locally is always nondeterministic." << std::endl;
    }
    
    //understanding remote builds
    if (results.remote_remote.first > 0 && results.remote_remote.second == 0){
        std::cout << "building remotely is always deterministic." << std::endl;
    }
    else if (results.remote_remote.first > 0 && results.remote_remote.second > 0){
        std::cout << "building remotely is sometimes nondeterministic." << std::endl;
    }
    else if (results.remote_remote.first == 0 && results.remote_remote.second > 0){
        std::cout << "building remotely is always nondeterministic." << std::endl;
    }
    
    //understanding differences between local/remote builds together
    if (results.local_local.first > 0 && results.local_local.second == 0){
        if (results.remote_remote.first > 0 && results.remote_remote.second == 0){
            if (results.local_remote.second > 0){
                std::cout << "local builds and remote builds are differently deterministic." << std::endl;
            }
        }
    }
❱