class
❪iostream❫
❪string❫
❪utility❫
❪set❫
❪"code/utilities/shell/lib"❫
❪"code/utilities/printers/prettyprint"❫
❪"code/utilities/printers/lib"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/bazel/bazel_runner"❫
❪"code/tools/repo_tools/build_determinism/program_options/program_options"❫
❪"code/tools/repo_tools/build_determinism/settings/settings_getter"❫
❪"src/main/protobuf/spawn.pb.h"❫
❪"code/utilities/serialization/protobuf"❫
❪"code/utilities/filesystem/files/getting/lib"❫
❪"code/utilities/git-related/lib"❫
❪"code/tools/repo_tools/build_determinism/data/spawn_pairings"❫
❪"code/tools/repo_tools/build_determinism/data/determinism_problem"❫
❪"code/utilities/types/map/lib"❫
❪"code/tools/repo_tools/build_determinism/spawn_pairer"❫
❪"code/tools/repo_tools/build_determinism/spawn_pair_determinism_checker"❫
❪"code/tools/repo_tools/build_determinism/determinism_ab_runner"❫
❪"code/tools/repo_tools/build_determinism/determinism_problem_getter"❫
⚯
⚞⚟


◀public: static▶ void ☀Execute_Needed_Tasks(Program_Options const& options) ❰

    //get the default settings modified by user's program options.
    auto settings = Settings_Getter::Get(options);
    
    //before starting the analysis, we clone or move into an existing repo.
    //either way this is done, we will end at the root of a repository.
    //NOTE: we want to avoid cloning the repo more than once from a branch as it may change.
    //for example, master would be changing frequently and me affect results.
    //so instead we use the same repository for the whole analysis.
    Maybe_Output_And_Flush_With_Newline(settings.verbose,"setting up repo...");
    Move_Into_Repo(settings);
    
    //try to derive the correct bazel program if its not known.
    if (settings.bazel_wrapper.derive){
        settings.bazel_wrapper.program_name = Derive_Program_Name(settings);
    }
    
    auto results = Determinism_Ab_Runner::Do_AB_Test(settings);
    
    //if the inputs are already nondeterministic there was probably nondeterminism further up the subcommand graph.
    //we should filter down to only the commands that had deterministic input but created nondeterministic output.
    //this will help us target where the nondeterminism actually starts and what tools are responsible.
    auto filtered_results = Filter_By_Subcommands_That_Cause_Nondeterminism(results.nondeterministic);
    
    //tell the user which programs we think are nondeterministic
    Report_Nondeterminisic_Programs(filtered_results);
    
    //tell the user the determinism problems
    Report_Nondeterminism_Problems(filtered_results);
    
    //give the user the subcommands that caused the problem
    //Report_Subcommand_That_Caused_Problems(filtered_results);
❱

◀private: static▶ void ☀Report_Nondeterminisic_Programs(std::vector<std::pair<tools::protos::SpawnExec,tools::protos::SpawnExec>> const& command_pairs)❰

    auto programs = Guess_Nondeterministic_Programs(command_pairs);
    if (programs.empty()){
        std::cout << "No programs were nondeterministic." << std::endl;
    }
    else{
        
        if (programs.size() == 1){
            std::cerr << "The following program was nondeterministic: ";
            std::string program_name = "";
            for (auto const& it: programs){
                program_name = it;
            }
            std::cerr << program_name;
            std::cerr << std::endl;
        }
        else{
            std::cerr << "The following programs were nondeterministic: ";
            std::cerr << programs;
            std::cerr << std::endl;
        }
    }
❱
◀private: static▶ void ☀Report_Nondeterminism_Problems(std::vector<std::pair<tools::protos::SpawnExec,tools::protos::SpawnExec>> const& command_pairs)❰

    for (auto const& it: command_pairs){
        auto problems = Determinism_Problem_Getter::Get(it);
        for (auto const& problem: problems){
            std::cerr << problem.message << std::endl;
        }
    }
❱

◀private: static▶ std::vector<std::pair<tools::protos::SpawnExec,tools::protos::SpawnExec>> ☀Filter_By_Subcommands_That_Cause_Nondeterminism(std::vector<std::pair<tools::protos::SpawnExec,tools::protos::SpawnExec>> const& command_pairs)❰
    std::vector<std::pair<tools::protos::SpawnExec,tools::protos::SpawnExec>> result;
    
    for (auto const& it: command_pairs){
        auto problems = Determinism_Problem_Getter::Get(it);
        if (Subcommand_Caused_Nondeterminsim(problems)){
            result.emplace_back(it);
        }
    }
    
    return result;
❱

◀private: static▶ bool ☀Subcommand_Caused_Nondeterminsim(std::vector<Determinism_Problem> const& problems)❰
    for (auto const& it: problems){
        if (it.type == Determinism_Problem_Type::INPUT_SIZE){
            return false;
        }
        if (it.type == Determinism_Problem_Type::MISSING_INPUT){
            return false;
        }
        if (it.type == Determinism_Problem_Type::WRONG_INPUT_HASH){
            return false;
        }
    }
    return true;
❱

◀private: static▶ std::set<std::string> ☀Guess_Nondeterministic_Programs(std::vector<std::pair<tools::protos::SpawnExec,tools::protos::SpawnExec>> const& command_pairs)❰
    std::set<std::string> programs;
    for (auto const& it: command_pairs){
        auto command_args = it.first.command_args();
        if (!command_args.empty()){
            programs.insert(command_args[0]);
        }
    }
    
    return programs;
❱

◀private: static▶ void ☀Move_Into_Repo(Settings const& settings) ❰

    if (settings.repo.use_clone){
        auto path_name = Download_Repo_To_Random_Name_In_Temp_Folder(settings.repo.clone_url);
        Set_Path(path_name);
    }
    
    //start in the appropriate directory
    Possibly_Set_Path(settings.repo.use_run_path,settings.repo.run_path);
❱

◀private: static▶ std::string ☀Derive_Program_Name(Settings const& settings) ❰
    auto program_name = First_Filename_Found_At_Current_Path(settings.bazel_wrapper.search_derive_programs);
    
    //use global installed bazel
    if (program_name.empty()){
        program_name = "bazel";
    }
    
    //use the local found bazel wrapper
    else{
        program_name = "./" + program_name;
    }
    
    return program_name;
❱