class
❪iostream❫
❪string❫
❪utility❫
❪"code/utilities/shell/lib"❫
❪"code/utilities/printers/prettyprint"❫
❪"code/utilities/printers/lib"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/bazel/bazel_runner"❫
❪"code/tools/repo_tools/build_determinism/program_options/program_options"❫
❪"code/tools/repo_tools/build_determinism/settings/settings_getter"❫
❪"src/main/protobuf/spawn.pb.h"❫
❪"code/utilities/serialization/protobuf"❫
❪"code/utilities/filesystem/files/getting/lib"❫
❪"code/utilities/git-related/lib"❫
❪"code/tools/repo_tools/build_determinism/data/spawn_pairings"❫
❪"code/utilities/types/map/lib"❫
❪"code/tools/repo_tools/build_determinism/spawn_pairer"❫
⚯
⚞⚟


◀public: static▶ void ☀Execute_Needed_Tasks(Program_Options const& options) ❰

    //get the default settings modified by user's program options.
    auto settings = Settings_Getter::Get(options);
    
    //we might clone or move into an existing folder.
    //either way, we will be at the root of the repository.
    Maybe_Output_And_Flush_With_Newline(settings.verbose,"cloning repo...");
    Move_Into_Repo(settings);
    
    //try to derive the correct bazel program if its not known.
    if (settings.bazel_wrapper.derive){
        settings.bazel_wrapper.program_name = Derive_Program_Name(settings);
    }
    
    Maybe_Output_And_Flush_With_Newline(settings.verbose,"building target...");
    auto spawns1 = Bazel_Runner::Get_Spawn_Information_As_Cmd_Map(settings.bazel_wrapper.program_name,settings.target_name);
    
    Maybe_Output_And_Flush_With_Newline(settings.verbose,"building target...");
    auto spawns2 = Bazel_Runner::Get_Spawn_Information_As_Cmd_Map(settings.bazel_wrapper.program_name,settings.target_name);
    
    //initial sanity check
    if (spawns1.size() == spawns2.size()){
        std::cout << "same number of spawned commands (" << spawns1.size() << ")" << std::endl;
    }
    else{
        std::cerr << "different number of spawned actions (" << spawns1.size() << " != " << spawns2.size() << ")" << std::endl;
    }
    
    auto pairings = Spawn_Pairer::Build_Matches_And_Unpairable_Spawns(spawns1,spawns2);
    std::cout << pairings.pairs.size() << " matches" << std::endl;
    
    auto nondeterminisim_matches = Get_Nondeterminism_Matches(pairings);
    std::cout << nondeterminisim_matches.size() << " nondeterminisim commands" << std::endl;
    
    
    
    // for (auto & spawn: spawns){
    //     for (auto & it: *spawn.mutable_inputs()){
    //         std::cout << *it.mutable_digest()->mutable_hash() << std::endl;
    //     }
    // }
❱

◀private: static▶ std::vector<std::pair<tools::protos::SpawnExec,tools::protos::SpawnExec>> ☀Get_Nondeterminism_Matches(Spawn_Pairings const& pairings)❰

    std::vector<std::pair<tools::protos::SpawnExec,tools::protos::SpawnExec>> results;
    for (auto const& it: pairings.pairs){
        if (!File_Hash_Nondeterminism(it)){
            results.emplace_back(it);
        }
    }
    
    return results;
❱

◀private: static▶ bool ☀File_Hash_Nondeterminism(std::pair<tools::protos::SpawnExec,tools::protos::SpawnExec> const& match)❰

    auto s1_input_set = Get_Input_Map(match.first);
    auto s1_output_set = Get_Output_Map(match.first);
    auto s2_input_set = Get_Input_Map(match.second);
    auto s2_output_set = Get_Output_Map(match.second);
    
    if (s1_input_set.size() != s2_input_set.size()){
        std::cerr << "wrong input size" << std::endl;
        return false;
    }
    
    if (s1_output_set.size() != s2_output_set.size()){
        std::cerr << "wrong output size" << std::endl;
        return false;
    }
    
    for (auto const& it: s1_input_set){
        auto find = s2_input_set.find(it.first);
        if (find == s2_input_set.end()){
            std::cerr << "input missing across runs" << std::endl;
            return false;
        }
        
        if (it.second.hash() != find->second.hash()){
            std::cerr << "input hashes don't match" << std::endl;
            return false;
        }
    }
    
    for (auto const& it: s1_output_set){
        auto find = s2_output_set.find(it.first);
        if (find == s2_output_set.end()){
            std::cerr << "output missing across runs" << std::endl;
            return false;
        }
        
        if (it.second.hash() != find->second.hash()){
            std::cerr << "output hashes don't match" << std::endl;
            return false;
        }
    }

    return true;
❱

◀private: static▶ std::map<std::string,tools::protos::Digest> ☀Get_Input_Map(tools::protos::SpawnExec const& s)❰
    std::map<std::string,tools::protos::Digest> m;
    for (auto & it: s.inputs()){
        m.insert({it.path(),it.digest()});
    }
    return m;
❱
◀private: static▶ std::map<std::string,tools::protos::Digest> ☀Get_Output_Map(tools::protos::SpawnExec const& s)❰
    std::map<std::string,tools::protos::Digest> m;
    for (auto & it: s.actual_outputs()){
        m.insert({it.path(),it.digest()});
    }
    return m;
❱


◀private: static▶ void ☀Move_Into_Repo(Settings const& settings) ❰

    if (settings.repo.use_clone){
        auto path_name = Download_Repo_To_Random_Name_In_Temp_Folder(settings.repo.clone_url);
        Set_Path(path_name);
    }
    
    //start in the appropriate directory
    Possibly_Set_Path(settings.repo.use_run_path,settings.repo.run_path);
❱

◀private: static▶ std::string ☀Derive_Program_Name(Settings const& settings) ❰
    auto program_name = First_Filename_Found_At_Current_Path(settings.bazel_wrapper.search_derive_programs);
    
    //use global installed bazel
    if (program_name.empty()){
        program_name = "bazel";
    }
    
    //use the local found bazel wrapper
    else{
        program_name = "./" + program_name;
    }
    
    return program_name;
❱