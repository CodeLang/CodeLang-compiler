class
❪"code/tools/repo_tools/build_determinism/settings/settings_getter"❫
❪"code/utilities/printers/lib"❫
❪"code/utilities/printers/prettyprint"❫
❪"code/utilities/git-related/repo_establisher/repo_establisher"❫
❪"code/utilities/bazel/wrapper/bazel_wrapper_deriver"❫
❪"code/utilities/bazel/config/bazel_config_deriver"❫
❪"code/tools/repo_tools/build_determinism/determinism_ab_runner"❫
❪"code/tools/repo_tools/build_determinism/reporter"❫
❪"code/tools/repo_tools/build_determinism/subcommand_filter"❫
❪"code/tools/repo_tools/build_determinism/determinism_problem_getter"❫
❪"code/utilities/random/lib"❫
❪"code/utilities/filesystem/files/observers/lstat_wrap/lib"❫
❪"code/utilities/bazel/bazel_runner"❫
❪"code/utilities/filesystem/files/moving/lib"❫
❪"code/tools/repo_tools/build_determinism/file_isolator"❫
❪"code/tools/repo_tools/build_determinism/scans/scan_results"❫
⚯
❪"code/tools/repo_tools/build_determinism/scans/environment_scan/environment_scanner"❫
❪"code/tools/repo_tools/build_determinism/scans/augment_scan/augment_scanner"❫
❪"code/tools/repo_tools/build_determinism/scan_utilities"❫
⚞⚟


//OTHER NOTES:
//other articles about build determinism:
//https://www.chromium.org/developers/testing/isolated-testing/deterministic-builds
//http://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html
//http://planet.clang.org/
//http://lists.llvm.org/pipermail/llvm-dev/2017-July/115196.html
//https://github.com/mgrang/non-determinism
//https://blog.conan.io/2019/09/02/Deterministic-builds-with-C-C++.html
//http://blog.mindfab.net/2013/12/on-way-to-deterministic-binariy-gcc.html


//filenames in object files.  why?
//https://stackoverflow.com/questions/32413176/why-do-common-c-compilers-include-the-source-filename-in-the-output
//https://stackoverflow.com/questions/32400931/why-dont-two-binaries-of-programs-with-only-comments-changed-exactly-match-in-g/32401320#32401320
//https://www.technovelty.org/linux/stripping-shared-libraries.html


◀public: static▶ void ☀Execute_Needed_Tasks(Program_Options const& options) ❰

    //get the default settings modified by user's program options.
    auto settings = Settings_Getter::Get(options);
    
    //this will decide which directories to do the analysis in.
    //it might clone and copy folders, it might use existing paths given by the user.
    Setup_Workspace(settings);
    
    //try to derive the correct bazel program if its not known.
    Bazel_Wrapper_Deriver::Possibly_Derive_Bazel_Runner(settings.bazel_wrapper,settings.a_path);
    
    //try to derive the correct bazel configs to use for the environments
    Bazel_Config_Deriver::Possibly_Derive_Bazel_Config_Settings(settings.config_settings,settings.a_path);
    
    //at this point we have the directories we want to operate in, and knowledge of how to run bazel within them.
    //we move onto doing some kind of analysis.
    
    auto scan_results = Perform_Requested_Scans(settings);
    Print_Needed_Scan_Info(settings,scan_results);
    
    if (settings.default_diagnosis){
        Do_Regular_AB_Test(settings);
    }
❱

◀private: static▶ Scan_Results ☀Perform_Requested_Scans(Settings const& settings)❰

    Scan_Results results;
    if (settings.environment_scan != 0){
        results.environment_scan_performed = true;
        results.environment = Environment_Scanner::Do_Multi_Environment_AB_Test(settings);
    }
    if (settings.augmented_scan != 0){
        results.augment_scan_performed = true;
        results.augment = Augment_Scanner::Do_Multi_Environment_AB_Test(settings);
    }
    return results;
❱

◀private: static▶ void ☀Print_Needed_Scan_Info(Settings const& settings, Scan_Results const& results)❰
❱


◀private: static▶ std::string ☀Get_Printable_Results(Environment_Scan_Results const& results)❰

    std::string x;
    
    //show results
    Append_With_Newline       (x,"                 D  ND");
    Scan_Utilities::Append_Row(x,"LOCAL  | LOCAL  ",results.local_local);
    Scan_Utilities::Append_Row(x,"REMOTE | REMOTE ",results.remote_remote);
    Scan_Utilities::Append_Row(x,"LOCAL  | REMOTE ",results.local_remote);
    
    //synthesize results
    
    //understanding local builds
    Append_With_Newline_Unless_Empty(x,Scan_Utilities::Express_Determinism_Of_Action("building locally",results.local_local));
    Append_With_Newline_Unless_Empty(x,Scan_Utilities::Express_Determinism_Of_Action("building remotely",results.remote_remote));
    Append_With_Newline_Unless_Empty(x,Scan_Utilities::Express_Determinism_Of_Mixed_Actions("local builds and remote builds",results.local_local,results.remote_remote,results.local_remote));
    
    return x;
❱
◀private: static▶ std::string ☀Get_Printable_Results(Augment_Scan_Results const& results)❰

    std::string x;
    
    //show results
    Append_With_Newline       (x,"                          D  ND");
    Scan_Utilities::Append_Row(x,"STANDALONE  | STANDALONE ",results.standalone_standalone);
    Scan_Utilities::Append_Row(x,"SANDBOX     | SANDBOX    ",results.sandbox_sandbox);
    Scan_Utilities::Append_Row(x,"STANDALONE  | SANDBOX    ",results.standalone_sandbox);
    
    //synthesize results
    
    Append_With_Newline_Unless_Empty(x,Scan_Utilities::Express_Determinism_Of_Action("building outside sandbox",results.standalone_standalone));
    Append_With_Newline_Unless_Empty(x,Scan_Utilities::Express_Determinism_Of_Action("building with sandbox",results.sandbox_sandbox));
    Append_With_Newline_Unless_Empty(x,Scan_Utilities::Express_Determinism_Of_Mixed_Actions("building with and without sandbox",results.standalone_standalone,results.sandbox_sandbox,results.standalone_sandbox));
    
    return x;
❱




◀private: static▶ void ☀Setup_Workspace(Settings & settings) ❰

    //before starting the analysis, we either clone or move into an existing repo.
    //This is chosen by the user and regardless of their choice, we will end up at the root of a repository.
    //NOTE: we want to avoid cloning the repo more than once from a branch as the branch may change.
    //for example, master would be changing frequently and me affect results.
    //so instead we use the same repository for the whole analysis.
    Maybe_Output_And_Flush_With_Newline(settings.verbose,"setting up repo...");
    settings.a_path = Repo_Establisher::Establish_And_Get_Path(settings.repo);
    if (settings.concurrency == Concurrency::SEQUENTIAL){
        settings.b_path = settings.a_path;
    }
    else {
        Maybe_Output_And_Flush_With_Newline(settings.verbose,"duplicating folder...");
        settings.b_path = Random_Tmp_Directory();
        Copy_File_To_Dir(settings.a_path,settings.b_path);
    }
    
    Maybe_Output_And_Flush_With_Newline(settings.verbose,"A test folder established: " + settings.a_path);
    Maybe_Output_And_Flush_With_Newline(settings.verbose,"B test folder established: " + settings.b_path);
❱

◀private: static▶ void ☀Do_Regular_AB_Test(Settings const& settings) ❰

    //Perform the AB test and get back results.
    auto results = Determinism_Ab_Runner::Do_AB_Test(settings);
    
    //Analyze the results for the user.
    Reporter::Report(results,settings.report);
    
    //Isolate the problem files.
    File_Isolator::Attempt_To_Isolate_Nondeterministic_Files(results,settings);
❱

