class
❪iostream❫
❪string❫
❪utility❫
❪"code/tools/repo_tools/build_third_party_lib/program_options/program_options"❫
❪"code/utilities/build/profiler/data/profile_settings"❫
❪"code/utilities/build/profiler/data/profile_results"❫
⚯
❪"code/utilities/program/wrappers/git/branch_switcher"❫
❪"code/utilities/types/vectors/converters/lib"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/build/profiler/branch_profile_compilation_timer"❫
❪"code/utilities/math/math"❫
❪"code/utilities/output/printers/lib"❫
❪"code/utilities/types/converters/lib"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/build/build_repo_establisher/build_repo_establisher"❫
❪"code/utilities/program/wrappers/bazel/query/bazel_query_runner"❫
⚞⚟


◀public: static▶ void ☀Execute_Needed_Tasks(Program_Options const& options) ❰

    //We establish a repo and a context for building artifacts in it.
    //This setup tries to be agnostic to any expectations about the repo's hosting, layout, and build system.
    //It tries to derive things like:
    //where/how the repository is cloned from, what branch it should be on or whether the repo already exists on the system.
    //Analyze the repository to learn how to build it
    auto repo_context = Build_Repo_Establisher::Establish_Repo_For_Building(options.Run_Dir(),options.Url(),options.Branch());
    
    auto deps = Bazel_Query_Runner::Get_All_Self_Third_Party_Deps(repo_context.program_to_run_build,options.Target());
    Remove_Targets_That_Look_Like_Direct_Files(deps);
    
    for (auto const& it: deps){
        std::cout << it << std::endl;
    }
    
❱

◀private: static▶ void ☀Remove_Targets_That_Look_Like_Direct_Files(std::vector<std::string> & deps) ❰

    //filter out targets that look like direct c++ files
    Remove_If(deps ,[&](std::string s){
        return Ends_With(s,".h") || Ends_With(s,".hh") || Ends_With(s,".hpp") || Ends_With(s,".cpp") || Ends_With(s,".cc") || Ends_With(s,".c");
    });
    
    //filter out targets that look like direct cuda files
    Remove_If(deps ,[&](std::string s){
        return Ends_With(s,".cu") || Ends_With(s,".cuh");
    });
    
    //filter out targets that look like direct python files
    Remove_If(deps ,[&](std::string s){
        return Ends_With(s,".py");
    });
    
    //filter out targets that look like direct config files
    Remove_If(deps ,[&](std::string s){
        return Ends_With(s,".yaml") || Ends_With(s,".in");
    });
    
    Remove_If(deps ,[&](std::string s){
        return Contains_Substring(s,".");
    });
❱