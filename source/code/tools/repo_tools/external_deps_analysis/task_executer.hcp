class
❪iostream❫
❪string❫
❪utility❫
❪"code/utilities/shell/lib"❫
❪"code/utilities/printers/prettyprint"❫
❪"code/tools/repo_tools/external_deps_analysis/settings/settings"❫
❪"code/tools/repo_tools/external_deps_analysis/analysis_state"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/types/vectors/transformers/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/types/strings/transformers/removing/lib"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
❪"code/utilities/types/sets/lib"❫
❪"code/utilities/graphviz/graphviz_image_maker"❫
❪"code/tools/repo_tools/external_deps_analysis/program_options/program_options"❫
❪"code/tools/repo_tools/external_deps_analysis/settings/settings_getter"❫
⚯
❪"code/utilities/bazel/bazel_runner"❫
⚞⚟


◀public: static▶ void ☀Execute_Needed_Tasks(Program_Options const& options) ❰

    auto settings = Settings_Getter::Get(options);
    
    Possibly_Set_Path(settings.use_run_path,settings.run_path);
    
    //start the analysis at a particular dependency
    Analysis_State state;
    state.deps_to_explore.push(settings.dep_name);
    
    //build all the relationships
    while (!state.deps_to_explore.empty()){
        
        //since we are now exploring this dependency, remove it from the queue
        auto dep = Pop_Front(state.deps_to_explore);
        
        
        //if we haven't yet explored this dependency do so, and add it to the set so we don't do it again
        if (!Exists_In_Set(state.dep_explored,dep)){
            state.dep_explored.insert(dep);
            
            Verbose_Querying_Message(settings,dep);
            Explore_The_Direct_Relationships(settings,state,dep);
        }
    }
    
    //remove cycles
    Remove_If(state.relationships,[&](std::pair<std::string,std::string> p){
        return p.first == p.second;
    });
    
    Output_Graphviz_Info(settings,state);
❱

◀private: static▶ void ☀Verbose_Querying_Message(Settings const& settings, std::string const& dep)❰
    if (settings.verbose){
        std::cout << "querying " << dep << "... ";
        std::cout.flush();
    }
❱
◀private: static▶ void ☀Verbose_Direct_Dependencies_Message(Settings const& settings, std::vector<std::string> const& results)❰
    if (settings.verbose){
        std::cout << results << std::endl;
    }
❱

◀private: static▶ void ☀Output_Graphviz_Info(Settings const& settings, Analysis_State const& state)❰

    std::vector<std::string> relationships_strs;
    for (auto const& it: state.relationships){
        std::string line = "";
        line += "\"";
        line += it.first;
        line += "\"";
        line += " -> ";
        line += "\"";
        line += it.second;
        line += "\"";
        relationships_strs.emplace_back(line);
    }
    
    std::string x;
    Append_With_Newline(x,"digraph results {");
    //Append_With_Newline(x,"splines=false;");
    Append_With_Newline(x,"node [");
    Append_With_Newline(x,"fontname=\"Arial\",");
    //Append_With_Newline(x,"shape = plaintext,");
    Append_With_Newline(x,"height=.1");
    Append_With_Newline(x,"]");
    for (auto const& it: relationships_strs){
        Append_With_Newline(x,it);
    }
    Append_With_Newline(x,"}");
    Graphviz_Image_Maker::Make(x,settings.result_path,settings.dep_name);
❱

◀private: static▶ void ☀Explore_The_Direct_Relationships(Settings const& settings, Analysis_State & state, std::string const& dep)❰

    //bazel query to get direct 3rd party dependencies
    auto results = Bazel_Runner::Get_Direct_Dependencies(settings.bazel_wrapper,dep);
    
    Verbose_Direct_Dependencies_Message(settings,results);
    
    //add relationships
    for (auto const& it: results){state.relationships.emplace_back(dep,it);}
    
    //add deps to explore
    for (auto const& it: results){state.deps_to_explore.push(it);}
❱

◀private: static▶ std::string ☀Pop_Front(std::queue<std::string> & q)❰
    std::string str = q.front();
    q.pop();
    return str;
❱
