class
❪iostream❫
❪string❫
❪set❫
❪utility❫
❪memory❫
❪grpcpp/grpcpp.h❫
❪grpcpp/health_check_service_interface.h❫
❪grpcpp/ext/proto_server_reflection_plugin.h❫
❪"build/bazel/remote/execution/v2/remote_execution.grpc.pb.h"❫
❪"code/utilities/formats/serialization/protobuf"❫
❪"code/tools/repo_tools/remote_execution/server/server_settings"❫
❪"code/utilities/remote_execution/services/grpc_glue"❫
⚯
⚞⚟

◀public: static▶ void ☀BuildAndRun(Server_Settings const& settings)❰

  //setup grpc
  grpc::EnableDefaultHealthCheckService(settings.enable_default_health_check_service);
  grpc::reflection::InitProtoReflectionServerBuilderPlugin();
  
  
  grpc::ServerBuilder builder;
  //auto channel_creds = grpc::SslCredentials(grpc::SslCredentialsOptions());
  
  
 // grpc::SslServerCredentialsOptions sslServerOptions;
 // grpc::SslServerCredentialsOptions::PemKeyCertPair pkcp;
 // pkcp.private_key = "";
 // pkcp.cert_chain  = "";
 // sslServerOptions.pem_key_cert_pairs.push_back( pkcp );
 // sslServerOptions.pem_root_certs = "";
 // grpc::SslServerCredentials( sslServerOptions );
 
  builder.AddListeningPort(settings.address, grpc::InsecureServerCredentials());
  
  //add all of the individual services from the proto definitions
  ExecutionService execution_service(
  [](grpc::ServerContext* context, const build::bazel::remote::execution::v2::ExecuteRequest* request, grpc::ServerWriter<google::longrunning::Operation>* writer){
    return grpc::Status::OK;
  },
  [](grpc::ServerContext* context, const build::bazel::remote::execution::v2::WaitExecutionRequest* request, grpc::ServerWriter<google::longrunning::Operation>* writer){
    return grpc::Status::OK;
  }
  );
  
  ActionCacheService action_cache_service(
  [](grpc::ServerContext* context, const build::bazel::remote::execution::v2::GetActionResultRequest* request, build::bazel::remote::execution::v2::ActionResult* response){
    return grpc::Status::OK;
  },
  [](grpc::ServerContext* context, const build::bazel::remote::execution::v2::UpdateActionResultRequest* request, build::bazel::remote::execution::v2::ActionResult* response){
    return grpc::Status::OK;
  }
  );
  
  ContentAddressableStorageService content_addressable_storage_service(
  [](grpc::ServerContext* context, const build::bazel::remote::execution::v2::FindMissingBlobsRequest* request, build::bazel::remote::execution::v2::FindMissingBlobsResponse* response){
    return grpc::Status::OK;
  },
  [](grpc::ServerContext* context, const build::bazel::remote::execution::v2::BatchUpdateBlobsRequest* request, build::bazel::remote::execution::v2::BatchUpdateBlobsResponse* response){
    return grpc::Status::OK;
  },
  [](grpc::ServerContext* context, const build::bazel::remote::execution::v2::BatchReadBlobsRequest* request, build::bazel::remote::execution::v2::BatchReadBlobsResponse* response){
    return grpc::Status::OK;
  },
  [](grpc::ServerContext* context, const build::bazel::remote::execution::v2::GetTreeRequest* request, grpc::ServerWriter< build::bazel::remote::execution::v2::GetTreeResponse>* writer){
    return grpc::Status::OK;
  }
  );
  
  CapabilitiesService capabilities_service(
  [](grpc::ServerContext* context, const build::bazel::remote::execution::v2::GetCapabilitiesRequest* request, build::bazel::remote::execution::v2::ServerCapabilities* response){
        std::cout << Protobuf_Message_To_Json(*request) << std::endl;
        return grpc::Status::OK;
  });
  
  builder.RegisterService(&execution_service);
  builder.RegisterService(&action_cache_service);
  builder.RegisterService(&content_addressable_storage_service);
  builder.RegisterService(&capabilities_service);
  
  
  // Finally assemble the server.
  std::unique_ptr<grpc::Server> server(builder.BuildAndStart());
  
  std::cout << "Server listening on " << settings.address << std::endl;

  // Wait for the server to shutdown. Note that some other thread must be
  // responsible for shutting down the server for this call to ever return.
  server->Wait();
  
  return;
❱


◀private: static▶ build::bazel::remote::execution::v2::CacheCapabilities ☀Get_Cache_Capabilities(Server_Settings const& settings)❰
  build::bazel::remote::execution::v2::CacheCapabilities x;
  x.add_digest_function(build::bazel::remote::execution::v2::DigestFunction_Value_SHA256);
  
  return x;
❱

