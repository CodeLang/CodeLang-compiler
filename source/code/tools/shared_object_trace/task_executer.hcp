class
❪iostream❫
❪string❫
❪utility❫
❪"code/tools/shared_object_trace/program_options/program_options"❫
❪"code/utilities/filesystem/files/getting/lib"❫
❪"code/utilities/filesystem/files/observers/other/lib"❫
❪"code/tools/shared_object_trace/file_and_type"❫
❪"code/utilities/filesystem/files/observers/other/file_and_ldd_results"❫
❪"code/utilities/filesystem/files/observers/other/ldd_results_getter"❫
⚯
❪"code/utilities/exits/lib"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/filesystem/files/getting/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/types/vectors/transformers/lib"❫
⚞⚟


◀public: static▶ void ☀Execute_Needed_Tasks(Program_Options const& options) ❰

    //cli verify
    if (options.Run_Dir().empty()){
        Exit_With_Error("provide path to external dir");
    }
    if (options.Dep().empty()){
        Exit_With_Error("pass a third party dep name");
    }
    
    //move into external dir of bazel repo
    Set_Path(options.Run_Dir());
    
    //get all the shared library files from this third party dependency
    //auto sos = Get_Shared_Objects(options.Dep());
    
    
    auto dirs = Get_Other_External_Paths(options.Dep());
    for (auto dir: dirs){
        std::cout << dir << std::endl;
        auto ldd_results = Ldd_Results_From_Dir(dir);
        for (x: ldd_results){
        }
        //std::cout << ldd_results << std::endl;
    }
    
    
❱



◀private: static▶ std::vector<File_And_Ldd_Results> ☀Ldd_Results_From_Dir(std::string const& dir)❰
    std::vector<File_And_Ldd_Results> results;
    auto files = Recursively_Get_All_Paths_To_Files_From_Path(dir);
    for (auto const& it: files){
        auto ldd_results = Ldd_Results_Getter::Get(it);
        
        if (ldd_results.results.valid){
            results.emplace_back(ldd_results);
        }
    }
    return results;
❱



◀private: static▶ std::vector<File_And_Type> ☀Get_Shared_Objects(std::string dep)❰

    std::string identifier_for_shared_object = "shared object";
    
    auto files = Recursively_Get_All_Paths_To_Files_From_Path(dep);
    std::vector<File_And_Type> results;
    
    for (auto const& it: files){
        auto type = Type_Of_File(it);
        if (Contains_Substring(type,identifier_for_shared_object)){
            File_And_Type x;
            x.file = it;
            x.type = type;
            results.emplace_back(x);
        }
    }
    return results;
❱

◀private: static▶ std::vector<std::string> ☀Get_Other_External_Paths(std::string dep)❰

    std::vector<std::string> paths;
    
    auto dirs = Get_Dirs_Of_Path();
    for (auto dir: Get_Dirs_Of_Path()){
        if (dir != dep){
            paths.emplace_back(dir);
        }
    }
    
    Sort_And_Remove_Duplicates(paths);
    
    return paths;
❱