class
❪vector❫
❪string❫
❪unordered_map❫
❪fstream❫
❪"code/tools/transcompilers/hcp-compiler/programatic/data/function"❫
❪"code/utilities/data_structures/tree/generic/string_tree"❫
❪"code/utilities/data_structures/tree/generic/string_to_string_tree"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
⚯
❪"code/tools/transcompilers/hcp-compiler/programatic/data/code"❫
❪"code/tools/transcompilers/hcp-compiler/programatic/code_getter"❫
❪"code/utilities/types/strings/transformers/wrap/lib"❫
❪"code/utilities/streams/filestreams/read_all/lib"❫
❪"code/utilities/types/strings/transformers/removing/lib"❫
❪"code/utilities/types/vectors/transformers/lib"❫
❪"code/utilities/types/strings/transformers/casing/case_modifier"❫
❪"code/utilities/types/tree/shortest_unique_name"❫
❪"code/utilities/types/tree/converters/tree_full_paths_getter"❫
❪"code/utilities/types/tree/children_path_names"❫
❪"code/utilities/types/strings/transformers/search_replace/lib"❫
❪"code/utilities/types/strings/observers/characteristic/is_cpp_keyword_checker"❫
❪"code/tools/transcompilers/tree_hcp/shared/path_naming"❫
⚞⚟

◀public: static▶ void ☀Create(std::string const& input_file, std::string const& path_without_extension)❰

    auto all_text = Read_Entire_File_Into_String(input_file);
    auto str_tree = String_To_String_Tree::Convert(all_text);
    
    Create_Header(str_tree,path_without_extension);
    Create_Source(str_tree,path_without_extension);
❱

◀private: static▶ void ☀Create_Header(String_Tree const& str_tree, std::string const& path_without_extension)❰
    std::string filename = path_without_extension + ".hpp";
    std::ofstream outfile(filename);
    outfile << "#pragma once" << std::endl;
    outfile << "#include <vector>" << std::endl;
    outfile << "#include <string>" << std::endl;
    outfile << "#include " << As_Wrapped_In_Double_Quotes("src/tree.hh") << std::endl;
    outfile << std::endl;
    
    outfile << "namespace model {\n";
    
    
    outfile << "//forward declares" << std::endl;
    auto full_paths = Tree_Full_Paths_Getter::Get_All_Paths_Ordered(str_tree);
    for (auto const& it: full_paths){
        outfile << Create_Forward_Declare(str_tree,it);
    }
    
    outfile << "//decelerations" << std::endl;
    for (auto const& it: full_paths){
        outfile << Create_Struct_Definition(str_tree,it);
    }
    
    outfile << "} //namespace: model\n";
❱
◀private: static▶ std::string ☀Create_Forward_Declare(String_Tree const& str_tree, std::string const& full_path)❰

    std::string x;
    //x += "template <typename T> ";
    x += "struct " + Path_Naming::Get_Struct_Typename(str_tree,full_path) + ";\n";
    return x;
❱
◀private: static▶ std::string ☀Create_Struct_Definition(String_Tree const& str_tree, std::string const& full_path)❰
    std::string x;
    //x += "template <typename T> ";
    x += "struct " + Path_Naming::Get_Struct_Typename(str_tree,full_path) + "{\n";
        auto children = Children_Path_Names::Get_All_Children_Names(str_tree,full_path);
        for (auto const& it: children){
            //x += "    std::vector<" + Path_Naming::Get_Struct_Typename(str_tree,it) + "<T>> " + Path_Naming::Get_Struct_Identifier(str_tree,it) + ";\n";
            x += "    std::vector<" + Path_Naming::Get_Struct_Typename(str_tree,it) + "> " + Path_Naming::Get_Struct_Identifier(str_tree,it) + ";\n";
        }
        
        //add a pointer back to the visual tree node
        //x += "    tree<std::string>::pre_order_iterator nodePtr;\n";
        
        //a unique string to re-identify the element in the tree
        //x += "    std::string tree_id;\n";
        
        //index of a pre-order
        x += "    int tree_id;\n";
        
        //if child leaf
        if (children.empty()){
            x += "    std::string value;\n";
        }
        
        
    x += "};\n\n";
    return x;
❱

◀private: static▶ void ☀Create_Source(String_Tree const& str_tree, std::string const& path_without_extension)❰
    std::ofstream outfile(path_without_extension + ".cpp");
    outfile << "#include ";
    outfile << '"';
    outfile << path_without_extension << ".hpp";
    outfile << '"';
    outfile << std::endl;
    outfile.close();
❱