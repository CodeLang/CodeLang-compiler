class
❪iostream❫
❪cstdlib❫
❪thread❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/program/call/lib.hpp"❫
❪"code/utilities/program/call/process_spawn/process_spawner"❫
❪"code/utilities/time/sleeping/lib"❫
⚯
❪"code/utilities/program/wrappers/sendmail/sendmail_sender"❫
❪"code/utilities/program/wrappers/sendmail/sendmail_settings"❫
❪"code/utilities/program/wrappers/sendmail/sendmail_settings_getter"❫
❪"code/utilities/program/wrappers/sendmail/ssmtp_conf_maker"❫
❪"code/utilities/build/self_builder"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
⚞⚟

◀public: static▶ void ☀Run() ❰
    
    
    while (true) {
        
        Move_To_Repo_Root();
        std::string results;
        Fresh_Pull(results);
        Record_Working_Hash(results);
        Run_Repo_Tasks(results);
        Possibly_Restart_Self(results);
        
    }
❱

◀private: static▶ void ☀Fresh_Pull(std::string & results) ❰

    auto x = Run_Command_And_Show("git reset --hard HEAD && git clean -d -f;");
    x = Run_Command_And_Show("git pull");
    
    if (x.return_code != 0){
        Append_With_Newline(results,"pull: FAIL");
        Append_With_Newline(results,x.stderr);
    }
❱
◀private: static▶ void ☀Record_Working_Hash(std::string & results) ❰

    auto x = Run_Command_And_Show("git rev-parse HEAD");
    Append_With_Newline(results,"commit: " + x.stdout);
❱
◀private: static▶ void ☀Run_Repo_Tasks(std::string & results) ❰
    auto x = Self_Builder::Get_Results_Of_Building_Through_Docker_Container();
    if (x.return_code == 0){
        Append_With_Newline(results,"docker build: PASS");
    }
    else {
        Append_With_Newline(results,"docker build: FAIL");
        Append_With_Newline(results,x.stderr);
    }
❱
◀private: static▶ void ☀Possibly_Restart_Self(std::string & results) ❰
    auto x = Run_Command_And_Show("./user_build //code/tools/worker_bot:main");
    if (x.return_code == 0){
        Append_With_Newline(results,"rebuild worker: PASS");
    }
    else {
        Append_With_Newline(results,"rebuild worker: FAIL");
        Append_With_Newline(results,x.stderr);
    }
    
    int duration = 4;
    
    //send email
    Send_Email_Status(results);
    Sleep_For_N_Hours(duration);
    
    //decide whether to restart
    //a wrapper script will restart the worker
    if (x.return_code == 0){
        exit(0);
    }
❱


◀private: static▶ void ☀Send_Email_Status(std::string & results) ❰

    Ssmtp_Conf_Maker::Setup_File();
    auto sendmail_settings = Sendmail_Settings_Getter::Test_Settings();
    sendmail_settings.title = "Worker Bot Results";
    sendmail_settings.message = "These are the results of our recent runs:";
    sendmail_settings.message += results;
    Sendmail_Sender::Send(sendmail_settings);
    std::cout << "sleeping then exiting" << std::endl;
❱
◀private: static▶ Process_Results ☀Run_Command_And_Show(std::string command) ❰
        std::cout << command << std::endl;
        auto results = Process_Spawner::Execute_And_Get_Back_Results(command);
        if (!results.stdout.empty()){
            std::cout << results.stdout << std::endl;
        }
        if (!results.stderr.empty()){
            std::cout << results.stderr << std::endl;
        }
        return results;
❱