class

❪fstream❫
❪iostream❫
❪"code/transcompilers/unilang/structure/model/structure"❫
❪"code/transcompilers/unilang/contributor/contributor"❫
❪"code/transcompilers/unilang/structure/model/inlined_structures"❫
❪"code/transcompilers/unilang/options/language-specific/markdown/markdown_settings"❫
⚯
❪"code/utilities/types/strings/transformers/appending/lib"❫
❪"code/utilities/converters/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/transcompilers/unilang/structure-printer/struct_derivers"❫
❪"code/utilities/types/strings/transformers/casing/case_modifier"❫
❪"code/utilities/shell/lib"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/transcompilers/unilang/options/manipulation/case_adjustment_settings"❫
❪"code/transcompilers/unilang/structure/adjust/casing_adjuster"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/transcompilers/unilang/structure/adjust/structure_adjuster"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/types/char/lib"❫
❪"code/transcompilers/unilang/doxygen_block_printer/grammar_adjuster"❫
⚞⚟

◀public: static▶ std::vector<std::string> ☀Export(Structure structure, std::vector<Contributor> const& contributors, Markdown_Settings const& settings)❰
   
   //Structure_Adjuster::Adjust(structure,settings.manipulations,Source_Language::Markdown);
   
  //created files
  std::vector<std::string> created;
  
  std::string source_code_filename = structure.name + settings.file_extension;
  std::ofstream outfile(source_code_filename);
  std::string str = Build_Markdown_Text(structure,contributors,settings);
  outfile << str <<'\n';
  outfile.close();
  
  created.emplace_back(source_code_filename);
  return created;
❱

◀private: static▶ std::string ☀Build_Markdown_Text(Structure const& structure, std::vector<Contributor> const& contributors, Markdown_Settings const& settings)❰
    std::string text;
    
    for (auto const& it: structure.literature.paragraphs){
        
        Append(text,Possibly_Get_Title(it,contributors,settings));
        Append(text,Possibly_Get_Sentences(it,contributors,settings));
    }
    
    return text;
❱

◀private: static▶ std::string ☀Possibly_Get_Title(Paragraph const& p, std::vector<Contributor> const& contributors, Markdown_Settings const& settings)❰
    std::string title;
    if (!p.title.value.empty()){
        
        //add the title marker
        Append(title,Depth_To_Header_Marker(0,settings));
        Append(title," ");
        
        //add the possible numbered
        //in markdown you can just mark everything
        //as 1., and it will be rendered with the correct numbers
        if (p.is_numbered){
            Append(title,"1. ");
        }
        
        //add the actual title
        Append_With_Newline(title,p.title.value);
    }
    return title;
❱

◀private: static▶ std::string ☀Possibly_Get_Sentences(Paragraph const& p, std::vector<Contributor> const& contributors, Markdown_Settings const& settings)❰
    std::string text;
    if (!p.sentences.empty()){
        
        //print each sentence
        for (auto const& it: p.sentences){
            Append(text,Possibly_Get_Sentence(it,contributors,settings));
        }
        
        //add extra line since we printed sentences under the title
        Append(text,"\n");
    }
    return text;
❱

◀private: static▶ std::string ☀Possibly_Get_Sentence(Sentence const& s, std::vector<Contributor> const& contributors, Markdown_Settings const& settings)❰
    std::string text;
    if (!s.text.value.empty()){
        Append(text,Grammar_Adjuster::Get_Adjusted(as_string(s.text.value),settings.grammar));
        Append(text,"  ");
        if (!s.images.empty() || !s.tables.empty()){
            Append(text,"\n");
            Append(text,Possibly_Get_Sentence_Suplementary(s,contributors,settings));
        }
    }
    return text;
❱
◀private: static▶ std::string ☀Possibly_Get_Sentence_Suplementary(Sentence const& s, std::vector<Contributor> const& contributors, Markdown_Settings const& settings)❰
    std::string text;
    
    std::string alternative_text_start_marker = "![";
    std::string alternative_text_end_marker = "]";
    std::string image_path_start_marker = "(";
    std::string image_path_end_marker = ")";
    std::string hover_text_start_marker = "\"";
    std::string hover_text_end_marker = "\"";
    
    //print images
    for (auto const& it: s.images){
        Append(text,alternative_text_start_marker);
        Append(text,as_string(it.alternative_text.value));
        Append(text,alternative_text_end_marker);
        Append(text,image_path_start_marker);
        Append(text,as_string(it.image_path.value));
        Append(text," ");
        Append(text,hover_text_start_marker);
        Append(text,as_string(it.hover_text.value));
        Append(text,hover_text_end_marker);
        Append(text,image_path_end_marker);
    }
    
    //print tables
    for (auto const& it: s.tables){
    }
    return text;
❱

◀private: static▶ std::string ☀Depth_To_Header_Marker(int depth, Markdown_Settings const& settings)❰
    if (depth == 0){
        return settings.headers.h1;
    }
    if (depth == 1){
        return settings.headers.h2;
    }
    if (depth == 2){
        return settings.headers.h3;
    }
    if (depth == 3){
        return settings.headers.h4;
    }
    if (depth == 4){
        return settings.headers.h5;
    }
    if (depth == 5){
        return settings.headers.h6;
    }
    
    //higher than 6? just use 6.
    return settings.headers.h6;
❱