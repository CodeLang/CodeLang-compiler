class
❪vector❫
❪string❫
❪unordered_map❫
❪"code/transcompilers/unilang/options/comment/doxygen/doxygen_block_options"❫
⚯

⚞⚟

◀
public:
     
   //grammar settings on exported comment
   
   //whether or not to take certain actions
   bool auto_capitalize_comments = true;
   bool auto_puncuate_comments = true;
   
   //the default puncution we will apply when the comment is missing puncuation
   std::string default_puncuation = ".";
   
   //a list of puncuations that we will look at to decide if the comment is missing puncuation
   //TODO: change to "terminal puncuation"
   std::vector<std::string> puncuations{
   ".",
   "!",
   "?",
   ":"
   };

   std::vector<std::string> non_word_puncuations{
   ".",
   "!",
   "?",
   ":",
   ",",
   "-",
   "*",
   "'",
   "\""
   };
   
   bool warn_about_sentences_ending_in_preposition=false;
   std::vector<std::string> prepositions{
"aboard",
"about",
"above",
"absent",
"across",
"after",
"against",
"along",
"alongside",
"amid",
"among",
"apropos",
"apud",
"around",
"as",
"astride",
"at",
"atop",
"ontop",
"bar",
"before",
"behind",
"below",
"beneath",
"beside",
"besides",
"between",
"beyond",
"but",
"by",
"chez",
"circa",
"come",
"dehors",
"despite",
"down",
"during",
"except",
"for",
"from",
"in",
"inside",
"into",
"less",
"like",
"minus",
"near",
"notwithstanding",
"of",
"off",
"on",
"onto",
"opposite",
"out",
"outside",
"over",
"pace",
"past",
"per",
"plus",
"post",
"pre",
"pro",
"qua",
"re",
"sans",
"save",
"short",
"since",
"than",
"through",
"throughout",
"till",
"to",
"toward",
"towards",
"under",
"underneath",
"unlike",
"until",
"unto",
"up",
"upon",
"upside",
"versus",
"via",
"vice",
"vis-à-vis",
"with",
"within",
"without",
"worth",
   };
   
   bool warn_about_sentences_ending_in_a_two_word_preposition=true;
   std::vector<std::string> two_word_prepositions{
"according to",
"across from",
"adjacent to",
"ahead of",
"along with",
"apart from",
"as for",
"as of",
"as per",
"as regards",
"aside from",
"back to",
"because of",
"close to",
"counter to",
"down on",
"due to",
"except for",
"far from",
"inside of",
"instead of",
"left of",
"near to",
"next to",
"opposite of",
"opposite to",
"other than",
"out from",
"out of",
"outside of",
"owing to",
"prior to",
"pursuant to",
"rather than",
"regardless of",
"right of",
"subsequent to",
"such as",
"thanks to",
"up to",
};

   bool warn_about_sentences_ending_in_a_three_word_preposition=true;
   std::vector<std::string> three_word_prepositions{
"as far as", //is one example of the many expressions which can be analyzed as as+adjective+as rather than a multiword preposition
"as opposed to",
"as soon as",
"as well as",
};
   
   

   
   //options for sensoring bad words
   bool auto_sensor_bad_words = true;
   bool warn_bad_words = true;
   std::vector<std::string> bad_words{
"aeolus",
"ahole",
"anal",
"apeshit",
"areola",
"areole",
"arrse",
"arse",
"arsehole",
"ass",
"asshole",
"boobs",
"boob",
"bootie",
"booty",
"ballsack",
"bullshit",
"barf",
"bastard",
"bdsm",
"beaner",
"beotch",
"bimbo",
"bitchy",
"bloody",
"blowjob",
"boner",
"bitch",
"crap",
"cunt",
"damn",
"dyke",
"dick",
"dumb",
"fuck",
"gay",
"nig",
"nigger",
"shit",
"slut",
"stupid",
"whore",
   }; //etc
   
   //use sensor alternative
   //instead of just sensoring the bad words with stars,
   //we may have alternative words/phrases to replace them with.
   //if a bad word exists but there is no given alternative, we will
   //choose to sensor it with the given character
   bool use_sensor_alternative=true;
   std::string sensor_pattern = "***";
   std::unordered_map<std::string, std::string> bad_word_alternatives{
	{"damn","darn"},
	{"crap","bad"}
   };
	
   bool use_auto_corrects=true;
   bool warn_about_auto_corrects=true;
   std::unordered_map<std::string, std::string> auto_corrects{
	{"teh","the"},
	{"wensday","wednesday"}
   };
   
   //these are words that are correct but people prefer that they are
   //written differently
   bool auto_retaste_words=true;
   bool warn_about_taste_suggestion=true;
   std::unordered_map<std::string, std::string> taste_corrections{
   {"vertexes","vertices"},
   {"indexes","indices"},
   };
   
   //"that's a valid word, but did you actually mean to write..."
   bool fix_correctly_spelled_typo=true;
   bool warn_correctly_spelled_typo=true;
   std::unordered_map<std::string, std::string> correctly_spelled_mistypes{
   {"manly","mainly"},
   };

   bool auto_capitalize_certain_words = true;
   bool warn_about_uncapitalized_words = true;
   std::vector<std::string> capitalize_words{
   "pennsylvania",
   "monday",
   "tuesday",
   "wednesday",
   "thursday",
   "friday",
   //months...
   };

   bool auto_full_caps_certain_words = true;
   std::vector<std::string> full_caps_words{
   "hidl"
   };
   
    
▶
