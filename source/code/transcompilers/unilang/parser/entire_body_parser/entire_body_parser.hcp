class
❪iostream❫
❪"code/transcompilers/unilang/structure/sections/method/body/function_body"❫
❪"code/transcompilers/unilang/parser/entire_body_parser/nested_body_tokens"❫
❪"code/transcompilers/unilang/parser/entire_body_parser/body_tokenizer"❫
⚯
❪"code/transcompilers/unilang/parser/global_tokens_table_utilities"❫
❪"code/utilities/types/strings/transformers/trimming/lib"❫
❪"code/utilities/converters/lib"❫
⚞⚟

◀public: static▶ Function_Body ☀Parse(std::wstring body)❰
    
    //trim the body
    auto body2 = as_string(body);
    trim(body2);
    body = as_wstring(body2);
    
    Function_Body entire_body;
    entire_body.elements = Parse_List_Of_Root_Elements(body);
    
    return entire_body;
❱

◀public: static▶ std::vector<Root_Body_Element> ☀Parse_List_Of_Root_Elements(std::wstring body)❰
    
    
    
    //a recursive decent tokenizer
    auto nested_tokens = Body_Tokenizer::Turn_Body_Into_Nested_Tokens(body);
    
    //now that we have nested tokens, we recursively build a variant out of their values
    std::vector<Root_Body_Element> results;
    for (auto const& it: nested_tokens.tokens.get()){
        results.emplace_back(Create_Root_Body_Element(it));
    }
    
    return results;
❱


◀private: static▶ Root_Body_Element ☀Create_Root_Body_Element(Nested_Body_Tokens const& all)❰
    Root_Body_Element element;
    
    //maybe its a comment
    if (all.single.name == Body_Token_Name::REGULAR_COMMENT){
        element.types = Create_Regular_Body_Comment(all);
        return element;
    }
    
    if (all.single.name == Body_Token_Name::TODO_COMMENT){
        element.types = Create_Todo_Body_Comment(all);
        return element;
    }
    
    if (all.single.name == Body_Token_Name::WARNING_COMMENT){
        element.types = Create_Warning_Body_Comment(all);
        return element;
    }
    
    //maybe its a statement of some kind
    if (all.single.name == Body_Token_Name::REGULAR_STATEMENT){
        element.types = Create_Regular_Statement(all);
        return element;
    }
    if (all.single.name == Body_Token_Name::RETURN_STATEMENT){
        element.types = Create_Return_Statement(all);
        return element;
    }
    if (all.single.name == Body_Token_Name::UNCAUGHT_STATEMENT){
        element.types = Create_Uncaught_Statement(all);
        return element;
    }
    
    //maybe its a control structure of some kind
    
    return element;
❱

◀private: static▶ Regular_Body_Comment ☀Create_Regular_Body_Comment(Nested_Body_Tokens const& all)❰
    
    if (!all.tokens.get().empty()){
        std::cerr << "regular body comment should be empty" << std::endl;
    }
    
    Regular_Body_Comment a;
    return a;
❱
◀private: static▶ Todo_Body_Comment ☀Create_Todo_Body_Comment(Nested_Body_Tokens const& all)❰

    if (!all.tokens.get().empty()){
        std::cerr << "todo comment should be empty" << std::endl;
    }
    
    Todo_Body_Comment a;
    return a;
❱
◀private: static▶ Warning_Body_Comment ☀Create_Warning_Body_Comment(Nested_Body_Tokens const& all)❰

    if (!all.tokens.get().empty()){
        std::cerr << "warning comment should be empty" << std::endl;
    }
    
    Warning_Body_Comment a;
    return a;
❱

◀private: static▶ Uncaught_Statement ☀Create_Uncaught_Statement(Nested_Body_Tokens const& all)❰

    std::cout << as_string(all.single.value) << std::endl;
    std::cout << "---" << std::endl;
    if (!all.tokens.get().empty()){
        std::cerr << "uncaught statement should be empty" << std::endl;
    }
    
    Uncaught_Statement a;
    return a;
❱




◀private: static▶ Regular_Statement ☀Create_Regular_Statement(Nested_Body_Tokens const& all)❰
    Regular_Statement a;
    return a;
❱
◀private: static▶ Return_Statement ☀Create_Return_Statement(Nested_Body_Tokens const& all)❰
    Return_Statement a;
    return a;
❱
