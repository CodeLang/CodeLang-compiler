class
❪"code/transcompilers/unilang/structure/sections/method/body/function_body"❫
⚯
❪"code/transcompilers/unilang/parser/global_tokens_table_utilities"❫
❪"code/utilities/types/strings/transformers/trimming/lib"❫
❪"code/utilities/converters/lib"❫
⚞⚟

//this is a poor hand written parser, but I can't really use bison, and the type of meta information and types I want extracted make it more plausable to just do something from scratch.  
//by the very nature of the unilang grammar, parsing is simple anyway.  In any other circumstance writing custom parsers would probably be a bad idea.
◀public: static▶ Function_Body ☀Parse(std::wstring body)❰
    
    //trim the body
    auto body2 = as_string(body);
    trim(body2);
    body = as_wstring(body2);
    
    Function_Body entire_body;
    entire_body.elements = Parse_List_Of_Root_Elements(body);
    
    return entire_body;
❱

◀public: static▶ std::vector<Root_Body_Element> ☀Parse_List_Of_Root_Elements(std::wstring body)❰
    
    
    std::vector<Root_Body_Element> results;
    
    /*
    std::wstring buffer;
    bool in_token = false;
    for (auto c: body){
        Handle_Char(result,buffer,in_token,c);
    }
    
    if (!buffer.empty()){
        Body_Token_Value t;
        t.value = buffer;
        t.name = Body_Token_Name::REGULAR;
        result.push_back(t);
    }
    */
    
    return results;
❱
