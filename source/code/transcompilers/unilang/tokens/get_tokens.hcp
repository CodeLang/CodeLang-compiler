class
❪"code/transcompilers/unilang/tokens/all_ast_markers"❫
❪"code/utilities/streams/filestreams/lib"❫
❪"code/utilities/types/strings/transformers/casing/lib"❫
❪"code/transcompilers/unilang/tokens/generic_token"❫
❪"code/transcompilers/unilang/tokens/token_name"❫
❪"code/transcompilers/unilang/tokens/token_group"❫
❪"code/transcompilers/unilang/tokens/all_language_tokens"❫

⚯

⚞⚟

◀public: static▶ All_Language_Tokens ☀Get() ❰
    All_Language_Tokens all;
    all.tokens.emplace_back(Meta_Code_Type());
    all.tokens.emplace_back(Meta_Brief_Comment());
    all.tokens.emplace_back(Meta_Detail_Comment());
    all.tokens.emplace_back(Meta_Group_Name());
    all.tokens.emplace_back(Meta_Author());
    all.tokens.emplace_back(Meta_Bug());
    all.tokens.emplace_back(Meta_Warning());
        all.tokens.emplace_back(Meta_Subgroup_Name());
        all.tokens.emplace_back(Meta_Subgroup_Description());
        all.tokens.emplace_back(Meta_Specification_File_Path());
        all.tokens.emplace_back(Meta_Specification_File_Description());
        all.tokens.emplace_back(Meta_Forseeable_Change());
        all.tokens.emplace_back(Meta_Forseeable_Change_Reason());
        all.tokens.emplace_back(Meta_Forseeable_Change_Reason_Percentage());
    all.tokens.emplace_back(Type_Brief_Description());
    all.tokens.emplace_back(Type_Detailed_Description());
    all.tokens.emplace_back(Type_Name());
    all.tokens.emplace_back(Library());
    all.tokens.emplace_back(COPTS());
    all.tokens.emplace_back(LINKOPTS());
    all.tokens.emplace_back(Import_Interface_Specifiers());
    all.tokens.emplace_back(Import_Interface_Name());
    all.tokens.emplace_back(Import_Interface_Comment());
        all.tokens.emplace_back(Import_Interface_Relationship());
        all.tokens.emplace_back(Import_Interface_Related());
    all.tokens.emplace_back(Import_Implementation_Specifiers());
    all.tokens.emplace_back(Import_Implementation_Name());
    all.tokens.emplace_back(Import_Implementation_Comment());
        all.tokens.emplace_back(Import_Implementation_Relationship());
        all.tokens.emplace_back(Import_Implementation_Related());
    all.tokens.emplace_back(Import_Test_Specifiers());
    all.tokens.emplace_back(Import_Test_Name());
    all.tokens.emplace_back(Import_Test_Comment());
        all.tokens.emplace_back(Import_Test_Relationship());
        all.tokens.emplace_back(Import_Test_Related());
    all.tokens.emplace_back(Namespace_Specifiers());
    all.tokens.emplace_back(Namespace_Name());
    all.tokens.emplace_back(Inheritance_Specifiers());
    all.tokens.emplace_back(Inheritance_Type());
    all.tokens.emplace_back(Forward_Declare_Argument());
    all.tokens.emplace_back(Object_Template_Argument_Qualifiers());
    all.tokens.emplace_back(Object_Template_Argument_Type());
    all.tokens.emplace_back(Object_Template_Argument_Identifier());
    all.tokens.emplace_back(Object_Template_Argument_Default());
    all.tokens.emplace_back(Object_Template_Argument_Units());
    all.tokens.emplace_back(Object_Template_Argument_Comment());
        all.tokens.emplace_back(Object_Template_Argument_Type_Concepts());
    all.tokens.emplace_back(Function_Class_Specifiers());
    all.tokens.emplace_back(Function_Subgroup_Name());
    all.tokens.emplace_back(Function_Brief_Description());
    all.tokens.emplace_back(Function_Detailed_Description());
    all.tokens.emplace_back(Function_Detailed_Name());
    all.tokens.emplace_back(Function_Unique_Mangle_Name());
        all.tokens.emplace_back(Function_Alternative_Expression_Name());
        all.tokens.emplace_back(Function_Precondition());
        all.tokens.emplace_back(Function_Precondition_Comment());
        all.tokens.emplace_back(Function_Postcondition());
        all.tokens.emplace_back(Function_Postcondition_Comment());
    all.tokens.emplace_back(Function_Stamp_Name());
        all.tokens.emplace_back(Function_Stamp_Value());
    all.tokens.emplace_back(Function_Template_Argument_Qualifiers());
    all.tokens.emplace_back(Function_Template_Argument_Type());
    all.tokens.emplace_back(Function_Template_Argument_Identifier());
    all.tokens.emplace_back(Function_Template_Argument_Default());
    all.tokens.emplace_back(Function_Template_Argument_Units());
    all.tokens.emplace_back(Function_Template_Argument_Comment());
    all.tokens.emplace_back(Function_Template_Argument_Concepts());
    all.tokens.emplace_back(Function_Argument_Type_Qualifiers());
    all.tokens.emplace_back(Function_Argument_Type());
    all.tokens.emplace_back(Function_Argument_Type_Scope());
    all.tokens.emplace_back(Function_Argument_Type_Specializations());
    all.tokens.emplace_back(Function_Argument_Type_Specializations_Scope());
    all.tokens.emplace_back(Function_Argument_Identifier());
    all.tokens.emplace_back(Function_Argument_Units());
    all.tokens.emplace_back(Function_Argument_Default());
    all.tokens.emplace_back(Function_Argument_Comment());
        all.tokens.emplace_back(Function_Argument_Type_Module_Dependencies());
        all.tokens.emplace_back(Function_Argument_Type_Library_Dependencies());
    all.tokens.emplace_back(Function_Result_Type_Qualifiers());
    all.tokens.emplace_back(Function_Result_Type());
    all.tokens.emplace_back(Function_Result_Type_Identifier());
    all.tokens.emplace_back(Function_Result_Units());
    all.tokens.emplace_back(Function_Result_Default());
    all.tokens.emplace_back(Function_Result_Comment());
        all.tokens.emplace_back(Function_Result_Type_Scope());
        all.tokens.emplace_back(Function_Result_Type_Specializations());
            all.tokens.emplace_back(Function_Result_Type_Specializations_Scope());
        all.tokens.emplace_back(Function_Result_Type_Module_Dependencies());
        all.tokens.emplace_back(Function_Result_Type_Library_Dependencies());
    all.tokens.emplace_back(Function_Except_Expression());
    all.tokens.emplace_back(Function_Except_Comment());
    all.tokens.emplace_back(Function_Body());
    all.tokens.emplace_back(Function_Test_Case_Name());
    all.tokens.emplace_back(Function_Test_Case_Tag());
    all.tokens.emplace_back(Function_Test_Case_Reason_For_Testing());
        all.tokens.emplace_back(Function_Test_Case_Reason_For_Failing());
    all.tokens.emplace_back(Function_Test_Case_Body());
    all.tokens.emplace_back(Function_Benchmark_Case_Name());
    all.tokens.emplace_back(Function_Benchmark_Case_Tag());
    all.tokens.emplace_back(Function_Benchmark_Case_Setup());
    all.tokens.emplace_back(Function_Benchmark_Case_Action());
    all.tokens.emplace_back(Function_Benchmark_Argument_Name());
    all.tokens.emplace_back(Function_Benchmark_Argument_Low());
    all.tokens.emplace_back(Function_Benchmark_Argument_High());
    all.tokens.emplace_back(Function_Benchmark_Argument_Multiplier());
    all.tokens.emplace_back(Typedef_Specifiers());
    all.tokens.emplace_back(Typedef_Brief_Description());
    all.tokens.emplace_back(Typedef_Detailed_Description());
    all.tokens.emplace_back(Typedef_Name());
    all.tokens.emplace_back(Typedef_Return());
    all.tokens.emplace_back(Typedef_Return_Comment());
    all.tokens.emplace_back(Typedef_Argument());
    all.tokens.emplace_back(Typedef_Argument_Comment());
    all.tokens.emplace_back(Data_Member_Brief());
    all.tokens.emplace_back(Data_Member_Detailed());
    all.tokens.emplace_back(Data_Member_Class_Specifiers());
    all.tokens.emplace_back(Data_Member_Type_Qualifiers());
    all.tokens.emplace_back(Data_Member_Identifier());
    all.tokens.emplace_back(Data_Member_Units());
    all.tokens.emplace_back(Data_Member_Default_Value());



    
    
    return Get_deprecated();
    //return all;
❱

◀private: static▶ Token ☀Meta_Code_Type() ❰
    Token t;
    t.name = Token_Name::META_DATA_CODE_TYPE;
    t.start = L'􏶞';
    t.end = L'􏶟';
    t.fg_color = "#45252B";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.description = "how the UniLang compiler should treat the file when compiling (object type or global type)";
    return t;
❱
◀private: static▶ Token ☀Meta_Brief_Comment() ❰
    Token t;
    t.name = Token_Name::META_DATA_BRIEF_DESCRIPTION;
    t.start = L'􏷲';
    t.end = L'􏷱';
    t.fg_color = "#66432A";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.description = "A brief description of the object or set of functions that make up the file";
    return t;
❱
◀private: static▶ Token ☀Meta_Detail_Comment() ❰
    Token t;
    t.name = Token_Name::META_DATA_DETAILED_DESCRIPTION;
    t.start = L'􏷰';
    t.end = L'􏷯';
    t.fg_color = "#66652A";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.description = "A detailed description of the object or set of functions that make up the file";
    return t;
❱
◀private: static▶ Token ☀Meta_Group_Name() ❰
    Token t;
    t.name = Token_Name::META_DATA_GROUP_NAME;
    t.start = L'􏷮';
    t.end = L'􏷭';
    t.fg_color = "#2A662E";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.description = "A categorical group name to help organize code";
    return t;
❱
◀private: static▶ Token ☀Meta_Author() ❰
    Token t;
    t.name = Token_Name::META_DATA_AUTHOR;
    t.start = L'􏷬';
    t.end = L'􏷫';
    t.fg_color = "#2A4866";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.description = "one of the authors of the files";
    return t;
❱
◀private: static▶ Token ☀Meta_Bug() ❰
    Token t;
    t.name = Token_Name::META_DATA_BUG;
    t.start = L'􏷪';
    t.end = L'􏷩';
    t.fg_color = "#623366";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.description = "a known bug about the object or set of functions";
    return t;
❱
◀private: static▶ Token ☀Meta_Warning() ❰
    Token t;
    t.name = Token_Name::META_DATA_WARNING;
    t.start = L'􏷨';
    t.end = L'􏷧';
    t.fg_color = "#922127";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.description = "a warning about using the object or set of functions";
    return t;
❱
◀private: static▶ Token ☀Meta_Depreciation() ❰
    Token t;
    t.name = Token_Name::META_DATA_DEPRECIATION;
    t.start = L'􏷖';
    t.end = L'􏷕';
    t.fg_color = "#876E51";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.description = "reasons why the object or set of functions are depreciated";
    return t;
❱
◀private: static▶ Token ☀Meta_Subgroup_Name() ❰
    Token t;
    t.name = Token_Name::META_SUBGROUP_NAME;
    t.start = L'􏴃';
    t.end = L'􏴄';
    t.fg_color = "#3DFF5D";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.groups.emplace_back(Token_Group::META_SUBGROUP);
    t.description = "the name of a subgroup that can be used for group documenting methods or data members";
    return t;
❱
◀private: static▶ Token ☀Meta_Subgroup_Description() ❰
    Token t;
    t.name = Token_Name::META_SUBGROUP_DESCRIPTION;
    t.start = L'􏴁';
    t.end = L'􏴂';
    t.fg_color = "#95F5A4";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.groups.emplace_back(Token_Group::META_SUBGROUP);
    t.description = "a description of the subgroup that is applied in the documentation grouping";
    return t;
❱
◀private: static▶ Token ☀Meta_Specification_File_Path() ❰
    Token t;
    t.name = Token_Name::META_SPECIFICATION_FILE_PATH;
    t.start = L'􏵔';
    t.end = L'􏵕';
    t.fg_color = "#CE5D37";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.groups.emplace_back(Token_Group::META_SPECIFICATION_FILE);
    t.description = "path to specification documents, ICDs, designs, requirements, etc";
    return t;
❱
◀private: static▶ Token ☀Meta_Specification_File_Description() ❰
    Token t;
    t.name = Token_Name::META_SPECIFICATION_FILE_DESCRIPTION;
    t.start = L'􏵒';
    t.end = L'􏵓';
    t.fg_color = "#CEAB37";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.groups.emplace_back(Token_Group::META_SPECIFICATION_FILE);
    t.description = "a brief description of what the specification file is";
    return t;
❱
◀private: static▶ Token ☀Meta_Forseeable_Change() ❰
    Token t;
    t.name = Token_Name::META_FORSEEABLE_CHANGE;
    t.start = L'􏴋';
    t.end = L'􏴌';
    t.fg_color = "#CE5D37";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.groups.emplace_back(Token_Group::META_FORSEEABLE_CHANGE);
    t.description = "something that may change about the whole module of code";
    return t;
❱
◀private: static▶ Token ☀Meta_Forseeable_Change_Reason() ❰
    Token t;
    t.name = Token_Name::META_FORSEEABLE_CHANGE_REASON;
    t.start = L'􏴉';
    t.end = L'􏴊';
    t.fg_color = "#CE5D37";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.groups.emplace_back(Token_Group::META_FORSEEABLE_CHANGE);
    t.description = "the reason this change may happen";
    return t;
❱
◀private: static▶ Token ☀Meta_Forseeable_Change_Reason_Percentage() ❰
    Token t;
    t.name = Token_Name::META_FORSEEABLE_REASON_PERCENTAGE;
    t.start = L'􏴇';
    t.end = L'􏴈';
    t.fg_color = "#CE5D37";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::META);
    t.groups.emplace_back(Token_Group::META_FORSEEABLE_CHANGE);
    t.description = "the likelihood that change may happen";
    return t;
❱
◀private: static▶ Token ☀Type_Brief_Description() ❰
    Token t;
    t.name = Token_Name::TYPE_BRIEF_DESCRIPTION;
    t.start = L'􏳃';
    t.end = L'􏳄';
    t.fg_color = "#66432A";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::TYPES);
    t.description = "a brief description of a new type";
    return t;
❱
◀private: static▶ Token ☀Type_Detailed_Description() ❰
    Token t;
    t.name = Token_Name::TYPE_DETAILED_DESCRIPTION;
    t.start = L'􏳁';
    t.end = L'􏳂';
    t.fg_color = "#66432A";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::TYPES);
    t.description = "a detailed description of a new type";
    return t;
❱
◀private: static▶ Token ☀Type_Name() ❰
    Token t;
    t.name = Token_Name::TYPE_NAME;
    t.start = L'􏲿';
    t.end = L'􏳀';
    t.fg_color = "#D69125";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::TYPES);
    t.description = "the name of the new type";
    return t;
❱
◀private: static▶ Token ☀Library() ❰
    Token t;
    t.name = Token_Name::LIBRARY;
    t.start = L'􏲟';
    t.end = L'􏲠';
    t.fg_color = "#FFFF00";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::LIBRARY);
    t.description = "a library include";
    return t;
❱

◀private: static▶ Token ☀COPTS() ❰
    Token t;
    t.name = Token_Name::COPTS;
    t.start = L'􏲃';
    t.end = L'􏲄';
    t.fg_color = "#FFFF00";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::COPTS);
    t.description = "a copts library";
    return t;
❱
◀private: static▶ Token ☀LINKOPTS() ❰
    Token t;
    t.name = Token_Name::LINKOPTS;
    t.start = L'􏲁';
    t.end = L'􏲂';
    t.fg_color = "#FFFF00";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::LINKOPTS);
    t.description = "a linkopts library";
    return t;
❱
◀private: static▶ Token ☀Import_Interface_Specifiers() ❰
    Token t;
    t.name = Token_Name::IMPORT_INTERFACE_SPECIFIERS;
    t.start = L'􏷤';
    t.end = L'􏷣';
    t.fg_color = "#1F4B22";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_INTERFACE);
    t.description = "whether the file is a system file.  whether it is inlined";
    return t;
❱
◀private: static▶ Token ☀Import_Interface_Name() ❰
    Token t;
    t.name = Token_Name::IMPORT_INTERFACE_NAME;
    t.start = L'􏷦';
    t.end = L'􏷥';
    t.fg_color = "#2A662E";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_INTERFACE);
    t.description = "code to import into the interface of this code";
    return t;
❱
◀private: static▶ Token ☀Import_Interface_Comment() ❰
    Token t;
    t.name = Token_Name::IMPORT_INTERFACE_COMMENT;
    t.start = L'􏷢';
    t.end = L'􏷡';
    t.fg_color = "#5C5C5C";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_INTERFACE);
    t.description = "a comment about the code being imported";
    return t;
❱
◀private: static▶ Token ☀Import_Interface_Relationship() ❰
    Token t;
    t.name = Token_Name::IMPORT_INTERFACE_RELATIONSHIP;
    t.start = L'􏴓';
    t.end = L'􏴔';
    t.fg_color = "#00ABB2";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_INTERFACE);
    t.groups.emplace_back(Token_Group::IMPORT_INTERFACE_RELATIONSHIP);
    t.description = "the relationship of something included by the include";
    return t;
❱
◀private: static▶ Token ☀Import_Interface_Related() ❰
    Token t;
    t.name = Token_Name::IMPORT_INTERFACE_RELATED;
    t.start = L'􏴑';
    t.end = L'􏴒';
    t.fg_color = "#3FF8FF";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_INTERFACE);
    t.groups.emplace_back(Token_Group::IMPORT_INTERFACE_RELATIONSHIP);
    t.description = "a related thing being included";
    return t;
❱
◀private: static▶ Token ☀Import_Implementation_Specifiers() ❰
    Token t;
    t.name = Token_Name::IMPORT_IMPLEMENTATION_SPECIFIERS;
    t.start = L'􏶔';
    t.end = L'􏶕';
    t.fg_color = "#4D2B13";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_IMPLEMENTATION);
    t.description = "whether the file is a system file.  whether it is inlined";
    return t;
❱
◀private: static▶ Token ☀Import_Implementation_Name() ❰
    Token t;
    t.name = Token_Name::IMPORT_IMPLEMENTATION_NAME;
    t.start = L'􏶒';
    t.end = L'􏶓';
    t.fg_color = "#66432A";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_IMPLEMENTATION);
    t.description = "code to import into the interface of this code";
    return t;
❱
◀private: static▶ Token ☀Import_Implementation_Comment() ❰
    Token t;
    t.name = Token_Name::IMPORT_IMPLEMENTATION_COMMENT;
    t.start = L'􏶖';
    t.end = L'􏶗';
    t.fg_color = "#5C5C5C";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_IMPLEMENTATION);
    t.description = "a comment about the code being imported";
    return t;
❱
◀private: static▶ Token ☀Import_Implementation_Relationship() ❰
    Token t;
    t.name = Token_Name::IMPORT_IMPLEMENTATION_RELATIONSHIP;
    t.start = L'􏴏';
    t.end = L'􏴐';
    t.fg_color = "#00ABB2";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_IMPLEMENTATION);
    t.groups.emplace_back(Token_Group::IMPORT_IMPLEMENTATION_RELATIONSHIP);
    t.description = "the relationship of something included by the include";
    return t;
❱
◀private: static▶ Token ☀Import_Implementation_Related() ❰
    Token t;
    t.name = Token_Name::IMPORT_IMPLEMENTATION_RELATED;
    t.start = L'􏴍';
    t.end = L'􏴎';
    t.fg_color = "#3FF8FF";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_IMPLEMENTATION);
    t.groups.emplace_back(Token_Group::IMPORT_IMPLEMENTATION_RELATIONSHIP);
    t.description = "a related thing being included";
    return t;
❱
◀private: static▶ Token ☀Import_Test_Specifiers() ❰
    Token t;
    t.name = Token_Name::IMPORT_TEST_SPECIFIERS;
    t.start = L'􏲏';
    t.end = L'􏲐';
    t.fg_color = "#4D2B13";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_TEST);
    t.description = "whether the file is a system file.  whether it is inlined";
    return t;
❱
◀private: static▶ Token ☀Import_Test_Name() ❰
    Token t;
    t.name = Token_Name::IMPORT_TEST_NAME;
    t.start = L'􏲍';
    t.end = L'􏲎';
    t.fg_color = "#66432A";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_TEST);
    t.description = "code to import into the interface of this code";
    return t;
❱
◀private: static▶ Token ☀Import_Test_Comment() ❰
    Token t;
    t.name = Token_Name::IMPORT_TEST_COMMENT;
    t.start = L'􏲋';
    t.end = L'􏲌';
    t.fg_color = "#5C5C5C";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_TEST);
    t.description = "a comment about the code being imported";
    return t;
❱
◀private: static▶ Token ☀Import_Test_Relationship() ❰
    Token t;
    t.name = Token_Name::IMPORT_TEST_RELATIONSHIP;
    t.start = L'􏲉';
    t.end = L'􏲊';
    t.fg_color = "#00ABB2";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_TEST);
    t.groups.emplace_back(Token_Group::IMPORT_TEST_RELATIONSHIP);
    t.description = "the relationship of something included by the include";
    return t;
❱
◀private: static▶ Token ☀Import_Test_Related() ❰
    Token t;
    t.name = Token_Name::IMPORT_TEST_RELATED;
    t.start = L'􏲇';
    t.end = L'􏲈';
    t.fg_color = "#3FF8FF";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::IMPORT_TEST);
    t.groups.emplace_back(Token_Group::IMPORT_TEST_RELATIONSHIP);
    t.description = "a related thing being included";
    return t;
❱
◀private: static▶ Token ☀Namespace_Specifiers() ❰
    Token t;
    t.name = Token_Name::NAMESPACE_SPECIFIERS;
    t.start = L'􏷠';
    t.end = L'􏷟';
    t.fg_color = "#00A300";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::NAMESPACE);
    t.description = "specifiers for the proceeding namespace name (inline or not)";
    return t;
❱
◀private: static▶ Token ☀Namespace_Name() ❰
    Token t;
    t.name = Token_Name::NAMESPACE_NAME;
    t.start = L'􏷞';
    t.end = L'􏷝';
    t.fg_color = "#0AFF0A";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::NAMESPACE);
    t.description = "the namespace name to wrap everything around";
    return t;
❱

◀private: static▶ Token ☀Inheritance_Specifiers() ❰
    Token t;
    t.name = Token_Name::INHERITANCE_SPECIFIERS;
    t.start = L'􏷜';
    t.end = L'􏷛';
    t.fg_color = "#A3A300";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::INHERITANCE);
    t.description = "virtual and/or access specifier for proceeding inheritance type";
    return t;
❱

◀private: static▶ Token ☀Inheritance_Type() ❰
    Token t;
    t.name = Token_Name::INHERITANCE_TYPE;
    t.start = L'􏷚';
    t.end = L'􏷙';
    t.fg_color = "#FFFF00";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::INHERITANCE);
    t.description = "a type to inherit from";
    return t;
❱

◀private: static▶ Token ☀Forward_Declare_Argument() ❰
    Token t;
    t.name = Token_Name::FORWARD_DECLARE_ARGUMENT;
    t.start = L'􏳹';
    t.end = L'􏳺';
    t.fg_color = "#FFFF00";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FORWARD_DECLARE);
    t.description = "a forward declaration";
    return t;
❱

◀private: static▶ Token ☀Object_Template_Argument_Qualifiers() ❰
    Token t;
    t.name = Token_Name::OBJECT_TEMPLATE_ARGUMENT_QUALIFIERS;
    t.start = L'􏳑';
    t.end = L'􏳒';
    t.fg_color = "#a2dfee";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::OBJECT_TEMPLATE_ARGUMENT);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Object_Template_Argument_Type() ❰
    Token t;
    t.name = Token_Name::OBJECT_TEMPLATE_ARGUMENT_TYPE;
    t.start = L'􏳓';
    t.end = L'􏳔';
    t.fg_color = "#73cfe5";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::OBJECT_TEMPLATE_ARGUMENT);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Object_Template_Argument_Identifier() ❰
    Token t;
    t.name = Token_Name::OBJECT_TEMPLATE_ARGUMENT_IDENTIFIER;
    t.start = L'􏳕';
    t.end = L'􏳖';
    t.fg_color = "#45bfdd";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::OBJECT_TEMPLATE_ARGUMENT);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Object_Template_Argument_Default() ❰
    Token t;
    t.name = Token_Name::OBJECT_TEMPLATE_ARGUMENT_DEFAULT;
    t.start = L'􏳗';
    t.end = L'􏳘';
    t.fg_color = "#17afd5";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::OBJECT_TEMPLATE_ARGUMENT);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Object_Template_Argument_Units() ❰
    Token t;
    t.name = Token_Name::OBJECT_TEMPLATE_ARGUMENT_UNITS;
    t.start = L'􏳙';
    t.end = L'􏳚';
    t.fg_color = "#0098be";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::OBJECT_TEMPLATE_ARGUMENT);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Object_Template_Argument_Comment() ❰
    Token t;
    t.name = Token_Name::OBJECT_TEMPLATE_ARGUMENT_COMMENT;
    t.start = L'􏳛';
    t.end = L'􏳜';
    t.fg_color = "#007a99";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::OBJECT_TEMPLATE_ARGUMENT);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Object_Template_Argument_Type_Concepts() ❰
    Token t;
    t.name = Token_Name::OBJECT_TEMPLATE_ARGUMENT_TYPE_CONCEPTS;
    t.start = L'􏳝';
    t.end = L'􏳞';
    t.fg_color = "#005c73";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::OBJECT_TEMPLATE_ARGUMENT);
    t.groups.emplace_back(Token_Group::OBJECT_TEMPLATE_ARGUMENT_CONCEPTS);
    t.description = "";
    return t;
❱


◀private: static▶ Token ☀Function_Class_Specifiers() ❰
    Token t;
    t.name = Token_Name::FUNCTION_CLASS_SPECIFIERS;
    t.start = L'􏷘';
    t.end = L'􏷗';
    t.fg_color = "#662A45";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.description = "static const lvalue/rvalue overloads and class specifiers";
    return t;
❱

◀private: static▶ Token ☀Function_Subgroup_Name() ❰
    Token t;
    t.name = Token_Name::FUNCTION_SUBGROUP_NAME;
    t.start = L'􏴅';
    t.end = L'􏴆';
    t.fg_color = "#3DFF5D";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.description = "a referenced subgroup name to describe the function.  possibly shared by other functions";
    return t;
❱

◀private: static▶ Token ☀Function_Brief_Description() ❰
    Token t;
    t.name = Token_Name::FUNCTION_BRIEF_DESCRIPTION;
    t.start = L'􏷐';
    t.end = L'􏷏';
    t.fg_color = "#66432A";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.description = "a brief description of the function/method";
    return t;
❱

◀private: static▶ Token ☀Function_Detailed_Description() ❰
    Token t;
    t.name = Token_Name::FUNCTION_DETAILED_DESCRIPTION;
    t.start = L'􏶠';
    t.end = L'􏶡';
    t.fg_color = "#66652A";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.description = "a detailed description of the function/method";
    return t;
❱

◀private: static▶ Token ☀Function_Detailed_Name() ❰
    Token t;
    t.name = Token_Name::FUNCTION_NAME;
    t.start = L'􏷒';
    t.end = L'􏷑';
    t.fg_color = "#C35A00";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.description = "the name of the function/method";
    return t;
❱

◀private: static▶ Token ☀Function_Unique_Mangle_Name() ❰
    Token t;
    t.name = Token_Name::FUNCTION_UNIQUE_MANGLE_NAME;
    t.start = L'􏴫';
    t.end = L'􏴬';
    t.fg_color = "#C35A00";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.description = "alternative name to choose when mangling a name to allow overloads/templates in languages that don't support them";
    return t;
❱

◀private: static▶ Token ☀Function_Alternative_Expression_Name() ❰
    Token t;
    t.name = Token_Name::FUNCTION_ALTERNATIVE_EXPRESSION_NAME;
    t.start = L'􏴳';
    t.end = L'􏴴';
    t.fg_color = "#E731C6";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_ALTERNATIVE_EXPRESSION_NAME);
    t.description = "the name of the function/method";
    return t;
❱
◀private: static▶ Token ☀Function_Precondition() ❰
    Token t;
    t.name = Token_Name::FUNCTION_PRECONDITION;
    t.start = L'􏵪';
    t.end = L'􏵫';
    t.fg_color = "#EAFF00";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_PRECONDITION);
    t.description = "preconditions or assumptions before the execution of the function body";
    return t;
❱
◀private: static▶ Token ☀Function_Precondition_Comment() ❰
    Token t;
    t.name = Token_Name::FUNCTION_PRECONDITION_COMMENT;
    t.start = L'􏵨';
    t.end = L'􏵩';
    t.fg_color = "#C0D102";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_PRECONDITION);
    t.description = "a comment describing the assumptions";
    return t;
❱
◀private: static▶ Token ☀Function_Postcondition() ❰
    Token t;
    t.name = Token_Name::FUNCTION_POSTCONDITION;
    t.start = L'􏵦';
    t.end = L'􏵧';
    t.fg_color = "#FF006A";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_POSTCONDITION);
    t.description = "postconditions or assumptions before the execution of the function body";
    return t;
❱
◀private: static▶ Token ☀Function_Postcondition_Comment() ❰
    Token t;
    t.name = Token_Name::FUNCTION_POSTCONDITION_COMMENT;
    t.start = L'􏵤';
    t.end = L'􏵥';
    t.fg_color = "#990040";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_POSTCONDITION);
    t.description = "a comment describing the assumptions";
    return t;
❱

◀private: static▶ Token ☀Function_Stamp_Name() ❰
    Token t;
    t.name = Token_Name::FUNCTION_STAMP_NAME;
    t.start = L'􏳇';
    t.end = L'􏳈';
    t.fg_color = "#cdd100";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_STAMP);
    t.description = "name of the function stamp";
    return t;
❱

◀private: static▶ Token ☀Function_Stamp_Value() ❰
    Token t;
    t.name = Token_Name::FUNCTION_STAMP_VALUE;
    t.start = L'􏳅';
    t.end = L'􏳆';
    t.fg_color = "#fcff6b";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_STAMP);
    t.groups.emplace_back(Token_Group::FUNCTION_STAMP_VALUE);
    t.description = "one of the values of the function stamp";
    return t;
❱
◀private: static▶ Token ☀Function_Template_Argument_Qualifiers() ❰
    Token t;
    t.name = Token_Name::FUNCTION_TEMPLATE_ARGUMENT_QUALIFIERS;
    t.start = L'􏳏';
    t.end = L'􏳐';
    t.fg_color = "#a2dfee";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_TEMPLATE_ARGUMENT);
    t.description = "qualifiers for template parameters";
    return t;
❱
◀private: static▶ Token ☀Function_Template_Argument_Type() ❰
    Token t;
    t.name = Token_Name::FUNCTION_TEMPLATE_ARGUMENT_TYPE;
    t.start = L'􏷎';
    t.end = L'􏷍';
    t.fg_color = "#73cfe5";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_TEMPLATE_ARGUMENT);
    t.description = "the template type of one of the template parameters";
    return t;
❱
◀private: static▶ Token ☀Function_Template_Argument_Identifier() ❰
    Token t;
    t.name = Token_Name::FUNCTION_TEMPLATE_ARGUMENT_IDENTIFIER;
    t.start = L'􏷌';
    t.end = L'􏷋';
    t.fg_color = "#45bfdd";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_TEMPLATE_ARGUMENT);
    t.description = "the template identifier for one of the template parameters";
    return t;
❱
◀private: static▶ Token ☀Function_Template_Argument_Default() ❰
    Token t;
    t.name = Token_Name::FUNCTION_TEMPLATE_ARGUMENT_DEFAULT;
    t.start = L'􏷊';
    t.end = L'􏷉';
    t.fg_color = "#17afd5";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_TEMPLATE_ARGUMENT);
    t.description = "the default type value for one of the template parameters";
    return t;
❱
◀private: static▶ Token ☀Function_Template_Argument_Units() ❰
    Token t;
    t.name = Token_Name::FUNCTION_TEMPLATE_ARGUMENT_UNITS;
    t.start = L'􏳍';
    t.end = L'􏳎';
    t.fg_color = "#0098be";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_TEMPLATE_ARGUMENT);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Function_Template_Argument_Comment() ❰
    Token t;
    t.name = Token_Name::FUNCTION_TEMPLATE_ARGUMENT_COMMENT;
    t.start = L'􏷈';
    t.end = L'􏷇';
    t.fg_color = "#007a99";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_TEMPLATE_ARGUMENT);
    t.description = "a comment about one of the template parameters";
    return t;
❱
◀private: static▶ Token ☀Function_Template_Argument_Concepts() ❰
    Token t;
    t.name = Token_Name::FUNCTION_TEMPLATE_ARGUMENT_TYPE_CONCEPTS;
    t.start = L'􏳋';
    t.end = L'􏳌';
    t.fg_color = "#005c73";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_TEMPLATE_ARGUMENT);
    t.groups.emplace_back(Token_Group::FUNCTION_TEMPLATE_ARGUMENT_CONCEPTS);
    t.description = "a comment about one of the template parameters";
    return t;
❱
◀private: static▶ Token ☀Function_Argument_Type_Qualifiers() ❰
    Token t;
    t.name = Token_Name::FUNCTION_TEMPLATE_ARGUMENT_TYPE_CONCEPTS;
    t.start = L'􏶜';
    t.end = L'􏶝';
    t.fg_color = "#2A662E";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT);
    t.description = "qualifiers of the type";
    return t;
❱
◀private: static▶ Token ☀Function_Argument_Type() ❰
    Token t;
    t.name = Token_Name::FUNCTION_ARGUMENT_TYPE;
    t.start = L'􏷆';
    t.end = L'􏷅';
    t.fg_color = "#2A4866";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT);
    t.description = "the type of one of the function/method parameters";
    return t;
❱
◀private: static▶ Token ☀Function_Argument_Type_Scope() ❰
    Token t;
    t.name = Token_Name::FUNCTION_ARGUMENT_TYPE_SCOPE;
    t.start = L'􏲯';
    t.end = L'􏲰';
    t.fg_color = "#2A4866";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT_SCOPE);
    t.description = "x";
    return t;
❱
◀private: static▶ Token ☀Function_Argument_Type_Specializations() ❰
    Token t;
    t.name = Token_Name::FUNCTION_ARGUMENT_TYPE_SPECIALIZATIONS;
    t.start = L'􏳣';
    t.end = L'􏳤';
    t.fg_color = "#2A4866";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT_TYPE_SPECIALIZATIONS);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Function_Argument_Type_Specializations_Scope() ❰
    Token t;
    t.name = Token_Name::FUNCTION_ARGUMENT_TYPE_SPECIALIZATIONS_SCOPE;
    t.start = L'􏲭';
    t.end = L'􏲮';
    t.fg_color = "#2A4866";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT_TYPE_SPECIALIZATIONS);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT_TYPE_SPECIALIZATIONS_SCOPE);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Function_Argument_Identifier() ❰
    Token t;
    t.name = Token_Name::FUNCTION_ARGUMENT_IDENTIFIER;
    t.start = L'􏷄';
    t.end = L'􏷃';
    t.fg_color = "#EF53EF";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT);
    t.description = "the identifier of one of the function/method parameters";
    return t;
❱
◀private: static▶ Token ☀Function_Argument_Units() ❰
    Token t;
    t.name = Token_Name::FUNCTION_ARGUMENT_UNITS;
    t.start = L'􏵘';
    t.end = L'􏵙';
    t.fg_color = "#9E6C9E";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT);
    t.description = "the units that the identifier is in";
    return t;
❱
◀private: static▶ Token ☀Function_Argument_Default() ❰
    Token t;
    t.name = Token_Name::FUNCTION_ARGUMENT_DEFAULT;
    t.start = L'􏷂';
    t.end = L'􏷁';
    t.fg_color = "#70FFFF";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT);
    t.description = "the default value for one of the function/method parameters";
    return t;
❱
◀private: static▶ Token ☀Function_Argument_Comment() ❰
    Token t;
    t.name = Token_Name::FUNCTION_ARGUMENT_COMMENT;
    t.start = L'􏷀';
    t.end = L'􏶿';
    t.fg_color = "#5C5C5C";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT);
    t.description = "a comment about one of the function/method parameters";
    return t;
❱
◀private: static▶ Token ☀Function_Argument_Type_Module_Dependencies() ❰
    Token t;
    t.name = Token_Name::FUNCTION_ARGUMENT_TYPE_MODULE_DEPENDENCIES;
    t.start = L'􏲧';
    t.end = L'􏲨';
    t.fg_color = "#42E2F4";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT_TYPE_MODULE_DEPENDENCIES);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Function_Argument_Type_Library_Dependencies() ❰
    Token t;
    t.name = Token_Name::FUNCTION_ARGUMENT_TYPE_LIBRARY_DEPENDENCIES;
    t.start = L'􏲥';
    t.end = L'􏲦';
    t.fg_color = "#42E2F4";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT);
    t.groups.emplace_back(Token_Group::FUNCTION_ARGUMENT_TYPE_LIBRARY_DEPENDENCIES);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Function_Result_Type_Qualifiers() ❰
    Token t;
    t.name = Token_Name::FUNCTION_RESULT_TYPE_QUALIFIERS;
    t.start = L'􏶚';
    t.end = L'􏶛';
    t.fg_color = "#32514F";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT);
    t.description = "the return type of the function/method";
    return t;
❱
◀private: static▶ Token ☀Function_Result_Type() ❰
    Token t;
    t.name = Token_Name::FUNCTION_RESULT_TYPE;
    t.start = L'􏶾';
    t.end = L'􏶽';
    t.fg_color = "#366D6B";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT);
    t.description = "the return type of the function/method";
    return t;
❱

◀private: static▶ Token ☀Function_Result_Type_Identifier() ❰
    Token t;
    t.name = Token_Name::FUNCTION_RESULT_IDENTIFIER;
    t.start = L'􏶼';
    t.end = L'􏶻';
    t.fg_color = "#5BAEAB";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT);
    t.description = "the identifier of the return parameter of the function/method";
    return t;
❱
◀private: static▶ Token ☀Function_Result_Units() ❰
    Token t;
    t.name = Token_Name::FUNCTION_RESULT_UNITS;
    t.start = L'􏵜';
    t.end = L'􏵝';
    t.fg_color = "#5E53EF";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT);
    t.description = "the units of the identifier";
    return t;
❱
◀private: static▶ Token ☀Function_Result_Default() ❰
    Token t;
    t.name = Token_Name::FUNCTION_RESULT_DEFAULT;
    t.start = L'􏲅';
    t.end = L'􏲆';
    t.fg_color = "#70FFFF";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT);
    t.description = "the units of the identifier";
    return t;
❱
◀private: static▶ Token ☀Function_Result_Comment() ❰
    Token t;
    t.name = Token_Name::FUNCTION_RESULT_COMMENT;
    t.start = L'􏶺';
    t.end = L'􏶹';
    t.fg_color = "#5C5C5C";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT);
    t.description = "a comment about the function/method return parameter";
    return t;
❱
◀private: static▶ Token ☀Function_Result_Type_Scope() ❰
    Token t;
    t.name = Token_Name::FUNCTION_RESULT_TYPE_SCOPE;
    t.start = L'􏲫';
    t.end = L'􏲬';
    t.fg_color = "#366D6B";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT_SCOPE);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Function_Result_Type_Specializations() ❰
    Token t;
    t.name = Token_Name::FUNCTION_RESULT_TYPE_SPECIALIZATIONS;
    t.start = L'􏳡';
    t.end = L'􏳢';
    t.fg_color = "#366D6B";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT_TYPE_SPECIALIZATIONS);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Function_Result_Type_Specializations_Scope() ❰
    Token t;
    t.name = Token_Name::FUNCTION_RESULT_TYPE_SPECIALIZATIONS_SCOPE;
    t.start = L'􏲩';
    t.end = L'􏲪';
    t.fg_color = "#366D6B";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT_TYPE_SPECIALIZATIONS);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT_TYPE_SPECIALIZATIONS_SCOPE);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Function_Result_Type_Module_Dependencies() ❰
    Token t;
    t.name = Token_Name::FUNCTION_RESULT_TYPE_MODULE_DEPENDENCIES;
    t.start = L'􏲣';
    t.end = L'􏲤';
    t.fg_color = "#42E2F4";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT_TYPE_MODULE_DEPENDENCIES);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Function_Result_Type_Library_Dependencies() ❰
    Token t;
    t.name = Token_Name::FUNCTION_RESULT_TYPE_LIBRARY_DEPENDENCIES;
    t.start = L'􏲡';
    t.end = L'􏲢';
    t.fg_color = "#42E2F4";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT);
    t.groups.emplace_back(Token_Group::FUNCTION_RESULT_TYPE_LIBRARY_DEPENDENCIES);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Function_Except_Expression() ❰
    Token t;
    t.name = Token_Name::EXCEPT_EXPRESSION;
    t.start = L'􏶸';
    t.end = L'􏶷';
    t.fg_color = "#FFADFF";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_EXCEPT);
    t.description = "a boolean expression as to whether or not to throw an expression";
    return t;
❱

◀private: static▶ Token ☀Function_Except_Comment() ❰
    Token t;
    t.name = Token_Name::EXCEPT_COMMENT;
    t.start = L'􏶶';
    t.end = L'􏶵';
    t.fg_color = "#5C5C5C";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_EXCEPT);
    t.description = "a comment about the exception expression";
    return t;
❱

◀private: static▶ Token ☀Function_Body() ❰
    Token t;
    t.name = Token_Name::FUNCTION_BODY;
    t.start = L'􏶴';
    t.end = L'􏶳';
    t.fg_color = "#FFFFFF";
    t.bg_color = "#015296";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_BODY);
    t.description = "the body of the function/method";
    return t;
❱

◀private: static▶ Token ☀Function_Test_Case_Name() ❰
    Token t;
    t.name = Token_Name::FUNCTION_TEST_CASE_NAME;
    t.start = L'􏴱';
    t.end = L'􏴲';
    t.fg_color = "#0BDC42";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_TEST_CASE);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Function_Test_Case_Tag() ❰
    Token t;
    t.name = Token_Name::FUNCTION_TEST_CASE_TAG;
    t.start = L'􏴯';
    t.end = L'􏴰';
    t.fg_color = "#126427";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_TEST_CASE);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Function_Test_Case_Reason_For_Testing() ❰
    Token t;
    t.name = Token_Name::FUNCTION_TEST_CASE_REASON_FOR_TESTING;
    t.start = L'􏲝';
    t.end = L'􏲞';
    t.fg_color = "#42b3f4";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_TEST_CASE);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Function_Test_Case_Reason_For_Failing() ❰
    Token t;
    t.name = Token_Name::FUNCTION_TEST_CASE_REASON_FOR_FAILING;
    t.start = L'􏲛';
    t.end = L'􏲜';
    t.fg_color = "#1e84bf";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_TEST_CASE);
    t.groups.emplace_back(Token_Group::FUNCTION_TEST_CASE_REASON_FOR_FAILING);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Function_Test_Case_Body() ❰
    Token t;
    t.name = Token_Name::FUNCTION_TEST_CASE_BODY;
    t.start = L'􏴭';
    t.end = L'􏴮';
    t.fg_color = "#FFFFFF";
    t.bg_color = "#1D3723";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_TEST_CASE);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Function_Benchmark_Case_Name() ❰
    Token t;
    t.name = Token_Name::FUNCTION_BENCHMARK_CASE_NAME;
    t.start = L'􏱿';
    t.end = L'􏲀';
    t.fg_color = "#ce3131";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_BENCHMARK);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Function_Benchmark_Case_Tag() ❰
    Token t;
    t.name = Token_Name::FUNCTION_BENCHMARK_CASE_TAG;
    t.start = L'􏱽';
    t.end = L'􏱾';
    t.fg_color = "#f97070";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_BENCHMARK);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Function_Benchmark_Case_Setup() ❰
    Token t;
    t.name = Token_Name::FUNCTION_BENCHMARK_CASE_SETUP;
    t.start = L'􏱻';
    t.end = L'􏱼';
    t.fg_color = "#FFFFFF";
    t.bg_color = "#702c2c";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_BENCHMARK);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Function_Benchmark_Case_Action() ❰
    Token t;
    t.name = Token_Name::FUNCTION_BENCHMARK_CASE_ACTION;
    t.start = L'􏱹';
    t.end = L'􏱺';
    t.fg_color = "#FFFFFF";
    t.bg_color = "#8c0e0e";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_BENCHMARK);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Function_Benchmark_Argument_Name() ❰
    Token t;
    t.name = Token_Name::FUNCTION_BENCHMARK_ARGUMENT_NAME;
    t.start = L'􏱷';
    t.end = L'􏱸';
    t.fg_color = "#ff8132";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_BENCHMARK);
    t.groups.emplace_back(Token_Group::FUNCTION_BENCHMARK_ARG);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Function_Benchmark_Argument_Low() ❰
    Token t;
    t.name = Token_Name::FUNCTION_BENCHMARK_ARGUMENT_LOW;
    t.start = L'􏱵';
    t.end = L'􏱶';
    t.fg_color = "#ff9f63";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_BENCHMARK);
    t.groups.emplace_back(Token_Group::FUNCTION_BENCHMARK_ARG);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Function_Benchmark_Argument_High() ❰
    Token t;
    t.name = Token_Name::FUNCTION_BENCHMARK_ARGUMENT_HIGH;
    t.start = L'􏱳';
    t.end = L'􏱴';
    t.fg_color = "#ff9f63";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_BENCHMARK);
    t.groups.emplace_back(Token_Group::FUNCTION_BENCHMARK_ARG);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Function_Benchmark_Argument_Multiplier() ❰
    Token t;
    t.name = Token_Name::FUNCTION_BENCHMARK_ARGUMENT_MULTIPLIER;
    t.start = L'􏱱';
    t.end = L'􏱲';
    t.fg_color = "#ff6200";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::FUNCTION);
    t.groups.emplace_back(Token_Group::FUNCTION_BENCHMARK);
    t.groups.emplace_back(Token_Group::FUNCTION_BENCHMARK_ARG);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Typedef_Specifiers() ❰
    Token t;
    t.name = Token_Name::TYPEDEF_SPECIFIERS;
    t.start = L'􏴥';
    t.end = L'􏴦';
    t.fg_color = "#662A45";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::TYPEDEF);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Typedef_Brief_Description() ❰
    Token t;
    t.name = Token_Name::TYPEDEF_BRIEF_DESCRIPTION;
    t.start = L'􏴣';
    t.end = L'􏴤';
    t.fg_color = "#66432A";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::TYPEDEF);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Typedef_Detailed_Description() ❰
    Token t;
    t.name = Token_Name::TYPEDEF_DETAILED_DESCRIPTION;
    t.start = L'􏴡';
    t.end = L'􏴢';
    t.fg_color = "#66652A";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::TYPEDEF);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Typedef_Name() ❰
    Token t;
    t.name = Token_Name::TYPEDEF_NAME;
    t.start = L'􏴟';
    t.end = L'􏴠';
    t.fg_color = "#D69125";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::TYPEDEF);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Typedef_Return() ❰
    Token t;
    t.name = Token_Name::TYPEDEF_RETURN;
    t.start = L'􏴝';
    t.end = L'􏴞';
    t.fg_color = "#366D6B";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::TYPEDEF);
    t.groups.emplace_back(Token_Group::TYPEDEF_RESULT);
    t.description = "";
    return t;
❱
◀private: static▶ Token ☀Typedef_Return_Comment() ❰
    Token t;
    t.name = Token_Name::TYPEDEF_RETURN_COMMENT;
    t.start = L'􏴛';
    t.end = L'􏴜';
    t.fg_color = "#5C5C5C";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::TYPEDEF);
    t.groups.emplace_back(Token_Group::TYPEDEF_RESULT);
    t.description = "";
    return t;
❱ 
◀private: static▶ Token ☀Typedef_Argument() ❰
    Token t;
    t.name = Token_Name::TYPEDEF_ARGUMENT;
    t.start = L'􏴙';
    t.end = L'􏴚';
    t.fg_color = "#2A4866";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::TYPEDEF);
    t.groups.emplace_back(Token_Group::TYPEDEF_ARGUMENT);
    t.description = "";
    return t;
❱ 
◀private: static▶ Token ☀Typedef_Argument_Comment() ❰
    Token t;
    t.name = Token_Name::TYPEDEF_ARGUMENT_COMMENT;
    t.start = L'􏴗';
    t.end = L'􏴘';
    t.fg_color = "#5C5C5C";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::TYPEDEF);
    t.groups.emplace_back(Token_Group::TYPEDEF_ARGUMENT);
    t.description = "";
    return t;
❱

◀private: static▶ Token ☀Data_Member_Brief() ❰
    Token t;
    t.name = Token_Name::DATA_MEMBER_BRIEF;
    t.start = L'􏶨';
    t.end = L'􏶧';
    t.fg_color = "#66432A";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::DATA_MEMBER);
    t.description = "brief comment about the data member or global variable";
    return t;
❱

◀private: static▶ Token ☀Data_Member_Detailed() ❰
    Token t;
    t.name = Token_Name::DATA_MEMBER_DETAILED;
    t.start = L'􏶦';
    t.end = L'􏶥';
    t.fg_color = "#66652A";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::DATA_MEMBER);
    t.description = "detailed comment about the data member or global variable";
    return t;
❱

◀private: static▶ Token ☀Data_Member_Class_Specifiers() ❰
    Token t;
    t.name = Token_Name::DATA_MEMBER_CLASS_SPECIFIERS;
    t.start = L'􏶘';
    t.end = L'􏶙';
    t.fg_color = "#BB4114";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::DATA_MEMBER);
    t.description = "class qualifiers / static for the data member or global variables";
    return t;
❱

◀private: static▶ Token ☀Data_Member_Type_Qualifiers() ❰
    Token t;
    t.name = Token_Name::DATA_MEMBER_TYPE_QUALIFIERS;
    t.start = L'􏶰';
    t.end = L'􏶯';
    t.fg_color = "#D67425";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::DATA_MEMBER);
    t.description = "qualifiers for the type";
    return t;
❱

◀private: static▶ Token ☀Data_Member_Identifier() ❰
    Token t;
    t.name = Token_Name::DATA_MEMBER_IDENTIFIER;
    t.start = L'􏶬';
    t.end = L'􏶫';
    t.fg_color = "#D69125";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::DATA_MEMBER);
    t.description = "the identifier of one of the data members or global variables";
    return t;
❱

◀private: static▶ Token ☀Data_Member_Units() ❰
    Token t;
    t.name = Token_Name::DATA_MEMBER_UNITS;
    t.start = L'􏵚';
    t.end = L'􏵛';
    t.fg_color = "#D7B859";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::DATA_MEMBER);
    t.description = "the units of the identifier";
    return t;
❱

◀private: static▶ Token ☀Data_Member_Default_Value() ❰
    Token t;
    t.name = Token_Name::DATA_MEMBER_DEFAULT_VALUE;
    t.start = L'􏶪';
    t.end = L'􏶩';
    t.fg_color = "#FFFFFF";
    t.bg_color = "#000000";
    t.groups.emplace_back(Token_Group::DATA_MEMBER);
    t.description = "the default value of the data member or global variable";
    return t;
❱

◀public: static▶ All_Language_Tokens ☀Get_deprecated() ❰

const std::vector<Token> TOKENS
{Meta_Code_Type()
,Meta_Brief_Comment()
,Meta_Detail_Comment()
,Meta_Group_Name()
,Meta_Author()
,Meta_Bug()
,Meta_Warning()
,Meta_Depreciation()
    ,Meta_Subgroup_Name()
    ,Meta_Subgroup_Description()
    ,Meta_Specification_File_Path()
    ,Meta_Specification_File_Description()
    ,Meta_Forseeable_Change()
    ,Meta_Forseeable_Change_Reason()
    ,Meta_Forseeable_Change_Reason_Percentage()
,Type_Brief_Description()
,Type_Detailed_Description()
,Type_Name()
,Library()
,COPTS()
,LINKOPTS()
,Import_Interface_Specifiers()
,Import_Interface_Name()
,Import_Interface_Comment()
    ,Import_Interface_Relationship()
    ,Import_Interface_Related()
,Import_Implementation_Specifiers()
,Import_Implementation_Name()
,Import_Implementation_Comment()
    ,Import_Implementation_Relationship()
    ,Import_Implementation_Related()
,Import_Test_Specifiers()
,Import_Test_Name()
,Import_Test_Comment()
    ,Import_Test_Relationship()
    ,Import_Test_Related()
,Namespace_Specifiers()
,Namespace_Name()
,Inheritance_Specifiers()
,Inheritance_Type()
,Forward_Declare_Argument()
,Object_Template_Argument_Qualifiers() 
,Object_Template_Argument_Type() 
,Object_Template_Argument_Identifier() 
,Object_Template_Argument_Default() 
,Object_Template_Argument_Units() 
,Object_Template_Argument_Comment()
    ,Object_Template_Argument_Type_Concepts()
,Function_Class_Specifiers()
,Function_Subgroup_Name()
,Function_Brief_Description()
,Function_Detailed_Description()
,Function_Detailed_Name()
,Function_Unique_Mangle_Name()
    ,Function_Alternative_Expression_Name()
    ,Function_Precondition()
    ,Function_Precondition_Comment()
    ,Function_Postcondition()
    ,Function_Postcondition_Comment()
    ,Function_Stamp_Name()
        ,Function_Stamp_Value()
    ,Function_Template_Argument_Qualifiers()
    ,Function_Template_Argument_Type()
    ,Function_Template_Argument_Identifier()
    ,Function_Template_Argument_Default()
    ,Function_Template_Argument_Units()
    ,Function_Template_Argument_Comment()
    ,Function_Template_Argument_Concepts()
    ,Function_Argument_Type_Qualifiers()
    ,Function_Argument_Type()
    ,Function_Argument_Type_Scope()
    ,Function_Argument_Type_Specializations()
    ,Function_Argument_Type_Specializations_Scope()
    ,Function_Argument_Identifier()
    ,Function_Argument_Units()
    ,Function_Argument_Default()
    ,Function_Argument_Comment()
        ,Function_Argument_Type_Module_Dependencies()
        ,Function_Argument_Type_Library_Dependencies()
    ,Function_Result_Type_Qualifiers()
    ,Function_Result_Type()
    ,Function_Result_Type_Identifier()
    ,Function_Result_Units()
    ,Function_Result_Default()
    ,Function_Result_Comment()
        ,Function_Result_Type_Scope()
        ,Function_Result_Type_Specializations()
            ,Function_Result_Type_Specializations_Scope()
        ,Function_Result_Type_Module_Dependencies()
        ,Function_Result_Type_Library_Dependencies()
    ,Function_Except_Expression()
    ,Function_Except_Comment()
    ,Function_Body()
    ,Function_Test_Case_Name()
    ,Function_Test_Case_Tag()
    ,Function_Test_Case_Reason_For_Testing()
        ,Function_Test_Case_Reason_For_Failing()
    ,Function_Test_Case_Body()
    ,Function_Benchmark_Case_Name()
    ,Function_Benchmark_Case_Tag()
    ,Function_Benchmark_Case_Setup()
    ,Function_Benchmark_Case_Action()
    ,Function_Benchmark_Argument_Name()
    ,Function_Benchmark_Argument_Low()
    ,Function_Benchmark_Argument_High()
    ,Function_Benchmark_Argument_Multiplier()
    ,Typedef_Specifiers()
    ,Typedef_Brief_Description()
    ,Typedef_Detailed_Description()
    ,Typedef_Name()
    ,Typedef_Return()
    ,Typedef_Return_Comment()
    ,Typedef_Argument()
    ,Typedef_Argument_Comment()
    ,Data_Member_Brief()
    ,Data_Member_Detailed()
    ,Data_Member_Class_Specifiers()
    ,Data_Member_Type_Qualifiers()
    ,Data_Member_Identifier()
    ,Data_Member_Units()
    ,Data_Member_Default_Value()
    



//serialization properties:
,{Token_Name::DATA_MEMBER_PARTIAL_PACK_AMOUNT,            L'􏴷',L'􏴸',"#EF00FF","#000000",0,0,0,1,1,1,1,1, {Token_Group::DATA_MEMBER},"the amount of elements to partially pack an array"}
//bit packing?
//endianess?
//address size envariances?

,{Token_Name::DATA_MEMBER_TYPE,                           L'􏶮',L'􏶭',"#2A4866","#000000",0,0,0,1,1,1,1,1, {Token_Group::DATA_MEMBER},"the type of one of the data members or global variables"}
,{Token_Name::INDEXES_TO_IDENTIFIER,                      L'􏲳',L'􏲴',"#2A4866","#000000",0,0,0,1,1,1,1,1, {Token_Group::DATA_MEMBER},""}
,{Token_Name::DATA_MEMBER_SCOPE,                          L'􏲷',L'􏲸',"#2A4866","#000000",0,0,0,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_SCOPE},""}
,{Token_Name::DATA_MEMBER_TYPE_SPECIALIZATIONS,           L'􏳟',L'􏳠',"#2A4866","#000000",0,0,0,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_TYPE_SPECIALIZATIONS},""}
,{Token_Name::DATA_MEMBER_TYPE_SPECIALIZATIONS_SCOPE,     L'􏲵',L'􏲶',"#2A4866","#000000",0,0,0,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_TYPE_SPECIALIZATIONS,Token_Group::DATA_MEMBER_TYPE_SPECIALIZATIONS_SCOPE},""}
,{Token_Name::DATA_MEMBER_TYPE_MODULE_DEPENDENCIES,       L'􏲹',L'􏲺',"#42E2F4","#000000",0,0,0,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_TYPE_MODULE_DEPENDENCIES},""}
,{Token_Name::DATA_MEMBER_TYPE_LIBRARY_DEPENDENCIES,      L'􏲱',L'􏲲',"#42E2F4","#000000",0,0,0,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_TYPE_LIBRARY_DEPENDENCIES},""}
,{Token_Name::DATA_MEMBER_PARENT_TYPE,                    L'􏷔',L'􏷓',"#42E2F4","#000000",0,0,0,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::PARENT_TYPES},""}

  
  //data member key value pairs
  ,{Token_Name::DATA_MEMBER_PAIR_KEY,                L'􏵁',L'􏵂',"#4C7B92","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_KEY_VALUES},""}
  ,{Token_Name::DATA_MEMBER_PAIR_VALUE,              L'􏴿',L'􏵀',"#6BC7F5","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_KEY_VALUES},""}
  
  //data member value constraints
  ,{Token_Name::DATA_MEMBER_CONSTRAINT_OPERATION,       L'􏴽',L'􏴾',"#FB3535","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_VALUE_CONSTRAINTS},""}
  ,{Token_Name::DATA_MEMBER_CONSTRAINT_VALUE,           L'􏴵',L'􏴶',"#FF7676","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_VALUE_CONSTRAINTS},""}
  ,{Token_Name::DATA_MEMBER_BROKEN_CONSTRAINT_MEANING,  L'􏳭',L'􏳮',"#ea908f","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_VALUE_CONSTRAINTS},""}
  ,{Token_Name::DATA_MEMBER_CONSTRAINT_DISPLAY_THEME,   L'􏳫',L'􏳬',"#edb5b4","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_VALUE_CONSTRAINTS},""}
  
  //data member defined value
  ,{Token_Name::DATA_MEMBER_DEFINED_VALUE_OPERATION,       L'􏳩',L'􏳪',"#14541f","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_VALUE_MEANING},""}
  ,{Token_Name::DATA_MEMBER_DEFINED_VALUE,                 L'􏴻',L'􏴼',"#137E45","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_VALUE_MEANING},""}
  ,{Token_Name::DATA_MEMBER_DEFINED_VALUE_MEANING,         L'􏴹',L'􏴺',"#2CEC85","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_VALUE_MEANING},""}
  ,{Token_Name::DATA_MEMBER_DEFINED_VALUE_DISPLAY_THEME,   L'􏳧',L'􏳨',"#90f9a4","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_VALUE_MEANING},""}

  //data member value transition tokens
  ,{Token_Name::DATA_MEMBER_TRANSITION_BEFORE_OPERATION, L'􏳷',L'􏳸',"#463300","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_VALUE_TRANSITION_MEANING},""}
  ,{Token_Name::DATA_MEMBER_TRANSITION_BEFORE_VALUE,     L'􏳵',L'􏳶',"#8c6600","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_VALUE_TRANSITION_MEANING},""}
  ,{Token_Name::DATA_MEMBER_TRANSITION_AFTER_OPERATION,  L'􏳳',L'􏳴',"#d19a00","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_VALUE_TRANSITION_MEANING},""}
  ,{Token_Name::DATA_MEMBER_TRANSITION_AFTER_VALUE,      L'􏳱',L'􏳲',"#ffc72e","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_VALUE_TRANSITION_MEANING},""}
  ,{Token_Name::DATA_MEMBER_TRANSITION_MEANING,          L'􏳯',L'􏳰',"#ffd973","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_VALUE_TRANSITION_MEANING},""}
  ,{Token_Name::DATA_MEMBER_TRANSITION_DISPLAY_THEME,    L'􏳥',L'􏳦',"#d3cda2","#000000",1,0,1,1,1,1,1,1, {Token_Group::DATA_MEMBER,Token_Group::DATA_MEMBER_VALUE_TRANSITION_MEANING},""}
  

//enumerated type
,{Token_Name::ENUM_BRIEF,                                 L'􏶊',L'􏶉',"#66432A","#000000",1,0,1,1,1,1,1,1, {Token_Group::ENUM},"a brief comment about the enumerated type"}
,{Token_Name::ENUM_DETAIL,                                L'􏶈',L'􏶇',"#66652A","#000000",1,0,1,1,1,1,1,1, {Token_Group::ENUM},"details about the enumerated type"}
,{Token_Name::ENUM_NAME,                                  L'􏶀',L'􏶋',"#C35A00","#000000",0,0,0,1,1,1,1,1, {Token_Group::ENUM},"the name of an enumerated type"}
,{Token_Name::ENUM_SPECIFIERS,                            L'􏵮',L'􏵯',"#5C5C5C","#000000",0,0,1,1,1,1,1,1, {Token_Group::ENUM},"i=iterable"}
,{Token_Name::ENUM_BASE_TYPE,                             L'􏵬',L'􏵭',"#5C5C5C","#000000",0,0,1,1,1,1,1,1, {Token_Group::ENUM},"the underlying base type of the enum(applies C++11 and up)"}
    ,{Token_Name::ENUM_SUBGROUP_NAME,                         L'􏳿',L'􏴀',"#4C7B92","#000000",0,0,1,1,1,1,1,1, {Token_Group::ENUM,Token_Group::ENUM_SUBGROUP},"name of an enumerated subgroup"}
    ,{Token_Name::ENUM_SUBGROUP_DESCRIPTION,                  L'􏳽',L'􏳾',"#6BC7F5","#000000",0,0,1,1,1,1,1,1, {Token_Group::ENUM,Token_Group::ENUM_SUBGROUP},"description of the enumerated subgroup"}


    //enum values
    ,{Token_Name::ENUM_ARG_NAME,                          L'􏶆',L'􏶅',"#66AD23","#000000",0,0,0,1,1,1,1,1, {Token_Group::ENUM,Token_Group::ENUM_ARG},"one of the enumerated type's values"}
    ,{Token_Name::ENUM_ARG_VALUE,                         L'􏶄',L'􏶃',"#23AD8D","#000000",0,0,0,1,1,1,1,1, {Token_Group::ENUM,Token_Group::ENUM_ARG},"the integer that the enumerated value represents"}
    ,{Token_Name::ENUM_ARG_COMMENT,                       L'􏶂',L'􏶁',"#5C5C5C","#000000",1,0,1,1,1,1,1,1, {Token_Group::ENUM,Token_Group::ENUM_ARG},"a comment about that particular enumerated value"}
        ,{Token_Name::ENUM_ARG_GROUP_AFFILIATION,             L'􏳻',L'􏳼',"#70FFFF","#000000",1,0,1,1,1,1,1,1, {Token_Group::ENUM,Token_Group::ENUM_ARG,Token_Group::ENUM_GROUP_AFFILIATION},"the affiliated group (if any) that the enum arg belongs to"}

//MACRO
,{Token_Name::MACRO_SPECIFIERS,                        L'􏵐',L'􏵑',"#E87272","#000000",0,0,0,1,1,1,1,1, {Token_Group::MACRO},"macro specifiers"}
,{Token_Name::MACRO_NAME,                              L'􏵾',L'􏵿',"#9C4747","#000000",0,0,0,1,1,1,1,1, {Token_Group::MACRO},"macro name"}
,{Token_Name::MACRO_UNITS,                             L'􏵖',L'􏵗',"#FF0000","#000000",0,0,0,1,1,1,1,1, {Token_Group::MACRO},"macro units"}

    //macro arguments
    ,{Token_Name::MACRO_ARGUMENT_IDENTIFIER,           L'􏴩',L'􏴪',"#66432A","#000000",1,0,1,1,1,1,1,1, {Token_Group::MACRO,Token_Group::MACRO_ARGUMENT},"macro argument"}
    ,{Token_Name::MACRO_ARGUMENT_COMMENT,              L'􏴧',L'􏴨',"#66432A","#000000",1,0,1,1,1,1,1,1, {Token_Group::MACRO,Token_Group::MACRO_ARGUMENT},"macro argument comment"}
    
    //maco values
    ,{Token_Name::MACRO_BRIEF,                             L'􏵺',L'􏵻',"#66432A","#000000",1,0,1,1,1,1,1,1, {Token_Group::MACRO,Token_Group::MACRO_VALUE},"macro brief statement"}
    ,{Token_Name::MACRO_DETAIL,                            L'􏵸',L'􏵹',"#66652A","#000000",1,0,1,1,1,1,1,1, {Token_Group::MACRO,Token_Group::MACRO_VALUE},"macro brief statement"}
    ,{Token_Name::MACRO_VALUE,                             L'􏵼',L'􏵽',"#5C5C5C","#000000",0,0,1,1,1,1,1,1, {Token_Group::MACRO,Token_Group::MACRO_VALUE},"macro value"}

//file wide invariants
,{Token_Name::FILE_WIDE_INVARIANT,            L'􏵠',L'􏵡',"#5F00A3","#000000",1,0,0,0,1,1,1,1, {Token_Group::FILE_WIDE_INVARIANT},"an invariant that holds true between all function calls"}
,{Token_Name::FILE_WIDE_INVARIANT_COMMENT,    L'􏵞',L'􏵟',"#5F00A3","#000000",1,0,0,0,1,1,1,1, {Token_Group::FILE_WIDE_INVARIANT},"an invariant that holds true between all function calls"}

//miscellaneous
,{Token_Name::RUN_SHELL_COMMAND,              L'􏶤',L'􏶣',"#5F00A3","#000000",1,0,0,0,1,1,1,1, {Token_Group::OTHER},"run a shell command and replace the token with the contents.  This happens again and again until there are no shell commands left.  So a shell command can create more shell commands to run"}

//UNIT TESTS:
,{Token_Name::TEST_CASE_NAME,              L'􏵎',L'􏵏',"#0BDC42","#000000",1,0,0,0,1,1,1,1, {Token_Group::TEST_CASE},"the name of the test case"}
,{Token_Name::TEST_CASE_TAG,               L'􏵌',L'􏵍',"#126427","#000000",1,0,0,0,1,1,1,1, {Token_Group::TEST_CASE},"a tag to identify the test case"}
,{Token_Name::TEST_CASE_BODY,              L'􏵊',L'􏵋',"#FFFFFF","#1D3723",1,0,0,0,1,1,1,1, {Token_Group::TEST_CASE},"the body of a test case"}


};

//symbols / bg/fg / could be doxygen / documentation related / usable in global / usable in object / groups / description
const std::vector<Body_Token> BODY_TOKENS
{{Body_Token_Name::REGULAR_COMMENT               ,L'􏶲',L'􏶱',"#5C5C5C","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY},""}
,{Body_Token_Name::TODO_COMMENT             ,L'􏲙',L'􏲚',"#5BAEAB","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY},""}
,{Body_Token_Name::WARNING_COMMENT             ,L'􏲗',L'􏲘',"#5BAEAB","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY},""}

,{Body_Token_Name::REGULAR_STATEMENT             ,L'􏲕',L'􏲖',"#5BAEAB","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY},""}
,{Body_Token_Name::RETURN_STATEMENT             ,L'􏲓',L'􏲔',"#5BAEAB","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY},""}
,{Body_Token_Name::UNCAUGHT_STATEMENT             ,L'􏲑',L'􏲒',"#5BAEAB","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY},""}


,{Body_Token_Name::STATEMENT             ,L'􏴕',L'􏴖',"#5BAEAB","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY,Body_Token_Group::STATEMENT},"a statement inside of a function"}
//control structures ..?


//TODO: shift into STATEMENT
,{Body_Token_Name::BODY_PARAMETER        ,L'􏵶',L'􏵷',"#EF53EF","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY,Body_Token_Group::BODY_PARAMETER},"the use of a function parameter inside a function"}
,{Body_Token_Name::SELF_DATA_MEMBER         ,L'􏵴',L'􏵵',"#D69125","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY,Body_Token_Group::SELF_DATA_MEMBER},"the use of a local data member inside a function"}
,{Body_Token_Name::SELF_DATA_MEMBER_WITHOUT_OBJ  ,L'􏳉',L'􏳊',"#D69125","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY,Body_Token_Group::SELF_DATA_MEMBER_WITHOUT_OBJ},"the use of a local data member inside a function"}
,{Body_Token_Name::LOCAL_DATA_MEMBER     ,L'􏵈',L'􏵉',"#2529DB","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY,Body_Token_Group::LOCAL_DATA_MEMBER},"a variable instantiated in the scope of the method"}
,{Body_Token_Name::SUB_MEMBER            ,L'􏵆',L'􏵇',"#5F00A3","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY,Body_Token_Group::SUB_MEMBER},"a child member of a particular member"}
,{Body_Token_Name::SELF_FUNCTION_CALL    ,L'􏵲',L'􏵳',"#C35A00","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY,Body_Token_Group::SELF_FUNCTION_CALL},"the call to another local function inside a function"}
,{Body_Token_Name::FOREIGN_FUNCTION_CALL ,L'􏵄',L'􏵅',"#DB252B","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY,Body_Token_Group::FOREIGN_FUNCTION_CALL},"a function call that exists outside outside the structure"}
,{Body_Token_Name::RETURN                ,L'􏵢',L'􏵣',"#5BAEAB","#051726",1,0,0,0,1,1,1,1, {Body_Token_Group::METHOD_BODY,Body_Token_Group::RETURN},"the return statement inside of a function"}
};


//additional depreciations

//do we turn self function call into just "function call"
//or do we separate them and make a new "external function call"?
//both/\ (local/external/have the compiler figure it out)

//deceleration:
//brief
//detail
//type qualifiers
//type
//identifier
//default value
//(C would place these at the top of functions automatically)


//constraints on the value:
//must not exceed 8 (self <= 8)
//could do weird things like 'must be even' (IsEven(self))
    
//network data packing.
//serialization/de-serialization
//We need an attribute language for describing network data packing/unpacking.
//this will apply to data members
//Things to consider:
//address size invariance:
//    DWORD (8 bytes)
//    WORD (4 bytes)
    
//endianess:
//    big / small /middle
    
//bit packing:
//for example: 8 bools packed into a byte
    
//padding and no padding
//use pragmas to prevent struct padding [I added the token already]
    
//oh! we need universal type mapping.
//a set of basic types that I can use in any language, and have a converter available


//------------------
//testing:
//we need to read a few books on unit testing first

//split into 4 separate blocks?
//-arrange
//-assume
//-act
//-assert
//*some people are saying that the assume part is not needed.  
//if you wanted to do something before your act, you would have tests like:
//arrange, empty act, assert.  followed by another test that does arrange, empty act, assert

//this test proves: __
//this test will catch: __
//if the test breaks, it means: __
//----------------------




//future tokens:

All_Language_Tokens all;
all.tokens = TOKENS;
all.body_tokens = BODY_TOKENS;

all.standalone_symbols.CLASS_NAME_CODE_FORM_MACRO = L'􏶐';
all.standalone_symbols.CLASS_NAME_PRINT_FORM_MACRO = L'􏶏';
all.standalone_symbols.TEST_OBJECT_CLASS_NAME = L'􏶍';
all.standalone_symbols.ESCAPE_CHARACTER = L'􏶎';
all.standalone_symbols.NULL_MACRO=L'􏵃';
all.standalone_symbols.TRUE_MACRO = L'􏵱';
all.standalone_symbols.FALSE_MACRO = L'􏵰';

return all;

❱