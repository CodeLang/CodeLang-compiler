class


❪"code/transcompilers/unilang/type_converters/unilang-type-to-language-type-converter/languages/equivalent_language_types"❫
⚯
❪"code/utilities/types/tri_bool"❫
⚞⚟

//nothing
◀public: static▶ Equivalent_Language_Types ☀Void()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "void";
    types.cpp.name = "void";
    types.d.name = "void";
    types.rust.name = "()";
    types.holyC.name = "U0";
    types.java.name = "void";
    types.csharp.name = "void";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "void";
    types.processing.name = "void";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀NullPtr()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "void*";
    types.cpp.name = "std::nullptr_t";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "void*";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱

//bytes
◀public: static▶ Equivalent_Language_Types ☀Xbyte()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "char";
    types.cpp.name = "char";
    types.d.name = "byte";
    types.rust.name = "i8";
    types.holyC.name = "I8";
    types.java.name = "byte";
    types.csharp.name = "byte";
    types.pascal.name = "Byte";
    types.ml.name = "";
    types.go.name = "int8";
    types.protocol_buffers.name = "bytes";
    types.hidl.name = "int8";
    types.processing.name = "byte";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Byte()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "signed char";
    types.cpp.name = "signed char";
    types.d.name = "byte";
    types.rust.name = "i8";
    types.holyC.name = "I8";
    types.java.name = "byte";
    types.csharp.name = "Shortint";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "int8";
    types.protocol_buffers.name = "bytes";
    types.hidl.name = "uint8";
    types.processing.name = "byte";

    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀UByte()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "unsigned char";
    types.cpp.name = "unsigned char";
    types.d.name = "ubyte";
    types.rust.name = "u8";
    types.holyC.name = "U8";
    types.java.name = "byte";
    types.csharp.name = "byte";
    types.pascal.name = "Byte";
    types.ml.name = "";
    types.go.name = "uint8";
    types.protocol_buffers.name = "bytes";
    types.hidl.name = "uint8";
    types.processing.name = "byte";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱

//shorts
◀public: static▶ Equivalent_Language_Types ☀S()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "short";
    types.cpp.name = "short";
    types.d.name = "short";
    types.rust.name = "i16";
    types.holyC.name = "I16";
    types.java.name = "short";
    types.csharp.name = "SmallInt";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "int16";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Us()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "unsigned short";
    types.cpp.name = "unsigned short";
    types.d.name = "ushort";
    types.rust.name = "u16";
    types.holyC.name = "U16";
    types.java.name = "short";
    types.csharp.name = "ushort";
    types.pascal.name = "Word";
    types.ml.name = "";
    types.go.name = "uint16";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱

//ints
◀public: static▶ Equivalent_Language_Types ☀I()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "int";
    types.cpp.name = "int";
    types.d.name = "int";
    types.rust.name = "i32";
    types.holyC.name = "I32";
    types.java.name = "int";
    types.csharp.name = "int";
    types.pascal.name = "Integer";
    types.ml.name = "";
    types.go.name = "int";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Ui()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "unsigned int";
    types.cpp.name = "unsigned int";
    types.d.name = "uint";
    types.rust.name = "u32";
    types.holyC.name = "U32";
    types.java.name = "int";
    types.csharp.name = "uint";
    types.pascal.name = "Integer";
    types.ml.name = "";
    types.go.name = "uint";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀L()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "long";
    types.cpp.name = "long";
    types.d.name = "long";
    types.rust.name = "i64";
    types.holyC.name = "I64";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Longint";
    types.ml.name = "";
    types.go.name = "int64";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Ul()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "unsigned long";
    types.cpp.name = "unsigned long";
    types.d.name = "ulong";
    types.rust.name = "u64";
    types.holyC.name = "U64";
    types.java.name = "long";
    types.csharp.name = "ulong";
    types.pascal.name = "Longword";
    types.ml.name = "";
    types.go.name = "uint64";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Ll()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "long long";
    types.cpp.name = "long long";
    types.d.name = "long";
    types.rust.name = "i64";
    types.holyC.name = "I64";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Int64";
    types.ml.name = "";
    types.go.name = "int64";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Ull()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "unsigned long long";
    types.cpp.name = "unsigned long long";
    types.d.name = "long";
    types.rust.name = "i64";
    types.holyC.name = "I64";
    types.java.name = "long";
    types.csharp.name = "ulong";
    types.pascal.name = "QWord";
    types.ml.name = "";
    types.go.name = "uint64";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱

//floating
◀public: static▶ Equivalent_Language_Types ☀F()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "float";
    types.cpp.name = "float";
    types.d.name = "float";
    types.rust.name = "f32";
    types.holyC.name = "F64";
    types.java.name = "float";
    types.csharp.name = "float";
    types.pascal.name = "Single";
    types.ml.name = "";
    types.ml.name = "float32";
    types.protocol_buffers.name = "float";
    types.hidl.name = "float32";
    types.processing.name = "float";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀D()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "double";
    types.cpp.name = "double";
    types.d.name = "double";
    types.rust.name = "f64";
    types.holyC.name = "F64";
    types.java.name = "double";
    types.csharp.name = "double";
    types.pascal.name = "Double";
    types.ml.name = "float64";
    types.protocol_buffers.name = "double";
    types.hidl.name = "float64";
    types.processing.name = "double";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Ld()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "long double";
    types.cpp.name = "long double";
    types.d.name = "real";
    types.rust.name = "f64";
    types.holyC.name = "F64";
    types.java.name = "double";
    types.csharp.name = "decimal";
    types.pascal.name = "Extend";
    types.ml.name = "float64";
    types.protocol_buffers.name = "double";
    types.hidl.name = "float64";
    types.processing.name = "double";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱

//imaginary
◀public: static▶ Equivalent_Language_Types ☀If()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Id()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Ild()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱

//complexes
◀public: static▶ Equivalent_Language_Types ☀Cf()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Cd()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Cld()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱

//characters
◀public: static▶ Equivalent_Language_Types ☀AsciiChar()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "char";
    types.cpp.name = "char";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "bytes";
    types.hidl.name = "uint8";
    types.processing.name = "char";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Utf8Char()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "char";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "string";
    types.hidl.name = "string";
    types.processing.name = "char";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Utf16Char()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "string";
    types.hidl.name = "string";
    types.processing.name = "char";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Utf32Char()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "string";
    types.processing.name = "char";
    
    //needed imports
    
    //size information
    
    return types;
❱

//string
◀public: static▶ Equivalent_Language_Types ☀AsciiString()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "char*";
    types.cpp.name = "std::string";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "string";
    types.hidl.name = "string";
    types.processing.name = "String";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "string";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Utf8String()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "char*";
    types.cpp.name = "std::string";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "string";
    types.hidl.name = "string";
    types.processing.name = "String";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Utf16String()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "char*";
    types.cpp.name = "std::string";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "string";
    types.hidl.name = "string";
    types.processing.name = "String";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Utf32String()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "char*";
    types.cpp.name = "std::string";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "string";
    types.hidl.name = "string";
    types.processing.name = "String";
    
    //needed imports
    
    //size information
    
    return types;
❱

//multiple precision numerical types
◀public: static▶ Equivalent_Language_Types ☀Z()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀R()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀C()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱

//pointer/memory carry over nonsense
◀public: static▶ Equivalent_Language_Types ☀Size()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "size_t";
    types.cpp.name = "std::size_t";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    {
        Needed_Import import;
        import.name = "Defs";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "cstddef";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Iptr()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Uptr()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Imax()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Umax()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Imin()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Umin()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱

//FIXED SIZES
//normal (signed)
◀public: static▶ Equivalent_Language_Types ☀I8()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "int8_t";
    types.cpp.name = "int8_t";
    types.d.name = "byte";
    types.rust.name = "i8";
    types.holyC.name = "I8";
    types.java.name = "byte";
    types.csharp.name = "sbyte";
    types.pascal.name = "Shortint";
    types.ml.name = "";
    types.go.name = "int8";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int8";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀I16()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "int16_t";
    types.cpp.name = "int16_t";
    types.d.name = "short";
    types.rust.name = "i16";
    types.holyC.name = "I16";
    types.java.name = "short";
    types.csharp.name = "short";
    types.pascal.name = "Smallint";
    types.ml.name = "";
    types.go.name = "int16";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int16";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀I32()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "int32_t";
    types.cpp.name = "int32_t";
    types.d.name = "int";
    types.rust.name = "i32";
    types.holyC.name = "I32";
    types.java.name = "int";
    types.csharp.name = "int";
    types.pascal.name = "Longint";
    types.ml.name = "";
    types.go.name = "int32";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀I64()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "int64_t";
    types.cpp.name = "int64_t";
    types.d.name = "long";
    types.rust.name = "i64";
    types.holyC.name = "I64";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Int64";
    types.ml.name = "";
    types.go.name = "int64";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀I128()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "cent";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Int64";
    types.ml.name = "";
    types.go.name = "int64";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱

//normal (unsigned)
◀public: static▶ Equivalent_Language_Types ☀U8()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "uint8_t";
    types.cpp.name = "uint8_t";
    types.d.name = "ubyte";
    types.rust.name = "u8";
    types.holyC.name = "U8";
    types.java.name = "byte";
    types.csharp.name = "byte";
    types.pascal.name = "Byte";
    types.ml.name = "";
    types.go.name = "uint8";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint8";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀U16()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "uint16_t";
    types.cpp.name = "uint16_t";
    types.d.name = "ushort";
    types.rust.name = "u16";
    types.holyC.name = "U16";
    types.java.name = "char";
    types.csharp.name = "ushort";
    types.pascal.name = "Word";
    types.ml.name = "";
    types.go.name = "uint16";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint16";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀U32()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "uint32_t";
    types.cpp.name = "uint32_t";
    types.d.name = "uint";
    types.rust.name = "u32";
    types.holyC.name = "U32";
    types.java.name = "int";
    types.csharp.name = "uint";
    types.pascal.name = "Longword";
    types.ml.name = "";
    types.go.name = "uint32";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀U64()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "uint64_t";
    types.cpp.name = "uint64_t";
    types.d.name = "ulong";
    types.rust.name = "u64";
    types.holyC.name = "U64";
    types.java.name = "long";
    types.csharp.name = "ulong";
    types.pascal.name = "QWord";
    types.ml.name = "";
    types.go.name = "uint64";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀U128()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "ucent";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "long";
    types.csharp.name = "ulong";
    types.pascal.name = "QWord";
    types.ml.name = "";
    types.go.name = "uint64";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱

//fast (signed)
◀public: static▶ Equivalent_Language_Types ☀Fast_I8()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "int_fast8_t";
    types.cpp.name = "int_fast8_t";
    types.d.name = "byte";
    types.rust.name = "i8";
    types.holyC.name = "I8";
    types.java.name = "byte";
    types.csharp.name = "sbyte";
    types.pascal.name = "Shortint";
    types.ml.name = "";
    types.go.name = "int8";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Fast_I16()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "int_fast16_t";
    types.cpp.name = "int_fast16_t";
    types.d.name = "short";
    types.rust.name = "i16";
    types.holyC.name = "I16";
    types.java.name = "short";
    types.csharp.name = "short";
    types.pascal.name = "Smallint";
    types.ml.name = "";
    types.go.name = "int16";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int16";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Fast_I32()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "int_fast32_t";
    types.cpp.name = "int_fast32_t";
    types.d.name = "int";
    types.rust.name = "i32";
    types.holyC.name = "I32";
    types.java.name = "int";
    types.csharp.name = "int";
    types.pascal.name = "Longint";
    types.ml.name = "";
    types.go.name = "int32";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Fast_I64()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "int_fast64_t";
    types.cpp.name = "int_fast64_t";
    types.d.name = "long";
    types.rust.name = "i64";
    types.holyC.name = "I64";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Int64";
    types.ml.name = "";
    types.go.name = "int64";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int64";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Fast_I128()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "cent";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Int64";
    types.ml.name = "";
    types.go.name = "int128";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱

//fast (unsigned)
◀public: static▶ Equivalent_Language_Types ☀Fast_U8()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "uint_fast8_t";
    types.cpp.name = "uint_fast8_t";
    types.d.name = "ubyte";
    types.rust.name = "u8";
    types.holyC.name = "U8";
    types.java.name = "byte";
    types.csharp.name = "byte";
    types.pascal.name = "Byte";
    types.ml.name = "";
    types.go.name = "uint8";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint8";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Fast_U16()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "uint_fast16_t";
    types.cpp.name = "uint_fast16_t";
    types.d.name = "ushort";
    types.rust.name = "u16";
    types.holyC.name = "U16";
    types.java.name = "short";
    types.csharp.name = "ushort";
    types.pascal.name = "Word";
    types.ml.name = "";
    types.go.name = "uint16";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint16";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Fast_U32()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "uint_fast32_t";
    types.cpp.name = "uint_fast32_t";
    types.d.name = "uint";
    types.rust.name = "u32";
    types.holyC.name = "U32";
    types.java.name = "int";
    types.csharp.name = "uint";
    types.pascal.name = "Longword";
    types.ml.name = "";
    types.go.name = "uint32";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Fast_U64()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "uint_fast64_t";
    types.cpp.name = "uint_fast64_t";
    types.d.name = "ulong";
    types.rust.name = "u64";
    types.holyC.name = "U64";
    types.java.name = "long";
    types.csharp.name = "ulong";
    types.pascal.name = "QWord";
    types.ml.name = "";
    types.go.name = "uint64";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Fast_U128()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "ucent";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "QWord";
    types.ml.name = "";
    types.go.name = "uint128";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱

//least (signed)
◀public: static▶ Equivalent_Language_Types ☀Least_I8()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "int_least8_t";
    types.cpp.name = "int_least8_t";
    types.d.name = "byte";
    types.rust.name = "i8";
    types.holyC.name = "I8";
    types.java.name = "byte";
    types.csharp.name = "sbyte";
    types.pascal.name = "Shortint";
    types.ml.name = "";
    types.go.name = "int8";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int8";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Least_I16()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "int_least16_t";
    types.cpp.name = "int_least16_t";
    types.d.name = "short";
    types.rust.name = "i16";
    types.holyC.name = "I16";
    types.java.name = "short";
    types.csharp.name = "short";
    types.pascal.name = "Smallint";
    types.ml.name = "";
    types.go.name = "int16";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int16";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Least_I32()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "int_least32_t";
    types.cpp.name = "int_least32_t";
    types.d.name = "int";
    types.rust.name = "i32";
    types.holyC.name = "I32";
    types.java.name = "int";
    types.csharp.name = "int";
    types.pascal.name = "Longint";
    types.ml.name = "";
    types.go.name = "int32";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Least_I64()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "int_least64_t";
    types.cpp.name = "int_least64_t";
    types.d.name = "long";
    types.rust.name = "i64";
    types.holyC.name = "I64";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Int64";
    types.ml.name = "";
    types.go.name = "int64";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Least_I128()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "cent";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Int64";
    types.ml.name = "";
    types.go.name = "int128";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int128";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱

//least (unsigned)
◀public: static▶ Equivalent_Language_Types ☀Least_U8()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "uint_least8_t";
    types.cpp.name = "uint_least8_t";
    types.d.name = "ubyte";
    types.rust.name = "u8";
    types.holyC.name = "U8";
    types.java.name = "byte";
    types.csharp.name = "byte";
    types.pascal.name = "Byte";
    types.ml.name = "";
    types.go.name = "uint8";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint8";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Least_U16()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "uint_least16_t";
    types.cpp.name = "uint_least16_t";
    types.d.name = "ushort";
    types.rust.name = "u16";
    types.holyC.name = "U16";
    types.java.name = "short";
    types.csharp.name = "ushort";
    types.pascal.name = "Word";
    types.ml.name = "";
    types.go.name = "uint16";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint16";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Least_U32()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "uint_least32_t";
    types.cpp.name = "uint_least32_t";
    types.d.name = "uint";
    types.rust.name = "u32";
    types.holyC.name = "U32";
    types.java.name = "int";
    types.csharp.name = "uint";
    types.pascal.name = "Longword";
    types.ml.name = "";
    types.go.name = "uint32";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Least_U64()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "uint_least64_t";
    types.cpp.name = "uint_least64_t";
    types.d.name = "ulong";
    types.rust.name = "u64";
    types.holyC.name = "U64";
    types.java.name = "long";
    types.csharp.name = "ulong";
    types.pascal.name = "QWord";
    types.ml.name = "";
    types.go.name = "uint64";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Least_U128()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "ucent";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "QWord";
    types.ml.name = "";
    types.go.name = "uint128";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint128";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱

//floating point
◀public: static▶ Equivalent_Language_Types ☀F32()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "float";
    types.cpp.name = "float";
    types.d.name = "float";
    types.rust.name = "f32";
    types.holyC.name = "F64";
    types.java.name = "float";
    types.csharp.name = "float";
    types.pascal.name = "Single";
    types.ml.name = "";
    types.go.name = "float32";
    types.protocol_buffers.name = "float";
    types.hidl.name = "float32";
    types.processing.name = "float";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀F64()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "double";
    types.cpp.name = "double";
    types.d.name = "double";
    types.rust.name = "f64";
    types.holyC.name = "F64";
    types.java.name = "double";
    types.csharp.name = "double";
    types.pascal.name = "Double";
    types.ml.name = "";
    types.go.name = "float64";
    types.protocol_buffers.name = "double";
    types.hidl.name = "uint8";
    types.hidl.name = "float64";
    types.processing.name = "double";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀F128()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "long double";
    types.cpp.name = "long double";
    types.d.name = "real";
    types.rust.name = "f64";
    types.holyC.name = "F64";
    types.java.name = "double";
    types.csharp.name = "decimal";
    types.pascal.name = "Extended";
    types.ml.name = "";
    types.go.name = "float64";
    types.protocol_buffers.name = "double";
    types.hidl.name = "float64";
    types.processing.name = "double";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱

//OTHER:  

//bool
◀public: static▶ Equivalent_Language_Types ☀Bool()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "BOOL";
    types.cpp.name = "bool";
    types.d.name = "bool";
    types.rust.name = "bool";
    types.holyC.name = "I8";
    types.java.name = "boolean";
    types.csharp.name = "bool";
    types.pascal.name = "Boolean";
    types.ml.name = "";
    types.go.name = "bool";
    types.protocol_buffers.name = "bool";
    types.hidl.name = "boolean";
    types.processing.name = "boolean";
    
    {
        Needed_Import import;
        import.name = "Defs";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;
    
    return types;
❱

//containers

//sequence
◀public: static▶ Equivalent_Language_Types ☀Sequence()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "VectorT";
    types.cpp.name = "std::vector";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist";
    types.processing.name = "ArrayList";
    
    //print names
    types.c.printable_name = "ordered sequence";
    types.cpp.printable_name = "ordered sequence";
    types.d.printable_name = "ordered sequence";
    types.rust.printable_name = "ordered sequence";
    types.holyC.printable_name = "ordered sequence";
    types.java.printable_name = "ordered sequence";
    types.csharp.printable_name = "ordered sequence";
    types.pascal.printable_name = "ordered sequence";
    types.ml.printable_name = "ordered sequence";
    types.go.printable_name = "ordered sequence";
    types.hidl.printable_name = "ordered sequence";
    
    //needed imports
    
    {
        Needed_Import import;
        import.name = "Vector";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "vector";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::YES;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

◀public: static▶ Equivalent_Language_Types ☀Indexes()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "VectorT";
    types.cpp.name = "std::vector<size_t>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist<uint64>";
    types.processing.name = "ArrayList<long>";
    
    //print names
    types.c.printable_name = "indexes";
    types.cpp.printable_name = "indexes";
    types.d.printable_name = "indexes";
    types.rust.printable_name = "indexes";
    types.holyC.printable_name = "indexes";
    types.java.printable_name = "indexes";
    types.csharp.printable_name = "indexes";
    types.pascal.printable_name = "indexes";
    types.ml.printable_name = "indexes";
    types.go.printable_name = "indexes";
    types.hidl.printable_name = "indexes";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Vector";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "vector";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::UNKNOWN;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

◀public: static▶ Equivalent_Language_Types ☀Ordered_Indexes()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "VectorT";
    types.cpp.name = "std::vector<size_t>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist<uint64>";
    types.processing.name = "ArrayList<long>";
    
    //print names
    types.c.printable_name = "ordered indexes";
    types.cpp.printable_name = "ordered indexes";
    types.d.printable_name = "ordered indexes";
    types.rust.printable_name = "ordered indexes";
    types.holyC.printable_name = "ordered indexes";
    types.java.printable_name = "ordered indexes";
    types.csharp.printable_name = "ordered indexes";
    types.pascal.printable_name = "ordered indexes";
    types.ml.printable_name = "ordered indexes";
    types.go.printable_name = "ordered indexes";
    types.hidl.printable_name = "ordered indexes";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Vector";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "vector";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::YES;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

◀public: static▶ Equivalent_Language_Types ☀Unordered_Indexes()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "SetT";
    types.cpp.name = "std::set<size_t>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist<uint64>";
    types.processing.name = "ArrayList<long>";
    
    //print names
    types.c.printable_name = "unordered indexes";
    types.cpp.printable_name = "unordered indexes";
    types.d.printable_name = "unordered indexes";
    types.rust.printable_name = "unordered indexes";
    types.holyC.printable_name = "unordered indexes";
    types.java.printable_name = "unordered indexes";
    types.csharp.printable_name = "unordered indexes";
    types.pascal.printable_name = "unordered indexes";
    types.ml.printable_name = "unordered indexes";
    types.go.printable_name = "unordered indexes";
    types.hidl.printable_name = "unordered indexes";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Set";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "set";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::YES;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

◀public: static▶ Equivalent_Language_Types ☀Strings()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "VecStringsT";
    types.cpp.name = "std::vector<std::string>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist<string>";
    types.processing.name = "ArrayList<String>";
    
    //print names
    types.c.printable_name = "strings";
    types.cpp.printable_name = "strings";
    types.d.printable_name = "strings";
    types.rust.printable_name = "strings";
    types.holyC.printable_name = "strings";
    types.java.printable_name = "strings";
    types.csharp.printable_name = "strings";
    types.pascal.printable_name = "strings";
    types.ml.printable_name = "strings";
    types.go.printable_name = "strings";
    types.hidl.printable_name = "strings";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Vector";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "string";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
        
        import.name = "vector";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::YES;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

◀public: static▶ Equivalent_Language_Types ☀Unordered_Strings()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "UnorderedSetT";
    types.cpp.name = "std::unordered_set<size_t>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "set<string>";
    types.processing.name = "ArrayList<string>";
    
    //print names
    types.c.printable_name = "unordered strings";
    types.cpp.printable_name = "unordered strings";
    types.d.printable_name = "unordered strings";
    types.rust.printable_name = "unordered strings";
    types.holyC.printable_name = "unordered strings";
    types.java.printable_name = "unordered strings";
    types.csharp.printable_name = "unordered strings";
    types.pascal.printable_name = "unordered strings";
    types.ml.printable_name = "unordered strings";
    types.go.printable_name = "unordered strings";
    types.hidl.printable_name = "unordered strings";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "UnorderedSet";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "unordered_set";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
        
        import.name = "string";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

◀public: static▶ Equivalent_Language_Types ☀Guids()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "GuidT";
    types.cpp.name = "std::vector<hub::base::guid>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist<guid>";
    types.processing.name = "ArrayList<String>";
    
    //print names
    types.c.printable_name = "guids";
    types.cpp.printable_name = "guids";
    types.d.printable_name = "guids";
    types.rust.printable_name = "guids";
    types.holyC.printable_name = "guids";
    types.java.printable_name = "guids";
    types.csharp.printable_name = "guids";
    types.pascal.printable_name = "guids";
    types.ml.printable_name = "guids";
    types.go.printable_name = "guids";
    types.hidl.printable_name = "guids";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Guid";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "hub/base/guid";
        import.type = Import_Type::LOCAL;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::UNKNOWN;
    types.inferred_properties.collection = Tri_Bool::NO;
    
    return types;
❱

◀public: static▶ Equivalent_Language_Types ☀Ordered_Guids()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "GuidT";
    types.cpp.name = "std::vector<hub::base::guid>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist<guid>";
    types.processing.name = "ArrayList<String>";
    
    //print names
    types.c.printable_name = "ordered guids";
    types.cpp.printable_name = "ordered guids";
    types.d.printable_name = "ordered guids";
    types.rust.printable_name = "ordered guids";
    types.holyC.printable_name = "ordered guids";
    types.java.printable_name = "ordered guids";
    types.csharp.printable_name = "ordered guids";
    types.pascal.printable_name = "ordered guids";
    types.ml.printable_name = "ordered guids";
    types.go.printable_name = "ordered guids";
    types.hidl.printable_name = "ordered guids";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Guid";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "hub/base/guid";
        import.type = Import_Type::LOCAL;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::UNKNOWN;
    types.inferred_properties.collection = Tri_Bool::NO;
    
    return types;
❱

◀public: static▶ Equivalent_Language_Types ☀Unordered_Guids()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "GuidT";
    types.cpp.name = "std::vector<hub::base::guid>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "std::set<guid>";
    types.processing.name = "ArrayList<String>";
    
    //print names
    types.c.printable_name = "unordered guids";
    types.cpp.printable_name = "unordered guids";
    types.d.printable_name = "unordered guids";
    types.rust.printable_name = "unordered guids";
    types.holyC.printable_name = "unordered guids";
    types.java.printable_name = "unordered guids";
    types.csharp.printable_name = "unordered guids";
    types.pascal.printable_name = "unordered guids";
    types.ml.printable_name = "unordered guids";
    types.go.printable_name = "unordered guids";
    types.hidl.printable_name = "unordered guids";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Guid";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "hub/base/guid";
        import.type = Import_Type::LOCAL;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::UNKNOWN;
    types.inferred_properties.collection = Tri_Bool::NO;
    
    return types;
❱


◀public: static▶ Equivalent_Language_Types ☀Array()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Fundamental;
    types.cpp.category = Language_Type_Category::Fundamental;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::UNKNOWN;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Vector()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "VectorT";
    types.cpp.name = "std::vector";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist";
    types.processing.name = "ArrayList";
    
    //print names
    types.c.printable_name = "sequence";
    types.cpp.printable_name = "sequence";
    types.d.printable_name = "sequence";
    types.rust.printable_name = "sequence";
    types.holyC.printable_name = "sequence";
    types.java.printable_name = "sequence";
    types.csharp.printable_name = "sequence";
    types.pascal.printable_name = "sequence";
    types.ml.printable_name = "sequence";
    types.go.printable_name = "sequence";
    types.hidl.printable_name = "sequence";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Vector";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "vector";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::UNKNOWN;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Deque()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Flist()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Dlist()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "std::linked_list";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "linkedlist";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    
    return types;
❱

//associative
◀public: static▶ Equivalent_Language_Types ☀Set()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "std::set";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "set";
    
    //needed imports
    //needed imports
    {
        Needed_Import import;
        import.name = "Set";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "set";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Map()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "MapT";
    types.cpp.name = "std::map";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "dictionary";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Mset()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Mmap()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

//unordered associative
◀public: static▶ Equivalent_Language_Types ☀Uset()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Umap()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;



	types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Umset()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;



	types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Ummap()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

//adapters
◀public: static▶ Equivalent_Language_Types ☀Stack()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Queue()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Pqueue()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

//vocabulary
◀public: static▶ Equivalent_Language_Types ☀Any()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Optional()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;

    types.inferred_properties.optional = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Variant()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;
    
    return types;
❱
◀public: static▶ Equivalent_Language_Types ☀Result()❰
    Equivalent_Language_Types types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::Abstract;
    types.cpp.category = Language_Type_Category::Abstract;
    
    return types;
❱
