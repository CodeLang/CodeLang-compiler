class
❪vector❫
❪string❫
❪"code/transcompilers/unilang/main/program_options/program_options"❫
❪"code/transcompilers/unilang/user-frontend/command_line_arguments/dependency_paths"❫
❪"code/transcompilers/unilang/dependency_graph_creator/code_graph"❫
❪"code/transcompilers/unilang/main/root_settings/root_settings"❫
❪"code/transcompilers/unilang/main/composed_program_options/composed_program_options"❫
❪"code/transcompilers/unilang/user-frontend/graph_adjuster/code_graph_adjuster"❫
❪"code/transcompilers/unilang/user-frontend/fully_read_file"❫
❪"code/transcompilers/unilang/main/program_input"❫
❪"code/utilities/filesystem/paths/lib"❫
⚯
❪"code/transcompilers/unilang/validators/file_name/filename_validator"❫
❪"code/transcompilers/unilang/parser/parser"❫
❪"code/transcompilers/unilang/user-frontend/compiler/compiler"❫
❪"code/transcompilers/unilang/user-frontend/exception_handler"❫
❪"code/utilities/types/general/lib"❫
❪"code/utilities/types/strings/transformers/stripping/lib"❫
❪"code/transcompilers/unilang/structure_static_analyzer/structure_static_analyzer"❫
❪"code/utilities/filesystem/files/getting/lib"❫
❪"code/utilities/exits/lib"❫
❪"code/transcompilers/unilang/user-frontend/language_guesser"❫
❪"code/transcompilers/unilang/user-frontend/workspace_adjuster"❫
❪"code/transcompilers/unilang/user-frontend/after_artifact_actions"❫
❪"code/transcompilers/unilang/f2si_frontend_compiler/file_transfer_settings_getter"❫
❪"code/transcompilers/unilang/f2si_frontend_compiler/pulse/pulse_action_getter"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/shell/lib"❫
❪"code/transcompilers/unilang/f2si_frontend_compiler/file_transferer"❫
❪"code/utilities/types/strings/observers/splitting/lib"❫
❪"code/utilities/colors/lib"❫
❪"code/utilities/diagnostic/diagnostic_printer"❫
❪"code/transcompilers/unilang/user-frontend/program_input_enricher"❫
❪"code/transcompilers/unilang/user-frontend/transcompiler"❫
⚞⚟

◀public: static▶ void ☀Transcompile_Each_Of_The_Files_According_To_Program_Options(Program_Input input)❰
    
    //attempt to derive some more information if it was not provided on CLI
    //also do some validation and error handling in regards to program input.
    Program_Input_Enricher::Enrich(input);
    
    //parse all of the files into daunilang's conceptual model.  
    //this is essentially the entire frontend of the transcompiler.
    auto graphs = Turn_Files_Into_Code_Graphs(input);
    
    //run the backend transcompilers and possibly create some artifacts.  
    //workspace here essentially means the compilers current working directory.  
    //sometimes we may want to jump somewhere else before we start creating files.  
    //other times, we will stay in the same directory where unilang was run from.
    Workspace_Adjuster::While_Inside_Possibly_Adjusted_Scratch_Space(input,[&](){
        Scratch_Space_Actions(input,graphs);
    });
❱

◀private: static▶ std::vector<Code_Graph> ☀Turn_Files_Into_Code_Graphs(Program_Input const& input)❰
    std::vector<Code_Graph> graphs;
    for (auto const& it: input.options.input_files){
        auto g = Parse_File(it,input.settings,input.options);
        graphs.emplace_back(g);
    }
    return graphs;
❱

◀private: static▶ Code_Graph ☀Parse_File(std::string const& path_to_file, Root_Settings const& settings, Composed_Program_Options const& program_options)❰

    //derive filename from the path
    auto file_name = Get_File_Name_From_File_Path(path_to_file);
    
    //check if something is initially wrong with the path and filename sent to the compiler
    //might throw..
    Filename_Validator::Validate_Input_File(settings.file_validation,file_name,settings.parser.input_files.expected_file_extension);
    
    //read in the entire file first so that we have it in memory.
    //This is useful for testing too, where we can pass test strings into the frontend
    //without having to actually create files in unit tests.
    Fully_Read_File file(file_name);
    
    //I would like the backend compiler to return something like 
    //full strings for the files one day.  We would want to write to
    //disk at the very very end.
    auto code_graph = Front_End(file,settings,program_options);
    
    return code_graph;
❱

◀private: static▶ Code_Graph ☀Front_End(Fully_Read_File const& file, Root_Settings const& settings, Composed_Program_Options const& program_options)❰

    //Apart from just parsing the file that needs compiled, 
    //we will also need to compile all of the file's dependencies and store them in a graph data structure
    //create a graph of these classes to handle the dependencies.
    //might throw...
    auto code_graph = Parser::Parse(file,program_options.dependency_paths,settings.parser);
    
    //before compiling the source file,
    //make the necessary code graph transformations automatically
    //this will include actions like:  
    // - specific transformations from settings
    // - inlining structures
    // - deriving import relations
    Code_Graph_Adjuster::Adjust(code_graph,settings,program_options);
    
    Structure_Static_Analyzer::Print_Warnings(code_graph.structure,settings.static_analysis);
    
    return code_graph;
❱



◀private: static▶ void ☀Scratch_Space_Actions(Program_Input input, std::vector<Code_Graph> const& graphs)❰

    //transcompile all of the files
    auto created_files = Transcompiler::Create_All_The_Files(graphs,input);

   //do things with the transcompiled files
   After_Artifact_Actions::Do(input,graphs,created_files);
❱




