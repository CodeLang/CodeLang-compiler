class
❪string❫
❪unordered_map❫
❪utility❫
❪cstdlib❫
❪"code/utilities/fonts/bdf/settings/character_segment"❫
❪"code/utilities/data_structures/graphics/objects/label/label_settings"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_label/positioned_buttoned_faced_label"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_tree/positioned_button_face_tree"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_tree/button_tree_label_drawer"❫
❪"code/utilities/data_structures/graphics/objects/buildable_faced_tree/buildable_face_tree"❫
❪"code/utilities/data_structures/graphics/objects/buildable_faced_tree/positioned_buildable_face_tree"❫
❪"code/utilities/data_structures/graphics/objects/buildable_faced_tree/buildable_label_action"❫
❪"code/utilities/data_structures/graphics/objects/label/label_drawer"❫
❪"code/utilities/data_structures/graphics/objects/frame_elements"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/data_structures/graphics/objects/faced_label/faced_label_drawer"❫
❪"code/utilities/peripheral/mouse/state/mouse_state"❫
❪"code/utilities/fonts/bdf/character_maps/character_maps"❫
❪"code/utilities/data_structures/counters/unique_max_counter/unique_max_counter"❫
⚯
❪"code/utilities/data_structures/graphics/objects/mouse/events/mouse_events_checker"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/data_structures/graphics/bitmap/premade/vertical_line"❫
❪"code/utilities/data_structures/graphics/bitmap/premade/horizontal_line"❫
❪"code/utilities/data_structures/graphics/bitmap/premade/l_line"❫
❪"code/utilities/data_structures/graphics/objects/faced_label/premade/faced_label_premades"❫
❪"code/utilities/data_structures/graphics/objects/faced_tree/tree_label_drawer"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_tree/button_face_tree_click_finder"❫
❪"code/utilities/data_structures/graphics/objects/faced_tree/tree_label_click_finder"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_label/premade/buttoned_faced_label_premades"❫
⚞⚟

◀public: static▶ Frame_Elements ☀Draw(Character_Maps const& font_chars, Positioned_Buildable_Face_Tree & tree, Pc_Input_State const& pc_input)❰
    
    Frame_Elements elements;
    
    //draw the tree
    elements.types += Button_Tree_Label_Drawer::Draw(font_chars,tree.structure,tree.pos,pc_input).types;
    
    //find the element that has been right-clicked
    //TODO: Drawing the tree should return this information.
    bool label_first_selected = false;
    if (!tree.menu.visible){
        tree.selected_node = Button_Face_Tree_Click_Finder::Find_Clicked_Label(tree.structure);
        if (tree.selected_node != tree.structure.nodes.end()){
            label_first_selected = true;
        }
        
    }
    
    //was an element clicked?
    //decide to show the action menu 
    Possibly_Open_Menu(tree,label_first_selected);
    
    
    Handle_Menu(elements,font_chars,tree,pc_input,label_first_selected);
    
    
    return elements;
❱

◀private: static▶ void ☀Possibly_Open_Menu(Positioned_Buildable_Face_Tree & tree, bool label_first_selected)❰

    if (label_first_selected){
        std::cout << "clicked" << std::endl;
        
        tree.menu = Decide_Menu(tree.structure,tree.selected_node);
        tree.menu.visible = true;
    }
❱

◀private: static▶ void ☀Handle_Menu(Frame_Elements & elements, Character_Maps const& font_chars, Positioned_Buildable_Face_Tree & tree, Pc_Input_State const& pc_input, bool const& label_first_selected)❰

    if (tree.menu.visible){
        elements.types += Tree_Label_Drawer::Draw(font_chars,tree.menu.menu,tree.pos,pc_input).types;
        
        if (!label_first_selected){
            if (pc_input.mouse.left.clicked || pc_input.mouse.right.clicked){
                
                tree.menu.visible = false;
                Handle_Menu_Click(tree);
                
                
            }
        }
    }
❱

◀private: static▶ void ☀Handle_Menu_Click(Positioned_Buildable_Face_Tree & tree)❰

    auto found = Tree_Label_Click_Finder::Find_Clicked_Label(tree.menu.menu);
    if (found != tree.menu.menu.nodes.end()){
        auto label_action = Label_Message_To_Action(found->faces[0].label.message);
        
        switch (label_action){
            
            case Buildable_Label_Action::ADD_SIBLING_BEFORE: Do_Label_Add_Sibling_Before(tree);
            break;
            
            case Buildable_Label_Action::DELETE: Do_Label_Delete(tree);
            break;
            
            case Buildable_Label_Action::COPY: Do_Label_Copy(tree);
            break;
        }
    }
❱

◀private: static▶ void ☀Do_Label_Add_Sibling_Before(Positioned_Buildable_Face_Tree & tree)❰
    std::cout << "doing add" << std::endl;
    
    
    //add a default label
    auto x = Buttoned_Faced_Label_Premades::Single_Plain_White_Box_For_Tree();
    tree.structure.nodes.insert_after(tree.selected_node,x);
❱
◀private: static▶ void ☀Do_Label_Delete(Positioned_Buildable_Face_Tree & tree)❰
    std::cout << "doing delete" << std::endl;
    
    tree.structure.nodes.erase(tree.selected_node);
❱
◀private: static▶ void ☀Do_Label_Copy(Positioned_Buildable_Face_Tree & tree)❰
    std::cout << "doing copy" << std::endl;
❱


◀private: static▶ Buildable_Label_Action ☀Label_Message_To_Action(std::string const& message)❰

    if (message == "Add Sibling Before"){
        return Buildable_Label_Action::ADD_SIBLING_BEFORE;
    }
    if (message == "Delete"){
        return Buildable_Label_Action::DELETE;
    }
    if (message == "Copy"){
        return Buildable_Label_Action::COPY;
    }
    
    std::cerr << "Menu Item has no matching action" << std::endl;
    exit(1);
❱

◀private: static▶ Select_Menu ☀Decide_Menu(Button_Face_Tree const& structure, tree<Buttoned_Faced_Label>::pre_order_iterator it)❰
    Select_Menu x;
    
    auto face_label = Faced_Label_Premades::Single_Plain_White_Box();
    auto top = x.menu.nodes.begin();
    
    face_label.faces[0].label.message = "Add Sibling Before";
    x.menu.nodes.insert(top,face_label);
    
    face_label.faces[0].label.message = "Delete";
    x.menu.nodes.insert(top,face_label);
    
    face_label.faces[0].label.message = "Copy";
    x.menu.nodes.insert(top,face_label);
    
    return x;
❱