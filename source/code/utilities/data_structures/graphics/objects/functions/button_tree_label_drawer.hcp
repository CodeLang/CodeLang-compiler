class
❪string❫
❪unordered_map❫
❪utility❫
❪cstdlib❫
❪"code/utilities/fonts/bdf/settings/character_segment"❫
❪"code/utilities/data_structures/graphics/objects/grid/faced/regular/label_settings"❫
❪"code/utilities/data_structures/graphics/objects/grid/faced/positioned_buttoned_faced_label"❫
❪"code/utilities/data_structures/graphics/objects/grid/positioned_button_face_tree"❫
❪"code/utilities/data_structures/graphics/objects/functions/label_drawer"❫
❪"code/utilities/data_structures/graphics/objects/frame_elements"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/data_structures/graphics/objects/functions/faced_label_drawer"❫
❪"code/utilities/peripheral/mouse/state/mouse_state"❫
❪"code/utilities/fonts/bdf/character_maps/character_maps"❫
⚯
❪"code/utilities/data_structures/graphics/objects/mouse/events/mouse_events_checker"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/types/vectors/observers/lib"❫
⚞⚟

◀public: static▶ Frame_Elements ☀Draw(Character_Maps const& font_chars, Positioned_Button_Face_Tree & tree, Pc_Input_State const& pc_input)❰
    
    Frame_Elements elements;
    Print_Tree_In_Iteration(font_chars,elements,pc_input,tree.pos,tree.nodes,tree.nodes.begin(),tree.nodes.end());
    return elements;
❱

◀private: static▶ void ☀Print_Tree_In_Iteration(Character_Maps const& font_chars, Frame_Elements & elements, Pc_Input_State const& pc_input, Position const& pos, const tree<Buttoned_Faced_Label>& tr, tree<Buttoned_Faced_Label>::pre_order_iterator it, tree<Buttoned_Faced_Label>::pre_order_iterator end)❰

    //exit early if tree if empty
    if(!tr.is_valid(it)) return;
    
    //calculate the current depth of the iterator given
    int rootdepth=tr.depth(it);
    
    auto start_pos = pos;
    auto current_pos = pos;
    
    bool subtree_collapsed = false;
    int collapsed_depth = 0;
    
    while(it!=end) {
        
        //calculate the depth of the node
        int depth = tr.depth(it)-rootdepth;
        
        //uncollapse
        if (subtree_collapsed && collapsed_depth >= depth){
            subtree_collapsed = false;
        }
        
        //draw
        if (!subtree_collapsed){
            
            //add label
            Adjust_Positions_For_Next_Cell(it->label,start_pos,current_pos,depth);
            Faced_Label_Drawer::Event_It(font_chars,it->label,current_pos,pc_input);
            Append(elements.types,Faced_Label_Drawer::Draw(font_chars,it->label,current_pos,pc_input.mouse).types);
            
            //add button
            Possibly_Add_Button(elements,pc_input.mouse,tr,it,current_pos);
        }
        
        //collapse
        if (!subtree_collapsed && tr.number_of_children(it) > 0 && it->button.current_face == 0){
            subtree_collapsed = true;
            collapsed_depth = depth;
        }
        
        
        ++it;
    }
❱

◀private: static▶ void  ☀Possibly_Add_Button(Frame_Elements & elements, Mouse_State const& mouse, const tree<Buttoned_Faced_Label>& tr, tree<Buttoned_Faced_Label>::pre_order_iterator it, Position const& current_pos)❰
    if (tr.number_of_children(it) > 0){
        
        //draw
        Positioned_Multi_Color_Bitmap button;
        button.pos = current_pos;
        button.pos.x -= 10;
        button.pos.y += 3;
        button.bitmap = it->button.faces[it->button.current_face];
        elements.types.emplace_back(button);
        
        //change on click
        auto events = Mouse_Events_Checker::search_for_mouse_events_in_rectangle(button.pos,it->button.click_size,mouse);
        if (events.clicked){
            Set_Next_Index_In_Round_Robin(it->button.faces,it->button.current_face);
        }
        
        
    }
❱

◀private: static▶ void  ☀Adjust_Positions_For_Next_Cell(Faced_Label const& label, Position const& start_pos, Position & current_pos, int const& depth)❰
        auto dim = Faced_Label_Drawer::Get_Dimensions(label);
        current_pos.x = start_pos.x + 10 * depth;
        current_pos.y += dim.y-1;
❱