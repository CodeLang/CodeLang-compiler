class
❪string❫
❪iostream❫
❪set❫
❪sys/types.h❫
❪dirent.h❫
❪errno.h❫
⚯
⚞⚟

◀public: static▶ long ☀Get_Inode(std::string const& path)❰

    //we were able to open the dir so we can assume its a directory
    DIR* dir = opendir(path.c_str());
    if (dir != nullptr){
        
        struct dirent* dir2 = readdir(dir);
        Proper_Close(dir);
        return dir2->d_ino;
    }
    
    
    return -1;
❱

//this was supposed to be an optized way of checking to see if a path is a directory
//without stating the file.  We are under the impression that stat is more expensive
//than calling just opendir.  We are also under the impression that opendir is sufficient
//for determining if a path is a directory or not.
◀public: static▶ bool ☀Is_Directory(std::string const& path)❰
    
    //we were able to open the dir so we can assume its a directory
    auto dir = opendir(path.c_str());
    if (dir != nullptr){
        Proper_Close(dir);
        return true;
    }
    
    //if we were unable to open the directory, we can check if
    //it was because its not actually a directory.
    if (errno == ENOTDIR || errno == ENOENT)
    {
        return false;
    }
    
    //if it was a different kind of error we can assume
    //it is indeed a directory.
    //this is likely a bad assumption.
    return true;
❱

◀public: static▶ bool ☀Is_Permission_Denied(std::string const& path)❰

    auto dir = opendir(path.c_str());
    if (dir != nullptr){
        Proper_Close(dir);
        return false;
    }
    
    if (errno != EACCES){return false;}
    return true;
❱

◀public: static▶ bool ☀Per_Process_Limit_Reached(std::string const& path)❰

    auto dir = opendir(path.c_str());
    if (dir != nullptr){
        Proper_Close(dir);
        return false;
    }
    
    if (errno != EMFILE){return false;}
    return true;
❱

◀public: static▶ bool ☀System_Wide_Limit_Reached(std::string const& path)❰

    auto dir = opendir(path.c_str());
    if (dir != nullptr){
        Proper_Close(dir);
        return false;
    }
    
    if (errno != ENFILE){return false;}
    return true;
❱

◀public: static▶ bool ☀Name_Is_Not_A_Directory(std::string const& path)❰

    auto dir = opendir(path.c_str());
    if (dir != nullptr){
        Proper_Close(dir);
        return false;
    }
    
    if (errno != ENOTDIR){return false;}
    return true;
❱


//properly ensuring this gets closed could be implemented as an infinite loop
◀private: static▶ void ☀Proper_Close(DIR * dir)❰
    closedir(dir); //closing may fail
❱