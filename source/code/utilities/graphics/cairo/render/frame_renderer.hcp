class
❪"code/utilities/graphics/imgui/render/frame_elements"❫
❪"code/utilities/data_structures/color/transparent_rgb_color"❫
❪cairo-svg.h❫
❪"SDL.h"❫
⚯
❪"code/utilities/graphics/imgui/ui/draw/rectangle/rectangle_drawer"❫
❪"code/utilities/graphics/imgui/ui/draw/line/line_drawer"❫
❪"code/utilities/graphics/imgui/ui/draw/bitmap/multi_color_bitmap/multi_color_bitmap_drawer"❫
❪"code/utilities/graphics/imgui/ui/draw/bitmap/multi_color_bitmap/positioned_multi_color_bitmap"❫
❪"code/utilities/graphics/imgui/ui/draw/bitmap/full_color_bitmap/positioned_full_color_bitmap"❫
❪"code/utilities/types/variant/lib"❫
❪"code/utilities/math/math"❫
⚞⚟

◀public: static▶ void ☀Render(Frame_Elements const& elements)❰

        Render_Frame_Elements(elements);
❱

◀private: static▶ void ☀Render_Frame_Elements(Frame_Elements const& elements)❰
    
    //build drawing context
    cairo_surface_t *surface = cairo_image_surface_create(CAIRO_FORMAT_RGB24,500,500);
    cairo_t *cr = cairo_create(surface);
    
    //draw background
    cairo_save(cr);
    cairo_set_source_rgb(cr, 1, 1, 1);
    cairo_paint(cr);
    //cairo_restore(cr);
    
    for (auto const& it: elements.types){
        std::visit(overloaded {
            [&](Positioned_Rectangle_Settings const& x) {
                Draw(cr,x);
            },
            [&](Positioned_Multi_Color_Bitmap const& x) {
                Draw(cr,x);
            },
            [&](Positioned_Full_Color_Bitmap const& x) {
                Draw(cr,x);
            },
        }, it);
    }
    
    //export image
    cairo_surface_write_to_png(surface, "/home/laptop/Desktop/cairo_pixel_example.png");
    
    //cleanup
    cairo_destroy(cr), cr = NULL;
    cairo_surface_destroy(surface), surface = NULL;
❱

◀private: static▶ void ☀Draw(cairo_t *cr, Positioned_Rectangle_Settings const& shape)❰
    std::cout << "rectangle" << std::endl;
    
    
    //https://www.cairographics.org/FAQ/#sharp_lines
      
      Set_Rgb(cr,shape.shape.colors.fill);
      cairo_rectangle(cr, shape.pos.x+.5, shape.pos.y+.5, shape.shape.dimensions.width, shape.shape.dimensions.height);
      cairo_stroke_preserve(cr);
      cairo_fill(cr);
      cairo_stroke(cr);
      
      Set_Rgb(cr,shape.shape.colors.border);
      cairo_set_line_width(cr,1);
      //cairo_translate (cr, 1, 0);
      cairo_rectangle(cr, shape.pos.x+.5, shape.pos.y+.5, shape.shape.dimensions.width, shape.shape.dimensions.height);
      //cairo_stroke_preserve(cr);
      cairo_stroke(cr);
      
❱

◀private: static▶ void ☀Draw(cairo_t *cr, Positioned_Multi_Color_Bitmap const& shape)❰
    std::cout << "multi" << std::endl;
    for (auto const& it: shape.bitmap.pixels){
        cairo_rectangle (cr, shape.pos.x+it.pos.x, shape.pos.y+it.pos.y, 1, 1);
        Set_Rgb(cr,it.color_fill);
        cairo_fill (cr);
    }
❱
◀private: static▶ void ☀Draw(cairo_t *cr, Positioned_Full_Color_Bitmap const& shape)❰

    std::cout << "full" << std::endl;
    for (auto const& it: shape.bitmap.pixels){
        cairo_rectangle (cr, shape.pos.x+it.x, shape.pos.y+it.y, 1, 1);
        Set_Rgb(cr,shape.bitmap.color_fill);
        cairo_fill (cr);
    }
❱
◀private: static▶ void ☀Set_Rgb(cairo_t *cr, Transparent_Rgb_Color const& color)❰
    
    auto new_r = Math::map_value_across_range(color.r,0,255,0,1);
    auto new_g = Math::map_value_across_range(color.g,0,255,0,1);
    auto new_b = Math::map_value_across_range(color.b,0,255,0,1);
    cairo_set_source_rgb (cr, new_r, new_g, new_b);
❱