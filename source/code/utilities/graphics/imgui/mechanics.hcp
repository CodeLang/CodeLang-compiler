class
❪GL/gl3w.h❫
❪string❫
❪iostream❫
❪limits❫
❪float.h❫
❪"imgui.h"❫
❪cstdlib❫
❪"imgui_internal.h"❫
❪"examples/imgui_impl_sdl.h"❫
❪"examples/imgui_impl_opengl3.h"❫
❪"SDL.h"❫
❪iostream❫
❪"code/utilities/graphics/sdl/sdl_init_settings"❫
❪"code/utilities/graphics/sdl/sdl_window_creator"❫
❪"code/utilities/graphics/sdl/sdl_initializer"❫
❪"code/utilities/graphics/sdl/sdl_swap_interval_setter"❫
❪"code/utilities/graphics/opengl/loader/opengl_loader"❫
❪"code/utilities/filesystem/paths/lib"❫
⚯
⚞⚟


◀public: 
template <typename T, typename U, typename V>
static int render_each_frame(Sdl_Init_Settings const& s, T before, U logic, V render)
{
    // set up GL and SDL
    Sdl_Initializer::Initialize();
    auto          window       = Sdl_Window_Creator::Create(s.main_window);
    auto gl_context   = SDL_GL_CreateContext(window);
    Sdl_Swap_Interval_Setter::Set(s.interval);
    Opengl_Loader::Initialize();

    // Setup Dear ImGui binding
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    
    set_imgui_io_state();
    
    ImGui_ImplSDL2_InitForOpenGL(window, gl_context);
    
    auto          glsl_version = decide_sdl_glsl_version();
    ImGui_ImplOpenGL3_Init(glsl_version.c_str());

    // clear frame color
    //(not sure if this is important)
    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);
    
    customize_imgui_overall_look(s);

    //our custom before rendering the first frame logic
    //sometimes its important to do something after all of the SDL and imgui stuff have been established
    //but before the app starts rendering frames.
    before();
    
    
    //Below is our old implementation derived from what I've seen from ImGui applications.
    //I believe mixing application logic / rendering logic may be bad.
    //Instead, maybe it would be better to run ImGui in the same way that SFML game loops run.
    //below is that alternative approach
    // while (!poll_for_events(window))
    // {
    //     render_frame(window,render);
    //     render_frame(window, gl_context, io, clear_color);
    // }
    
    //we think its better to do a more disciplined logic+render update
    //where the logic is updated at a faster rate than the application is rendering.
    //I'm not sure if this paradigm is good for imgui (as it appears to be for SFML).
    //Either way, this will force us to separate our logic from render which would be good to do anyhow.
    //Game_Loop::Run([&](){
    // Game_Loop::Run_Same_Rate([&](){
    //     return !poll_for_events(window);
    // },
    // [&](sf::Time const& TimePerFrame){
    //     //logic
    //     logic();
    // },
    // [&](){
    //     //render
    //     render_frame(window,render);
    //     ImGuiIO &io = ImGui::GetIO();
    //     render_frame(window, gl_context, io, clear_color);
    // });
    
    //linking with SFML causes problems
    while (!poll_for_events(window)){
            logic();
        render_frame(window,render);
        ImGuiIO &io = ImGui::GetIO();
        render_frame(window, gl_context, io, clear_color);
    }

    clean_up_resources(gl_context, window);
    return EXIT_SUCCESS;
}▶

◀private:
template <typename T>
static void render_frame(SDL_Window * window, T render){

        // Start the Dear ImGui frame
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplSDL2_NewFrame(window);
        ImGui::NewFrame();

        // our custom frame render logic
        render(window);
}
▶

◀private: static▶ void ☀set_imgui_io_state()❰

    ImGuiIO &io = ImGui::GetIO();
    
    //set a default font
    //I wasn't happy with this because it wasn't perfect.
    //I couldn't get the aliasing perfect, it wasn't pixel perfect.
    //I've decided to render text directly as my own pixelated bitmaps.  
    //This is better anyways, because I want so much more out of text.  
    //I want to color parts of letters/words differently over quick time iterations.
    //so maybe my own pixel perfect bitmaps is a better direction with less blockers anyway.
    //io.Fonts->AddFontDefault();
    //std::string font_path = Full_Path_To_Home();
    //font_path += "/.fonts/ProFontPowerline.ttf";
    //std::cout << font_path << std::endl;
    //ImFont* font1 = io.Fonts->AddFontFromFileTTF(font_path.c_str(),12);
    
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
❱

◀private: static▶ void ☀customize_imgui_overall_look(Sdl_Init_Settings const& s)❰
    // customize imgui overall look
    // (maybe move to overall settings)
    //ImGui::StyleColorsLight();
    ImGuiStyle &style      = ImGui::GetStyle();
    style.FrameBorderSize  = 1;
    style.PopupBorderSize  = 1;
    style.WindowBorderSize = 0;
    style.WindowRounding = 0;
❱

◀private: static▶ std::string ☀decide_sdl_glsl_version()❰
    std::string version;

#if __APPLE__
    // GL 3.2 Core + GLSL 150
    version = "#version 150";
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG); // Always required on Mac
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
#else
    // GL 3.0 + GLSL 130
    version = "#version 130";
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
#endif

    return version;
❱

◀private: static▶ bool ☀poll_for_events(SDL_Window *window)
❰
    // Poll and handle events (inputs, window resize, etc.)
    // You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your
    // inputs.
    // - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application.
    // - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application.
    // Generally you may always pass all inputs to dear imgui, and hide them from your application based on those
    // two flags.
    SDL_Event event;
    bool      done = false;
    while (SDL_PollEvent(&event))
    {
        ImGui_ImplSDL2_ProcessEvent(&event);
        done = user_asked_to_quit(window, event);
    }
    return done;
❱

◀private: static▶ void ☀clean_up_resources(SDL_GLContext &gl_context, SDL_Window *window)
❰
    // Cleanup
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplSDL2_Shutdown();
    ImGui::DestroyContext();

    SDL_GL_DeleteContext(gl_context);
    SDL_DestroyWindow(window);
    SDL_Quit();
❱

◀private: static▶ bool ☀user_asked_to_quit(SDL_Window *window, SDL_Event event)
❰
    if (event.type == SDL_QUIT)
    {
        return true;
    }
    if (event.type == SDL_WINDOWEVENT && event.window.event == SDL_WINDOWEVENT_CLOSE
        && event.window.windowID == SDL_GetWindowID(window))
    {
        return true;
    }
    return false;
❱

◀private: static▶ void ☀render_frame(SDL_Window *window, SDL_GLContext &gl_context, ImGuiIO &io, ImVec4 &clear_color)
❰
    // Rendering
    ImGui::Render();
    SDL_GL_MakeCurrent(window, gl_context);
    glViewport(0, 0, (int) io.DisplaySize.x, (int) io.DisplaySize.y);
    glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w);
    glClear(GL_COLOR_BUFFER_BIT);
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
    SDL_GL_SwapWindow(window);
❱

