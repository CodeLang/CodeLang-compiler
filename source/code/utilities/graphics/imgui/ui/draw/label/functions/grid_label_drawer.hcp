class
❪string❫
❪unordered_map❫
❪utility❫
❪cstdlib❫
❪"code/utilities/fonts/bdf/settings/character_segment"❫
❪"code/utilities/graphics/imgui/ui/draw/label/grid/faced/regular/label_settings"❫
❪"code/utilities/graphics/imgui/ui/draw/label/grid/faced/positioned_faced_label"❫
❪"code/utilities/graphics/imgui/ui/draw/label/grid/positioned_face_grid"❫
❪"code/utilities/graphics/imgui/ui/draw/label/functions/label_drawer"❫
❪"code/tools/ide/frame/logic/frame_elements"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/graphics/imgui/ui/draw/label/functions/faced_label_drawer"❫
❪"code/utilities/peripheral/mouse/state/mouse_state"❫
⚯
⚞⚟

◀public: static▶ Frame_Elements ☀Draw(std::unordered_map<int,Character_Segment> const& font_chars, Positioned_Face_Grid & grid, Mouse_State const& mouse_state)❰
    Frame_Elements elements;
    
    
    Update_Events(font_chars,grid,mouse_state);
    
    auto start_pos = grid.pos;
    auto current_pos = grid.pos;
    
    
    //redraw
    for (size_t i = 0; i < grid.cell.size(); ++i){
        elements.types += Faced_Label_Drawer::Draw(font_chars,grid.cell[i],current_pos,mouse_state).types;
        Adjust_Positions_For_Next_Cell(grid,i,start_pos,current_pos);
    }
    
    return elements;
❱


◀private: static▶ void  ☀Update_Events(std::unordered_map<int,Character_Segment> const& font_chars, Positioned_Face_Grid & grid, Mouse_State const& mouse_state)❰

    auto start_pos = grid.pos;
    auto current_pos = grid.pos;
    
    
    //process events
    for (size_t i = 0; i < grid.cell.size(); ++i){
        Faced_Label_Drawer::Event_It(font_chars,grid.cell[i],current_pos,mouse_state);
        Adjust_Positions_For_Next_Cell(grid,i,start_pos,current_pos);
    }
❱


◀private: static▶ void  ☀Adjust_Positions_For_Next_Cell(Positioned_Face_Grid & grid, size_t index, Position const& start_pos, Position & current_pos)❰
    
        auto dim = Faced_Label_Drawer::Get_Dimensions(grid.cell[index]);
        current_pos.x += dim.x-1;
        
        //line break cells if needed
        if (grid.breaks[index] == Should_Line_Break::YES){
            current_pos.y += dim.y-1;
            current_pos.x = start_pos.x;
        }
❱