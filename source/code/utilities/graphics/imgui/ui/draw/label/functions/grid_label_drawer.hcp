class
❪string❫
❪unordered_map❫
❪utility❫
❪cstdlib❫
❪"code/utilities/fonts/bdf/settings/character_segment"❫
❪"code/utilities/graphics/imgui/ui/draw/label/grid/faced/regular/label_settings"❫
❪"code/utilities/graphics/imgui/ui/draw/label/grid/faced/positioned_faced_label"❫
❪"code/utilities/graphics/imgui/ui/draw/label/grid/positioned_face_grid"❫
❪"code/utilities/graphics/imgui/ui/draw/label/functions/label_drawer"❫
❪"code/tools/ide/frame/logic/frame_elements"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/graphics/imgui/ui/draw/label/functions/faced_label_drawer"❫
❪"code/utilities/peripheral/mouse/state/mouse_state"❫
⚯
⚞⚟

◀public: static▶ Frame_Elements ☀Draw(std::unordered_map<int,Character_Segment> const& font_chars, Positioned_Face_Grid & grid, Mouse_State const& mouse_state)❰
    Frame_Elements elements;
    
    auto start_pos = grid.pos;
    auto current_pos = grid.pos;
    
    for (size_t i = 0; i < grid.cell.size(); ++i){
        elements.types += Faced_Label_Drawer::Draw(font_chars,grid.cell[i],current_pos,mouse_state).types;
        current_pos.x += Decide_Drawn_Width(grid.cell[i]);
        
        //line break cells if needed
        if (grid.breaks[i] == Should_Line_Break::YES){
            current_pos.y += Decide_Drawn_Height(grid.cell[i]);
            current_pos.x = start_pos.x;
        }
    }
    
    return elements;
❱

◀private: static▶ size_t ☀Decide_Drawn_Width(Faced_Label const& label)❰
    return 100 -1;
❱
◀private: static▶ size_t ☀Decide_Drawn_Height(Faced_Label const& label)❰
    return 14;
❱