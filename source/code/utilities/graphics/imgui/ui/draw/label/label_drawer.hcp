class
❪string❫
❪unordered_map❫
❪utility❫
❪cstdlib❫
❪"code/utilities/graphics/imgui/ui/draw/bitmap/full_color_bitmap/full_color_bitmap"❫
❪"code/utilities/bdf/settings/character_segment"❫
❪"code/utilities/graphics/imgui/ui/draw/label/label_settings"❫
❪"code/utilities/graphics/imgui/ui/draw/label/label_cursor_selection"❫
❪"code/utilities/graphics/imgui/ui/draw/mouse_events/mouse_events_checker"❫
❪"code/utilities/graphics/imgui/ui/draw/rectangle/rectangle_drawer"❫
❪"code/utilities/graphics/imgui/ui/draw/bitmap/full_color_bitmap/full_color_bitmap_drawer"❫
❪"code/utilities/graphics/imgui/ui/draw/text/text_to_bitmap"❫
❪"code/utilities/graphics/imgui/ui/ui_renders"❫
⚯
❪"code/utilities/graphics/imgui/ui/draw/text/str_to_bdf_segments"❫
⚞⚟

◀public: static▶ void ☀Draw(ImDrawList *draw_list, std::unordered_map<int,Character_Segment> const& font_chars, Position pos, Label_Settings & label)❰
    
    //convert strings to bitmap representations
    auto bitmap = Text_To_Bitmap::Convert(font_chars,label.message);
    
    Decide_Label_Box_Dimensions(font_chars,label);
    
    int x_adjusted_label_draw = -2;
    int y_adjusted_label_draw = -10;

    //adjust for label backdrop
    pos.y += y_adjusted_label_draw;
    pos.x += x_adjusted_label_draw;

    //draw and handle backdrop
    auto events = Mouse_Events_Checker::search_for_mouse_events_in_rectangle(pos,label.regular.box);
    Set_Label_Properties_Based_On_Events(label,events);
    Draw_Rectangle_Portion(draw_list,bitmap,pos,label);
    
    //adjust for message bitmap and print it
    pos.y -= y_adjusted_label_draw;
    pos.x -= x_adjusted_label_draw;
    Full_Color_Bitmap_Drawer::Draw(draw_list,pos,bitmap);
    
    
    //set active properties on the label
    if (ImGui::IsMouseClicked(0)){
        if (events.clicked){
            label.cursors.clear();
            auto s = get_cursor_selection_based_on_click(font_chars,events.pos,pos,label);
            label.cursors.emplace_back(s);
        }
        else{
            label.cursors.clear();
        }
    }
❱

◀public: static▶ void ☀Move_Cursor_Forward(std::unordered_map<int,Character_Segment> const& font_chars, Position pos, Label_Settings const& label, Label_Cursor_Selection & s)❰

    if (label.message.empty()){
        Move_Cursor_To_The_Beginning(font_chars,pos,label,s);
        return;
    }
    
    auto segments = Str_To_Bdf_Segments::Convert(font_chars,label.message);
    s.label_index += 1;
    s.recommended_cursor_pos.x += segments[s.label_index].d_width_x;
❱
◀public: static▶ void ☀Move_Cursor_Backward(std::unordered_map<int,Character_Segment> const& font_chars, Position pos, Label_Settings const& label, Label_Cursor_Selection & s)❰
    
    if (label.message.empty()){
        Move_Cursor_To_The_Beginning(font_chars,pos,label,s);
        return;
    }
    
    auto segments = Str_To_Bdf_Segments::Convert(font_chars,label.message);
    s.label_index -= 1;
    s.recommended_cursor_pos.x -= segments[s.label_index+1].d_width_x;
❱
◀public: static▶ void ☀Move_Cursor_To_Start_Of_Selection(std::unordered_map<int,Character_Segment> const& font_chars, Position pos, Label_Settings const& label, Label_Cursor_Selection & s)❰
    
    //already at the beginning
    if (s.additional_chars_selected >= 0){
        return;
    }
    
    auto segments = Str_To_Bdf_Segments::Convert(font_chars,label.message);
    for (size_t i = 0; i < std::abs(s.additional_chars_selected); ++i){
        s.recommended_cursor_pos.x -= segments[s.label_index].d_width_x;
        s.label_index -= 1;
    }
❱
◀public: static▶ void ☀Move_Cursor_To_End_Of_Selection(std::unordered_map<int,Character_Segment> const& font_chars, Position pos, Label_Settings const& label, Label_Cursor_Selection & s)❰
    
    //already at the end
    if (s.additional_chars_selected <= 0){
        return;
    }
    
    auto segments = Str_To_Bdf_Segments::Convert(font_chars,label.message);
    for (size_t i = 0; i < s.additional_chars_selected; ++i){
        s.label_index += 1;
        s.recommended_cursor_pos.x += segments[s.label_index].d_width_x;
    }
❱










◀public: static▶ void ☀Move_Cursor_To_The_End(std::unordered_map<int,Character_Segment> const& font_chars, Position pos, Label_Settings const& label, Label_Cursor_Selection & s)❰
    
    
    
    if (label.message.empty()){
        Move_Cursor_To_The_Beginning(font_chars,pos,label,s);
        return;
    }
    
    s.label_index = static_cast<int>(label.message.size())-1;
    auto segments = Str_To_Bdf_Segments::Convert(font_chars,label.message);
    s.recommended_cursor_pos.x = 0;
    for (size_t i = 0; i < segments.size(); ++i){
        pos.x += segments[i].d_width_x;
    }
    s.recommended_cursor_pos.x = pos.x;
❱

◀public: static▶ void ☀Move_Cursor_To_The_Beginning(std::unordered_map<int,Character_Segment> const& font_chars, Position pos, Label_Settings const& label, Label_Cursor_Selection & s)❰
        s.label_index = -1;
        s.recommended_cursor_pos.x = pos.x;
❱











//utility
◀private: static▶ void ☀Set_Label_Properties_Based_On_Events(Label_Settings & label, Mouse_Events const& events)❰

    //set hover properties on the label
    label.is_hovered = events.hovered;
    
    //set active properties on the label
    if (ImGui::IsMouseClicked(0)){
        if (events.clicked){
            label.is_active = true;
        }
        else{
            label.is_active = false;
        }
    }
❱

◀private: static▶ void ☀Draw_Rectangle_Portion(ImDrawList *draw_list, Full_Color_Bitmap & bitmap, Position pos, Label_Settings const& label)❰
    if (label.is_hovered){
        bitmap.color_fill = label.highlighted.text;
        Rectangle_Drawer::draw_rectangle(draw_list,pos,label.highlighted.box);
    }
    else if (label.is_active){
        //TODO (group into styles and use here)
    }
    else{
        bitmap.color_fill = label.regular.text;
        Rectangle_Drawer::draw_rectangle(draw_list,pos,label.regular.box);
    }
❱

◀private: static▶ void ☀Decide_Label_Box_Dimensions(std::unordered_map<int,Character_Segment> const& font_chars, Label_Settings & label)❰

    //some pixel fudging
    const auto EXPECTED_MONOSPACE_CHAR_WIDTH = 6;
    const auto EXPECTED_MONOSPACE_FITTING_HEIGHT = 15;
    const auto SOME_BUFFER_SPACE = 3;
    label.regular.box.width      = (label.message.size() * EXPECTED_MONOSPACE_CHAR_WIDTH) + SOME_BUFFER_SPACE;
    label.regular.box.height     = EXPECTED_MONOSPACE_FITTING_HEIGHT;
    label.highlighted.box.width  = (label.message.size() * EXPECTED_MONOSPACE_CHAR_WIDTH) + SOME_BUFFER_SPACE;
    label.highlighted.box.height = EXPECTED_MONOSPACE_FITTING_HEIGHT;
❱

◀private: static▶ Label_Cursor_Selection ☀get_cursor_selection_based_on_click(std::unordered_map<int,Character_Segment> const& font_chars, Position click_pos, Position pos, Label_Settings & label)❰
    
    
    Label_Cursor_Selection s;
    int width_covered = 0;
    bool found = false;
    auto segments = Str_To_Bdf_Segments::Convert(font_chars,label.message);
    for (size_t i = 0; i < segments.size(); ++i){
        pos.x += segments[i].d_width_x;
        width_covered = segments[i].d_width_x;
        if (pos.x > click_pos.x){
            s.label_index = i;
            found = true;
            break;
        }
    }
    
    if (!found){
        s.label_index = segments.size()-1;
    }
    
    //get difference
    int diff = std::abs(pos.x - click_pos.x);
    if (diff < width_covered/2){
        s.recommended_cursor_pos.x = pos.x;
    }
    else{
        s.recommended_cursor_pos.x = pos.x - width_covered;
        s.label_index -= 1;
    }
    s.recommended_cursor_pos.y = pos.y - 9;
    return s;
❱