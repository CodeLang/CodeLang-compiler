class
❪string❫
❪unordered_map❫
❪"code/utilities/graphics/imgui/ui/draw/bitmap/full_color_bitmap/full_color_bitmap"❫
❪"code/utilities/fonts/bdf/settings/character_segment"❫
❪"code/utilities/fonts/bdf/character_maps/character_maps"❫
⚯
❪"code/utilities/graphics/imgui/ui/draw/bitmap/full_color_bitmap/full_color_bitmap_drawer"❫
❪"code/utilities/types/char/lib"❫
❪"code/utilities/graphics/imgui/ui/draw/text/str_to_bdf_segments"❫
❪"code/utilities/graphics/imgui/ui/draw/imgui_type_utility"❫
⚞⚟

◀public: static▶ Full_Color_Bitmap ☀Convert(Character_Maps const& font_chars, std::string const& str)❰
    auto message = Str_To_Bdf_Segments::Convert_2(font_chars.bitmaps.lookup,str);
    auto bitmap = bdf_segments_to_bitmap(message);
    return bitmap;
❱

◀private: static▶ Full_Color_Bitmap ☀bdf_segments_to_bitmap(std::vector<Full_Color_Bitmap> const& segments)❰
    
    Full_Color_Bitmap bitmap;
    bitmap.color_fill = Imgui_Type_Utility::Black();
        
    
    int total_x_offset = 0;
    int total_y_offset = 0;
    for (size_t i = 0; i < segments.size(); ++i){
        
        for (auto const& x: segments[i].pixels){
            Position pos;
            
            //start with the character's offset relative the other characters already typed
            pos.x = x.x + total_x_offset;
            pos.y = x.y + total_y_offset;

            bitmap.pixels.emplace_back(pos);
        }
        
        //increment a square offset for the next consecutive character box
        total_x_offset += 6; //TODO(thickey): no longer derived, but probably should be
        total_y_offset += 0; //TODO(thickey): no longer derived, but probably should be
    }
    
    return bitmap;
❱