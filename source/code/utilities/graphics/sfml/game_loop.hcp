class
❪string❫
❪"SFML/Graphics"❫
❪"SFML/Graphics/Transformable"❫
⚯
⚞⚟

//Game loops that can be leveraged for games and applications.


◀public:
template <typename T, typename U, typename V>
static void Run(T stop_predicate, U logic, V render){
    
    // run the program as long as the window is open
    // this is a common game loop and it was taken
    // from the SFML Game Development Book.
    sf::Clock clock;
    sf::Time timeSinceLastUpdate = sf::Time::Zero;
    const sf::Time TimePerFrame = sf::seconds(1.f/60.f);
    
    
    while (stop_predicate()){
        
        //process events()
        
        while (timeSinceLastUpdate >= TimePerFrame){
            timeSinceLastUpdate -= TimePerFrame;
            logic(timeSinceLastUpdate);
        }
        render();
        timeSinceLastUpdate += clock.restart();
    }
}
▶


◀public:
template <typename T, typename U, typename V>
static void Run_Same_Rate(T stop_predicate, U logic, V render){
    
    // run the program as long as the window is open
    // this is a common game loop and it was taken
    // from the SFML Game Development Book.
    sf::Clock clock;
    sf::Time timeSinceLastUpdate = sf::Time::Zero;
    const sf::Time TimePerFrame = sf::seconds(1.f/60.f);
    
    
    while (stop_predicate()){
        
        timeSinceLastUpdate -= TimePerFrame;
        logic(timeSinceLastUpdate);
        render();
        timeSinceLastUpdate += clock.restart();
    }
}
▶




//https://github.com/Hopson97/SFML-Game-Framework/blob/master/Source/Game.cpp
◀public:
template <typename T, typename U, typename V>
static void Fixed_Step_Interpolation(T stop_predicate, U logic, V render){

    constexpr unsigned TPS = 60; //ticks per seconds
    const sf::Time     timePerUpdate = sf::seconds(1.0f / float(TPS));
    unsigned ticks = 0;

    sf::Clock timer;
    auto lastTime = sf::Time::Zero;
    auto lag      = sf::Time::Zero;
    
    while (stop_predicate()){
        
        //Get times
        auto time = timer.getElapsedTime();
        auto elapsed = time - lastTime;
        lastTime = time;
        lag += elapsed;
        
        
        //Fixed time update
        while (lag >= timePerUpdate)
        {
            ticks++;
            lag -= timePerUpdate;
            logic(elapsed);
        }
        
        render();
    }
    
}
▶











//from fix your timestamp
//https://gafferongames.com/post/fix_your_timestep/


    // double t = 0.0;
    // double dt = 0.01;

    // double currentTime = hires_time_in_seconds();
    // double accumulator = 0.0;

    // State previous;
    // State current;

    // while ( !quit )
    // {
    //     double newTime = time();
    //     double frameTime = newTime - currentTime;
    //     if ( frameTime > 0.25 )
    //         frameTime = 0.25;
    //     currentTime = newTime;

    //     accumulator += frameTime;

    //     while ( accumulator >= dt )
    //     {
    //         previousState = currentState;
    //         integrate( currentState, t, dt );
    //         t += dt;
    //         accumulator -= dt;
    //     }

    //     const double alpha = accumulator / dt;

    //     State state = currentState * alpha + 
    //         previousState * ( 1.0 - alpha );

    //     render( state );
    // }









// #include "State.h"

// int main()
// {
//         sf::RenderWindow window(sf::VideoMode(1500, 1000), "Timestep Testing");
//         window.setKeyRepeatEnabled(false);

//         State state;

//         sf::Clock clock;
//         float dt = 1.0f / 60.0f;
//         float accumulator = 0.0f;

//         while(window.isOpen())
//         {
//                 sf::Event event;
//                 while(window.pollEvent(event))
//                         if(event.type == sf::Event::Closed)
//                                 window.close();

//                 accumulator += clock.restart().asSeconds();

//                 while(accumulator >= dt)
//                 {
//                         state.update(dt);
//                         accumulator -= dt;
//                 }

//                 float interp = accumulator / dt;

//                 window.clear();
//                 state.draw(window, interp);
//                 window.display();
//         }

//     return 0;
// }
