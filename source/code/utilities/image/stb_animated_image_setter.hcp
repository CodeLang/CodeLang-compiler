class
❪string❫
❪iostream❫
❪algorithm❫
❪"code/utilities/data_structures/graphics/image/positioned_animated_image_data"❫
⚯
❪"code/utilities/streams/filestreams/lib"❫
❪"code/utilities/image/stb_image"❫
❪"code/utilities/image/texture_loader"❫
⚞⚟

◀public: static▶ void ☀Set(Positioned_Animated_Image_Data & data)❰

        //delete the existing image data in case it already has something in it
        free(data.full_img_data);
        
        //load the image so it can be seen (we assume we are in a gl context now
        Load_Image(data);
        
        Load_Textures(data);
❱

◀private: static▶ void ☀Load_Image(Positioned_Animated_Image_Data & data)❰
    
    
    //load file
    size_t size;
    void* buf = FileReadToNewBuffer(data.orign_filepath.c_str(), size);
    
    if (buf == nullptr)
    {
        std::cerr << "failed to open image" << std::endl;
        exit(-1);
    }

    
    //interpret it as a gif
    int* delays;
    int frames = 0;
    unsigned char* full_img_data = (unsigned char*) stbi_load_gif_from_memory((const stbi_uc*)buf, (int) size, &delays, &data.width, &data.height, &frames, &data.rows, 0);
    
    if (full_img_data == nullptr)
    {
        std::cerr << "failed to interpret image as gif" << std::endl;
        exit(-1);
    }
    
    //split up each frame of the image
    for (int frameIndex = 0; frameIndex < frames - 1; ++frameIndex){
        int imageOffset = (data.width * data.height * data.rows) * frameIndex;
        unsigned char* imageStart = &full_img_data[imageOffset];
        data.img_data.emplace_back(imageStart);
    }
❱

◀private: static▶ void ☀Load_Textures(Positioned_Animated_Image_Data & data)❰

    for (auto & it: data.img_data){
        GLuint tex = 0;
        Texture_Loader::Load(tex,it,data.width,data.height);
        data.texture.emplace_back(tex);
    }
❱