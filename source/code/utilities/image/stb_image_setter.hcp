class
❪string❫
❪iostream❫
❪algorithm❫
❪"code/utilities/data_structures/graphics/image/positioned_image_data"❫
⚯
❪"code/utilities/image/stb_image"❫
⚞⚟

◀public: static▶ void ☀Set(Positioned_Image_Data & data)❰

        //delete the existing image data in case it already has something in it
        free(data.img_data);
        
        //load the image so it can be seen (we assume we are in a gl context now
        Load(data);
        // stbir_resize_uint8(data.img_data, width, height, 0)
        
        // Create a OpenGL texture identifier
        glGenTextures(1, &data.texture);
        
        if (data.texture == 0){
            std::cerr << "Zero is a reserved texture name and is never returned as a texture name by glGenTextures()." << std::endl;
            std::cerr << "Have you created an OpenGL context first?" << std::endl;
            std::cerr << "glGetError: " << glGetError() << std::endl;
            exit(-1);
        }
        
        glBindTexture(GL_TEXTURE_2D, data.texture);
        
        // Setup filtering parameters for display
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); // This is required on WebGL for non power-of-two textures
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); // Same
        
        //glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
        
    // Upload pixels into texture
#if defined(GL_UNPACK_ROW_LENGTH) && !defined(__EMSCRIPTEN__)
        glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
#endif
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, data.width, data.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data.img_data);
❱

◀private: static▶ void ☀Load(Positioned_Image_Data & data)❰


    //settings
    bool attempt_loading_from_serialized_in_memory = true;
    bool save_image_in_memory_for_serialization = true;


    //we don't need to load the file if we've already saved and serialized it in memory
    if (attempt_loading_from_serialized_in_memory){
        if (!data.seralizable_image.empty()){
            std::cout << "loading image from encoded memory" << std::endl;
            data.img_data = reinterpret_cast<unsigned char*>(data.seralizable_image.data());
            return;
        }
    }
    
    //however, if it was not saved and serialized to memory, we will instead load it from the file_name given
    Load_Image_From_Filename(data);
    
    //decide whether to save the image in memory for serialization
    if (save_image_in_memory_for_serialization){
        Save_To_Serializable_Memory(data);
    }
❱

◀private: static▶ void ☀Load_Image_From_Filename(Positioned_Image_Data & data)❰

    std::cout << "loading image from file name: " << data.orign_filepath << std::endl;
    data.img_data = stbi_load(data.orign_filepath.c_str(), &data.width, &data.height, &data.rows, 4);
    if (data.img_data == nullptr){
        std::cerr << "unable to read in image" << std::endl;
        exit(-1);
    }
❱

◀private: static▶ void ☀Save_To_Serializable_Memory(Positioned_Image_Data & data)❰

    //https://github.com/nothings/stb/issues/855
    int total_bytes = data.width*data.height*data.rows;
    data.seralizable_image.clear();
    std::copy(data.img_data, data.img_data+total_bytes, std::back_inserter(data.seralizable_image)); 
❱