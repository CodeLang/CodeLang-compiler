class


❪"code/utilities/linguistics/computer/types/cross/cross_language_type"❫
⚯
❪"code/utilities/types/tri_bool"❫
⚞⚟

//nothing
◀public: static▶ Cross_Language_Type ☀Void()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "void";
    types.cpp.name = "void";
    types.d.name = "void";
    types.rust.name = "()";
    types.holyC.name = "U0";
    types.java.name = "void";
    types.csharp.name = "void";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "void";
    types.protocol_buffers.name = "void";
    types.processing.name = "void";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀NullPtr()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "void*";
    types.cpp.name = "std::nullptr_t";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "void*";
    types.protocol_buffers.name = "void*";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱

//bytes
◀public: static▶ Cross_Language_Type ☀Xbyte()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "char";
    types.cpp.name = "char";
    types.d.name = "byte";
    types.rust.name = "i8";
    types.holyC.name = "I8";
    types.java.name = "byte";
    types.csharp.name = "byte";
    types.pascal.name = "Byte";
    types.ml.name = "";
    types.go.name = "int8";
    types.protocol_buffers.name = "bytes";
    types.hidl.name = "int8";
    types.processing.name = "byte";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Byte()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "signed char";
    types.cpp.name = "signed char";
    types.d.name = "byte";
    types.rust.name = "i8";
    types.holyC.name = "I8";
    types.java.name = "byte";
    types.csharp.name = "Shortint";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "int8";
    types.protocol_buffers.name = "bytes";
    types.hidl.name = "uint8";
    types.processing.name = "byte";

    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀UByte()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "unsigned char";
    types.cpp.name = "unsigned char";
    types.d.name = "ubyte";
    types.rust.name = "u8";
    types.holyC.name = "U8";
    types.java.name = "byte";
    types.csharp.name = "byte";
    types.pascal.name = "Byte";
    types.ml.name = "";
    types.go.name = "uint8";
    types.protocol_buffers.name = "bytes";
    types.hidl.name = "uint8";
    types.processing.name = "byte";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱

//shorts
◀public: static▶ Cross_Language_Type ☀S()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "short";
    types.cpp.name = "short";
    types.d.name = "short";
    types.rust.name = "i16";
    types.holyC.name = "I16";
    types.java.name = "short";
    types.csharp.name = "SmallInt";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "int16";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Us()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "unsigned short";
    types.cpp.name = "unsigned short";
    types.d.name = "ushort";
    types.rust.name = "u16";
    types.holyC.name = "U16";
    types.java.name = "short";
    types.csharp.name = "ushort";
    types.pascal.name = "Word";
    types.ml.name = "";
    types.go.name = "uint16";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱

//ints
◀public: static▶ Cross_Language_Type ☀I()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "int";
    types.cpp.name = "int";
    types.d.name = "int";
    types.rust.name = "i32";
    types.holyC.name = "I32";
    types.java.name = "int";
    types.csharp.name = "int";
    types.pascal.name = "Integer";
    types.ml.name = "";
    types.go.name = "int";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Ui()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "unsigned int";
    types.cpp.name = "unsigned int";
    types.d.name = "uint";
    types.rust.name = "u32";
    types.holyC.name = "U32";
    types.java.name = "int";
    types.csharp.name = "uint";
    types.pascal.name = "Integer";
    types.ml.name = "";
    types.go.name = "uint";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀L()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "long";
    types.cpp.name = "long";
    types.d.name = "long";
    types.rust.name = "i64";
    types.holyC.name = "I64";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Longint";
    types.ml.name = "";
    types.go.name = "int64";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Ul()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "unsigned long";
    types.cpp.name = "unsigned long";
    types.d.name = "ulong";
    types.rust.name = "u64";
    types.holyC.name = "U64";
    types.java.name = "long";
    types.csharp.name = "ulong";
    types.pascal.name = "Longword";
    types.ml.name = "";
    types.go.name = "uint64";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Ll()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "long long";
    types.cpp.name = "long long";
    types.d.name = "long";
    types.rust.name = "i64";
    types.holyC.name = "I64";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Int64";
    types.ml.name = "";
    types.go.name = "int64";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Ull()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "unsigned long long";
    types.cpp.name = "unsigned long long";
    types.d.name = "long";
    types.rust.name = "i64";
    types.holyC.name = "I64";
    types.java.name = "long";
    types.csharp.name = "ulong";
    types.pascal.name = "QWord";
    types.ml.name = "";
    types.go.name = "uint64";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱

//floating
◀public: static▶ Cross_Language_Type ☀F()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "float";
    types.cpp.name = "float";
    types.d.name = "float";
    types.rust.name = "f32";
    types.holyC.name = "F64";
    types.java.name = "float";
    types.csharp.name = "float";
    types.pascal.name = "Single";
    types.ml.name = "";
    types.ml.name = "float32";
    types.protocol_buffers.name = "float";
    types.hidl.name = "float32";
    types.processing.name = "float";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀D()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "double";
    types.cpp.name = "double";
    types.d.name = "double";
    types.rust.name = "f64";
    types.holyC.name = "F64";
    types.java.name = "double";
    types.csharp.name = "double";
    types.pascal.name = "Double";
    types.ml.name = "float64";
    types.protocol_buffers.name = "double";
    types.hidl.name = "float64";
    types.processing.name = "double";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Ld()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "long double";
    types.cpp.name = "long double";
    types.d.name = "real";
    types.rust.name = "f64";
    types.holyC.name = "F64";
    types.java.name = "double";
    types.csharp.name = "decimal";
    types.pascal.name = "Extend";
    types.ml.name = "float64";
    types.protocol_buffers.name = "double";
    types.hidl.name = "float64";
    types.processing.name = "double";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱

//imaginary
◀public: static▶ Cross_Language_Type ☀If()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Id()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Ild()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱

//complexes
◀public: static▶ Cross_Language_Type ☀Cf()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Cd()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Cld()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱

//characters
◀public: static▶ Cross_Language_Type ☀AsciiChar()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "char";
    types.cpp.name = "char";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "bytes";
    types.hidl.name = "uint8";
    types.processing.name = "char";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Utf8Char()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "char";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "string";
    types.hidl.name = "string";
    types.processing.name = "char";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Utf16Char()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "string";
    types.hidl.name = "string";
    types.processing.name = "char";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Utf32Char()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "string";
    types.processing.name = "char";
    
    //needed imports
    
    //size information
    
    return types;
❱

//string
◀public: static▶ Cross_Language_Type ☀AsciiString()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "char*";
    types.cpp.name = "std::string";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "string";
    types.hidl.name = "string";
    types.processing.name = "String";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "string";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Utf8String()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "char*";
    types.cpp.name = "std::string";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "string";
    types.hidl.name = "string";
    types.processing.name = "String";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Utf16String()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "char*";
    types.cpp.name = "std::string";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "string";
    types.hidl.name = "string";
    types.processing.name = "String";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Utf32String()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "char*";
    types.cpp.name = "std::string";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "string";
    types.hidl.name = "string";
    types.processing.name = "String";
    
    //needed imports
    
    //size information
    
    return types;
❱

//multiple precision numerical types
◀public: static▶ Cross_Language_Type ☀Z()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀R()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀C()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱

//pointer/memory carry over nonsense
◀public: static▶ Cross_Language_Type ☀Size()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "size_t";
    types.cpp.name = "std::size_t";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    {
        Needed_Import import;
        import.name = "Defs";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "cstddef";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Iptr()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Uptr()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Imax()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Umax()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Imin()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Umin()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    types.processing.name = "";
    
    //needed imports
    
    //size information
    
    return types;
❱

//FIXED SIZES
//normal (signed)
◀public: static▶ Cross_Language_Type ☀I8()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "int8_t";
    types.cpp.name = "int8_t";
    types.d.name = "byte";
    types.rust.name = "i8";
    types.holyC.name = "I8";
    types.java.name = "byte";
    types.csharp.name = "sbyte";
    types.pascal.name = "Shortint";
    types.ml.name = "";
    types.go.name = "int8";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int8";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀I16()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "int16_t";
    types.cpp.name = "int16_t";
    types.d.name = "short";
    types.rust.name = "i16";
    types.holyC.name = "I16";
    types.java.name = "short";
    types.csharp.name = "short";
    types.pascal.name = "Smallint";
    types.ml.name = "";
    types.go.name = "int16";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int16";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀I32()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "int32_t";
    types.cpp.name = "int32_t";
    types.d.name = "int";
    types.rust.name = "i32";
    types.holyC.name = "I32";
    types.java.name = "int";
    types.csharp.name = "int";
    types.pascal.name = "Longint";
    types.ml.name = "";
    types.go.name = "int32";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀I64()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "int64_t";
    types.cpp.name = "int64_t";
    types.d.name = "long";
    types.rust.name = "i64";
    types.holyC.name = "I64";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Int64";
    types.ml.name = "";
    types.go.name = "int64";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀I128()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "cent";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Int64";
    types.ml.name = "";
    types.go.name = "int64";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱

//normal (unsigned)
◀public: static▶ Cross_Language_Type ☀U8()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "uint8_t";
    types.cpp.name = "uint8_t";
    types.d.name = "ubyte";
    types.rust.name = "u8";
    types.holyC.name = "U8";
    types.java.name = "byte";
    types.csharp.name = "byte";
    types.pascal.name = "Byte";
    types.ml.name = "";
    types.go.name = "uint8";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint8";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀U16()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "uint16_t";
    types.cpp.name = "uint16_t";
    types.d.name = "ushort";
    types.rust.name = "u16";
    types.holyC.name = "U16";
    types.java.name = "char";
    types.csharp.name = "ushort";
    types.pascal.name = "Word";
    types.ml.name = "";
    types.go.name = "uint16";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint16";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀U32()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "uint32_t";
    types.cpp.name = "uint32_t";
    types.d.name = "uint";
    types.rust.name = "u32";
    types.holyC.name = "U32";
    types.java.name = "int";
    types.csharp.name = "uint";
    types.pascal.name = "Longword";
    types.ml.name = "";
    types.go.name = "uint32";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀U64()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "uint64_t";
    types.cpp.name = "uint64_t";
    types.d.name = "ulong";
    types.rust.name = "u64";
    types.holyC.name = "U64";
    types.java.name = "long";
    types.csharp.name = "ulong";
    types.pascal.name = "QWord";
    types.ml.name = "";
    types.go.name = "uint64";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀U128()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "ucent";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "long";
    types.csharp.name = "ulong";
    types.pascal.name = "QWord";
    types.ml.name = "";
    types.go.name = "uint64";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱

//fast (signed)
◀public: static▶ Cross_Language_Type ☀Fast_I8()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "int_fast8_t";
    types.cpp.name = "int_fast8_t";
    types.d.name = "byte";
    types.rust.name = "i8";
    types.holyC.name = "I8";
    types.java.name = "byte";
    types.csharp.name = "sbyte";
    types.pascal.name = "Shortint";
    types.ml.name = "";
    types.go.name = "int8";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Fast_I16()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "int_fast16_t";
    types.cpp.name = "int_fast16_t";
    types.d.name = "short";
    types.rust.name = "i16";
    types.holyC.name = "I16";
    types.java.name = "short";
    types.csharp.name = "short";
    types.pascal.name = "Smallint";
    types.ml.name = "";
    types.go.name = "int16";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int16";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Fast_I32()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "int_fast32_t";
    types.cpp.name = "int_fast32_t";
    types.d.name = "int";
    types.rust.name = "i32";
    types.holyC.name = "I32";
    types.java.name = "int";
    types.csharp.name = "int";
    types.pascal.name = "Longint";
    types.ml.name = "";
    types.go.name = "int32";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Fast_I64()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "int_fast64_t";
    types.cpp.name = "int_fast64_t";
    types.d.name = "long";
    types.rust.name = "i64";
    types.holyC.name = "I64";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Int64";
    types.ml.name = "";
    types.go.name = "int64";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int64";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Fast_I128()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "cent";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Int64";
    types.ml.name = "";
    types.go.name = "int128";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱

//fast (unsigned)
◀public: static▶ Cross_Language_Type ☀Fast_U8()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "uint_fast8_t";
    types.cpp.name = "uint_fast8_t";
    types.d.name = "ubyte";
    types.rust.name = "u8";
    types.holyC.name = "U8";
    types.java.name = "byte";
    types.csharp.name = "byte";
    types.pascal.name = "Byte";
    types.ml.name = "";
    types.go.name = "uint8";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint8";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Fast_U16()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "uint_fast16_t";
    types.cpp.name = "uint_fast16_t";
    types.d.name = "ushort";
    types.rust.name = "u16";
    types.holyC.name = "U16";
    types.java.name = "short";
    types.csharp.name = "ushort";
    types.pascal.name = "Word";
    types.ml.name = "";
    types.go.name = "uint16";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint16";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Fast_U32()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "uint_fast32_t";
    types.cpp.name = "uint_fast32_t";
    types.d.name = "uint";
    types.rust.name = "u32";
    types.holyC.name = "U32";
    types.java.name = "int";
    types.csharp.name = "uint";
    types.pascal.name = "Longword";
    types.ml.name = "";
    types.go.name = "uint32";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Fast_U64()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "uint_fast64_t";
    types.cpp.name = "uint_fast64_t";
    types.d.name = "ulong";
    types.rust.name = "u64";
    types.holyC.name = "U64";
    types.java.name = "long";
    types.csharp.name = "ulong";
    types.pascal.name = "QWord";
    types.ml.name = "";
    types.go.name = "uint64";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Fast_U128()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "ucent";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "QWord";
    types.ml.name = "";
    types.go.name = "uint128";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱

//least (signed)
◀public: static▶ Cross_Language_Type ☀Least_I8()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "int_least8_t";
    types.cpp.name = "int_least8_t";
    types.d.name = "byte";
    types.rust.name = "i8";
    types.holyC.name = "I8";
    types.java.name = "byte";
    types.csharp.name = "sbyte";
    types.pascal.name = "Shortint";
    types.ml.name = "";
    types.go.name = "int8";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int8";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Least_I16()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "int_least16_t";
    types.cpp.name = "int_least16_t";
    types.d.name = "short";
    types.rust.name = "i16";
    types.holyC.name = "I16";
    types.java.name = "short";
    types.csharp.name = "short";
    types.pascal.name = "Smallint";
    types.ml.name = "";
    types.go.name = "int16";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int16";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Least_I32()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "int_least32_t";
    types.cpp.name = "int_least32_t";
    types.d.name = "int";
    types.rust.name = "i32";
    types.holyC.name = "I32";
    types.java.name = "int";
    types.csharp.name = "int";
    types.pascal.name = "Longint";
    types.ml.name = "";
    types.go.name = "int32";
    types.protocol_buffers.name = "int32";
    types.hidl.name = "int32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Least_I64()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "int_least64_t";
    types.cpp.name = "int_least64_t";
    types.d.name = "long";
    types.rust.name = "i64";
    types.holyC.name = "I64";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Int64";
    types.ml.name = "";
    types.go.name = "int64";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Least_I128()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "cent";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "Int64";
    types.ml.name = "";
    types.go.name = "int128";
    types.protocol_buffers.name = "int64";
    types.hidl.name = "int128";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱

//least (unsigned)
◀public: static▶ Cross_Language_Type ☀Least_U8()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "uint_least8_t";
    types.cpp.name = "uint_least8_t";
    types.d.name = "ubyte";
    types.rust.name = "u8";
    types.holyC.name = "U8";
    types.java.name = "byte";
    types.csharp.name = "byte";
    types.pascal.name = "Byte";
    types.ml.name = "";
    types.go.name = "uint8";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint8";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Least_U16()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "uint_least16_t";
    types.cpp.name = "uint_least16_t";
    types.d.name = "ushort";
    types.rust.name = "u16";
    types.holyC.name = "U16";
    types.java.name = "short";
    types.csharp.name = "ushort";
    types.pascal.name = "Word";
    types.ml.name = "";
    types.go.name = "uint16";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint16";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Least_U32()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "uint_least32_t";
    types.cpp.name = "uint_least32_t";
    types.d.name = "uint";
    types.rust.name = "u32";
    types.holyC.name = "U32";
    types.java.name = "int";
    types.csharp.name = "uint";
    types.pascal.name = "Longword";
    types.ml.name = "";
    types.go.name = "uint32";
    types.protocol_buffers.name = "uint32";
    types.hidl.name = "uint32";
    types.processing.name = "int";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Least_U64()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "uint_least64_t";
    types.cpp.name = "uint_least64_t";
    types.d.name = "ulong";
    types.rust.name = "u64";
    types.holyC.name = "U64";
    types.java.name = "long";
    types.csharp.name = "ulong";
    types.pascal.name = "QWord";
    types.ml.name = "";
    types.go.name = "uint64";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint64";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Least_U128()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "ucent";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "long";
    types.csharp.name = "long";
    types.pascal.name = "QWord";
    types.ml.name = "";
    types.go.name = "uint128";
    types.protocol_buffers.name = "uint64";
    types.hidl.name = "uint128";
    types.processing.name = "long";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱

//floating point
◀public: static▶ Cross_Language_Type ☀F32()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "float";
    types.cpp.name = "float";
    types.d.name = "float";
    types.rust.name = "f32";
    types.holyC.name = "F64";
    types.java.name = "float";
    types.csharp.name = "float";
    types.pascal.name = "Single";
    types.ml.name = "";
    types.go.name = "float32";
    types.protocol_buffers.name = "float";
    types.hidl.name = "float32";
    types.processing.name = "float";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀F64()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "double";
    types.cpp.name = "double";
    types.d.name = "double";
    types.rust.name = "f64";
    types.holyC.name = "F64";
    types.java.name = "double";
    types.csharp.name = "double";
    types.pascal.name = "Double";
    types.ml.name = "";
    types.go.name = "float64";
    types.protocol_buffers.name = "double";
    types.hidl.name = "uint8";
    types.hidl.name = "float64";
    types.processing.name = "double";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀F128()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "long double";
    types.cpp.name = "long double";
    types.d.name = "real";
    types.rust.name = "f64";
    types.holyC.name = "F64";
    types.java.name = "double";
    types.csharp.name = "decimal";
    types.pascal.name = "Extended";
    types.ml.name = "";
    types.go.name = "float64";
    types.protocol_buffers.name = "double";
    types.hidl.name = "float64";
    types.processing.name = "double";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱

//OTHER:  

//bool
◀public: static▶ Cross_Language_Type ☀Bool()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "BOOL";
    types.cpp.name = "bool";
    types.d.name = "bool";
    types.rust.name = "bool";
    types.holyC.name = "I8";
    types.java.name = "boolean";
    types.csharp.name = "bool";
    types.pascal.name = "Boolean";
    types.ml.name = "";
    types.go.name = "bool";
    types.protocol_buffers.name = "bool";
    types.hidl.name = "boolean";
    types.processing.name = "boolean";
    
    {
        Needed_Import import;
        import.name = "Defs";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;
    
    return types;
❱

//containers

//sequence
◀public: static▶ Cross_Language_Type ☀Sequence()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "VectorT";
    types.cpp.name = "std::vector";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist";
    types.processing.name = "ArrayList";
    
    //print names
    types.c.printable_name = "ordered sequence";
    types.cpp.printable_name = "ordered sequence";
    types.d.printable_name = "ordered sequence";
    types.rust.printable_name = "ordered sequence";
    types.holyC.printable_name = "ordered sequence";
    types.java.printable_name = "ordered sequence";
    types.csharp.printable_name = "ordered sequence";
    types.pascal.printable_name = "ordered sequence";
    types.ml.printable_name = "ordered sequence";
    types.go.printable_name = "ordered sequence";
    types.hidl.printable_name = "ordered sequence";
    
    //needed imports
    
    {
        Needed_Import import;
        import.name = "Vector";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "vector";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::YES;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

◀public: static▶ Cross_Language_Type ☀Indexes()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "VectorT";
    types.cpp.name = "std::vector<size_t>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist<uint64>";
    types.processing.name = "ArrayList<long>";
    
    //print names
    types.c.printable_name = "indexes";
    types.cpp.printable_name = "indexes";
    types.d.printable_name = "indexes";
    types.rust.printable_name = "indexes";
    types.holyC.printable_name = "indexes";
    types.java.printable_name = "indexes";
    types.csharp.printable_name = "indexes";
    types.pascal.printable_name = "indexes";
    types.ml.printable_name = "indexes";
    types.go.printable_name = "indexes";
    types.hidl.printable_name = "indexes";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Vector";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "vector";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::UNKNOWN;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

◀public: static▶ Cross_Language_Type ☀Ordered_Indexes()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "VectorT";
    types.cpp.name = "std::vector<size_t>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist<uint64>";
    types.processing.name = "ArrayList<long>";
    
    //print names
    types.c.printable_name = "ordered indexes";
    types.cpp.printable_name = "ordered indexes";
    types.d.printable_name = "ordered indexes";
    types.rust.printable_name = "ordered indexes";
    types.holyC.printable_name = "ordered indexes";
    types.java.printable_name = "ordered indexes";
    types.csharp.printable_name = "ordered indexes";
    types.pascal.printable_name = "ordered indexes";
    types.ml.printable_name = "ordered indexes";
    types.go.printable_name = "ordered indexes";
    types.hidl.printable_name = "ordered indexes";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Vector";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "vector";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::YES;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

◀public: static▶ Cross_Language_Type ☀Unordered_Indexes()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "SetT";
    types.cpp.name = "std::set<size_t>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist<uint64>";
    types.processing.name = "ArrayList<long>";
    
    //print names
    types.c.printable_name = "unordered indexes";
    types.cpp.printable_name = "unordered indexes";
    types.d.printable_name = "unordered indexes";
    types.rust.printable_name = "unordered indexes";
    types.holyC.printable_name = "unordered indexes";
    types.java.printable_name = "unordered indexes";
    types.csharp.printable_name = "unordered indexes";
    types.pascal.printable_name = "unordered indexes";
    types.ml.printable_name = "unordered indexes";
    types.go.printable_name = "unordered indexes";
    types.hidl.printable_name = "unordered indexes";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Set";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "set";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::YES;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

◀public: static▶ Cross_Language_Type ☀Strings()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "VecStringsT";
    types.cpp.name = "std::vector<std::string>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist<string>";
    types.processing.name = "ArrayList<String>";
    
    //print names
    types.c.printable_name = "strings";
    types.cpp.printable_name = "strings";
    types.d.printable_name = "strings";
    types.rust.printable_name = "strings";
    types.holyC.printable_name = "strings";
    types.java.printable_name = "strings";
    types.csharp.printable_name = "strings";
    types.pascal.printable_name = "strings";
    types.ml.printable_name = "strings";
    types.go.printable_name = "strings";
    types.hidl.printable_name = "strings";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Vector";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "string";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
        
        import.name = "vector";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::YES;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

◀public: static▶ Cross_Language_Type ☀Unordered_Strings()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "UnorderedSetT";
    types.cpp.name = "std::unordered_set<size_t>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "set<string>";
    types.processing.name = "ArrayList<string>";
    
    //print names
    types.c.printable_name = "unordered strings";
    types.cpp.printable_name = "unordered strings";
    types.d.printable_name = "unordered strings";
    types.rust.printable_name = "unordered strings";
    types.holyC.printable_name = "unordered strings";
    types.java.printable_name = "unordered strings";
    types.csharp.printable_name = "unordered strings";
    types.pascal.printable_name = "unordered strings";
    types.ml.printable_name = "unordered strings";
    types.go.printable_name = "unordered strings";
    types.hidl.printable_name = "unordered strings";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "UnorderedSet";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "unordered_set";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
        
        import.name = "string";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

◀public: static▶ Cross_Language_Type ☀Guids()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "GuidT";
    types.cpp.name = "std::vector<hub::base::guid>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist<guid>";
    types.processing.name = "ArrayList<String>";
    
    //print names
    types.c.printable_name = "guids";
    types.cpp.printable_name = "guids";
    types.d.printable_name = "guids";
    types.rust.printable_name = "guids";
    types.holyC.printable_name = "guids";
    types.java.printable_name = "guids";
    types.csharp.printable_name = "guids";
    types.pascal.printable_name = "guids";
    types.ml.printable_name = "guids";
    types.go.printable_name = "guids";
    types.hidl.printable_name = "guids";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Guid";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "hub/base/guid";
        import.type = Import_Type::LOCAL;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::UNKNOWN;
    types.inferred_properties.collection = Tri_Bool::NO;
    
    return types;
❱

◀public: static▶ Cross_Language_Type ☀Ordered_Guids()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "GuidT";
    types.cpp.name = "std::vector<hub::base::guid>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist<guid>";
    types.processing.name = "ArrayList<String>";
    
    //print names
    types.c.printable_name = "ordered guids";
    types.cpp.printable_name = "ordered guids";
    types.d.printable_name = "ordered guids";
    types.rust.printable_name = "ordered guids";
    types.holyC.printable_name = "ordered guids";
    types.java.printable_name = "ordered guids";
    types.csharp.printable_name = "ordered guids";
    types.pascal.printable_name = "ordered guids";
    types.ml.printable_name = "ordered guids";
    types.go.printable_name = "ordered guids";
    types.hidl.printable_name = "ordered guids";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Guid";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "hub/base/guid";
        import.type = Import_Type::LOCAL;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::UNKNOWN;
    types.inferred_properties.collection = Tri_Bool::NO;
    
    return types;
❱

◀public: static▶ Cross_Language_Type ☀Unordered_Guids()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "GuidT";
    types.cpp.name = "std::vector<hub::base::guid>";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "std::set<guid>";
    types.processing.name = "ArrayList<String>";
    
    //print names
    types.c.printable_name = "unordered guids";
    types.cpp.printable_name = "unordered guids";
    types.d.printable_name = "unordered guids";
    types.rust.printable_name = "unordered guids";
    types.holyC.printable_name = "unordered guids";
    types.java.printable_name = "unordered guids";
    types.csharp.printable_name = "unordered guids";
    types.pascal.printable_name = "unordered guids";
    types.ml.printable_name = "unordered guids";
    types.go.printable_name = "unordered guids";
    types.hidl.printable_name = "unordered guids";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Guid";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "hub/base/guid";
        import.type = Import_Type::LOCAL;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::UNKNOWN;
    types.inferred_properties.collection = Tri_Bool::NO;
    
    return types;
❱


◀public: static▶ Cross_Language_Type ☀Array()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::FUNDAMENTAL;
    types.cpp.category = Language_Type_Category::FUNDAMENTAL;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::UNKNOWN;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Vector()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "VectorT";
    types.cpp.name = "std::vector";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "arraylist";
    types.processing.name = "ArrayList";
    
    //print names
    types.c.printable_name = "sequence";
    types.cpp.printable_name = "sequence";
    types.d.printable_name = "sequence";
    types.rust.printable_name = "sequence";
    types.holyC.printable_name = "sequence";
    types.java.printable_name = "sequence";
    types.csharp.printable_name = "sequence";
    types.pascal.printable_name = "sequence";
    types.ml.printable_name = "sequence";
    types.go.printable_name = "sequence";
    types.hidl.printable_name = "sequence";
    
    //needed imports
    {
        Needed_Import import;
        import.name = "Vector";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "vector";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::UNKNOWN;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Deque()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Flist()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Dlist()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "std::linked_list";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "linkedlist";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    
    return types;
❱

//associative
◀public: static▶ Cross_Language_Type ☀Set()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "std::set";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "set";
    
    //needed imports
    //needed imports
    {
        Needed_Import import;
        import.name = "Set";
        import.type = Import_Type::LOCAL;
        types.c.needed_imports.emplace_back(import);
    }
    
    {
        Needed_Import import;
        import.name = "set";
        import.type = Import_Type::SYSTEM;
        types.cpp.needed_imports.emplace_back(import);
    }
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Map()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "MapT";
    types.cpp.name = "std::map";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "dictionary";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Mset()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Mmap()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

//unordered associative
◀public: static▶ Cross_Language_Type ☀Uset()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Umap()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;



	types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Umset()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;



	types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Ummap()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

//adapters
◀public: static▶ Cross_Language_Type ☀Stack()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Queue()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Pqueue()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

types.inferred_properties.assumes_plurality = true;
    types.inferred_properties.sequence = Tri_Bool::NO;
    types.inferred_properties.collection = Tri_Bool::YES;
    
    return types;
❱

//vocabulary
◀public: static▶ Cross_Language_Type ☀Any()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Optional()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;

    types.inferred_properties.optional = Tri_Bool::YES;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Variant()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;
    
    return types;
❱
◀public: static▶ Cross_Language_Type ☀Result()❰
    Cross_Language_Type types;
    
    //equivalent type
    types.c.name = "";
    types.cpp.name = "";
    types.d.name = "";
    types.rust.name = "";
    types.holyC.name = "";
    types.java.name = "";
    types.csharp.name = "";
    types.pascal.name = "";
    types.ml.name = "";
    types.go.name = "";
    types.hidl.name = "";
    
    //needed imports
    
    //size information
    
    //type category
    types.c.category = Language_Type_Category::ABSTRACT;
    types.cpp.category = Language_Type_Category::ABSTRACT;
    
    return types;
❱
