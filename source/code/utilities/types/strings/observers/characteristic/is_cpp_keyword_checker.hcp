class
❪string❫
❪vector❫
⚯
❪map❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/types/strings/transformers/casing/lib"❫
⚞⚟

◀public: static▶ bool ☀Check(std::string const& str)❰

    std::vector<std::string> keywords;
    keywords.emplace_back("alignas");
    keywords.emplace_back("alignof");
    keywords.emplace_back("and");
    keywords.emplace_back("and_eq");
    keywords.emplace_back("asm");
    keywords.emplace_back("atomic_cancel");
    keywords.emplace_back("atomic_commit");
    keywords.emplace_back("atomic_noexcept");
    keywords.emplace_back("auto");
    keywords.emplace_back("bitand");
    keywords.emplace_back("bitor");
    keywords.emplace_back("bool");
    keywords.emplace_back("break");
    keywords.emplace_back("case");
    keywords.emplace_back("catch");
    keywords.emplace_back("char");
    keywords.emplace_back("char8_t");
    keywords.emplace_back("char16_t");
    keywords.emplace_back("char32_t");
    keywords.emplace_back("class");
    keywords.emplace_back("compl");
    keywords.emplace_back("concept");
    keywords.emplace_back("const");
    keywords.emplace_back("consteval");
    keywords.emplace_back("constexpr");
    keywords.emplace_back("constinit");
    keywords.emplace_back("const_cast");
    keywords.emplace_back("continue");
    keywords.emplace_back("co_await");
    keywords.emplace_back("co_return");
    keywords.emplace_back("co_yield");
    keywords.emplace_back("decltype");
    keywords.emplace_back("default");
    keywords.emplace_back("delete");
    keywords.emplace_back("do");
    keywords.emplace_back("double");
    keywords.emplace_back("dynamic_cast");
    keywords.emplace_back("else");
    keywords.emplace_back("enum");
    keywords.emplace_back("explicit");
    keywords.emplace_back("export");
    keywords.emplace_back("extern");
    keywords.emplace_back("false");
    keywords.emplace_back("float");
    keywords.emplace_back("for");
    keywords.emplace_back("friend");
    keywords.emplace_back("goto");
    keywords.emplace_back("if");
    keywords.emplace_back("inline");
    keywords.emplace_back("int");
    keywords.emplace_back("long");
    keywords.emplace_back("mutable");
    keywords.emplace_back("namespace");
    keywords.emplace_back("new");
    keywords.emplace_back("noexcept");
    keywords.emplace_back("not");
    keywords.emplace_back("not_eq");
    keywords.emplace_back("nullptr");
    keywords.emplace_back("operator");
    keywords.emplace_back("or");
    keywords.emplace_back("or_eq");
    keywords.emplace_back("private");
    keywords.emplace_back("protected");
    keywords.emplace_back("public");
    keywords.emplace_back("reflexpr");
    keywords.emplace_back("register");
    keywords.emplace_back("reinterpret_cast");
    keywords.emplace_back("requires");
    keywords.emplace_back("return");
    keywords.emplace_back("short");
    keywords.emplace_back("signed");
    keywords.emplace_back("sizeof");
    keywords.emplace_back("static");
    keywords.emplace_back("static_assert");
    keywords.emplace_back("static_cast");
    keywords.emplace_back("struct");
    keywords.emplace_back("switch");
    keywords.emplace_back("synchronized");
    keywords.emplace_back("template");
    keywords.emplace_back("this");
    keywords.emplace_back("thread_local");
    keywords.emplace_back("throw");
    keywords.emplace_back("true");
    keywords.emplace_back("try");
    keywords.emplace_back("typedef");
    keywords.emplace_back("typeid");
    keywords.emplace_back("typename");
    keywords.emplace_back("union");
    keywords.emplace_back("unsigned");
    keywords.emplace_back("using");
    keywords.emplace_back("virtual");
    keywords.emplace_back("void");
    keywords.emplace_back("volatile");
    keywords.emplace_back("wchar_t");
    keywords.emplace_back("while");
    keywords.emplace_back("xor");
    keywords.emplace_back("xor_eq");

    
    return String_In_Vector(keywords,As_Lowercase(str));
❱