class
❪iostream❫
❪string❫
❪utility❫
❪cstdlib❫
❪fstream❫
❪"code/utilities/types/tree/bst/annotated_bst_state.hpp"❫
❪"code/utilities/types/tree/tree_traversal.hpp"❫
❪"code/utilities/types/tree/tree_node_properties.hpp"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
❪"code/utilities/shell/lib"❫
❪"code/utilities/types/char/lib"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/types/tree/bst/annotated_bst_visualizer"❫
⚯
⚞⚟

//maybe animate
//https://bl.ocks.org/magjac/4acffdb3afbc4f71b448a210b5060bca
// convert -loop 0 -delay 100 001.png -delay 20 *.png -delay 200 019.png animation.gif

◀public:
static void fix(Annotated_Bst_State & state){
    
    Annotated_Bst_Visualizer::clean_output_folder();
    
    //they both start at the root
    Annotated_Bst_Visualizer::make_image(state);
    state.b = state.a;
    Annotated_Bst_Visualizer::make_image(state);
    
    //set the loop back
    move_a_all_the_way_right(state);
    state.a->right = state.b;
    Annotated_Bst_Visualizer::make_image(state);
    
    //single HOP from ROOT implementation
    if (!state.a->left){
        
        Single_Hop_Implementation(state);
    }
    
    //double HOP from ROOT implementation
    //find the tail
    else{
        state.b = state.a;
        Annotated_Bst_Visualizer::make_image(state);
        
        while (state.a->left){
            
            state.a = state.a->left;
            Annotated_Bst_Visualizer::make_image(state);
            move_a_all_the_way_right(state);
        }
        
        state.a->right = state.b;
        Annotated_Bst_Visualizer::make_image(state);
        state.b = state.b->right;
        Annotated_Bst_Visualizer::make_image(state);
        
        Double_Hop_Implementation(state);
    }
}
▶

◀public:
static void Single_Hop_Implementation(Annotated_Bst_State & state){
    move_b_to_the_leftest_double_null(state);
    
    //a controls the new block indirectly
    state.a->left = state.b;
    Annotated_Bst_Visualizer::make_image(state);
    
    //take b back home
    set_b_to_a_right(state);
    
    modified_LR_morris_traversal(state);
}
▶

◀public:
static void Double_Hop_Implementation(Annotated_Bst_State & state){
    move_b_to_the_leftest_double_null(state);
    
    //a controls the new block indirectly
    state.a->left = state.b;
    Annotated_Bst_Visualizer::make_image(state);
    
    //take b back home
    set_b_to_a_right_right(state);
    
    modified_LR_morris_traversal(state);
    
    //we didn't find the discrepancy, but there's gotta be one
    //so we can fix it quick and cleanup
    if (!state.a->left->right){
    }
}
▶

◀public:
static void modified_LR_morris_traversal(Annotated_Bst_State & state){
    
    //we've given A an additional storage location so it can participate indirectly
    //in a morris traversal
    if (state.b == nullptr){
        return; 
    }
    while (state.a->left->right != state.a) {
        
        
        //the hack discrepancy climb
        if (state.b->left && (state.b->left == state.a->left)){
            std::cout << "hack climb" << std::endl;
            
            //possible discrepancy 1
            std::cout << state.b->left->val << "->" << state.b->val << std::endl;
            if (state.b->left->val > state.b->val){
                std::cout << "FOUND DISCREPENCY" << std::endl;
                state.a->left->right = state.b->left; //store discrepancy
                state.b = state.b->right; //do what you would've done this iteration
                Annotated_Bst_Visualizer::make_image(state);
                break;
            }
            
            //possible discrepancy 2
            std::cout << state.b->val << "->" << state.b->right->val << std::endl;
            if (state.b->val > state.b->right->val){
                std::cout << "FOUND DISCREPENCY" << std::endl;
                state.a->left->right = state.b->right; //store discrepancy
                state.b = state.b->right; //do what you would've done this iteration
                Annotated_Bst_Visualizer::make_image(state);
                break;
            }
            
            
            state.b = state.b->right;
            Annotated_Bst_Visualizer::make_image(state);
        }
        
        //the normal climb
        else if (state.b->left == nullptr) {
            
            //possible discrepancy 3
            std::cout << state.b->val << "->" << state.b->right->val << std::endl;
            if (state.b->val > state.b->right->val){
                std::cout << "FOUND DISCREPENCY" << std::endl;
                state.a->left->right = state.b; //store discrepancy
                state.b = state.b->right; //do what you would've done this iteration
                Annotated_Bst_Visualizer::make_image(state);
                break;
            }
            
            state.b = state.b->right;
            Annotated_Bst_Visualizer::make_image(state);
        }
        else{
            
            find_the_inorder_predecessor_of_current_using_a_proxy(state);
            
            //we've reached the end with no discrepancies found
            if (state.a->left->right == state.a){
                std::cout << "full traversal and no discrepancy was found" << std::endl;
                state.a->left->right = nullptr;
                Annotated_Bst_Visualizer::make_image(state);
                break;
            }
            
            // if (state.b->left == state.a){
            //     std::cout << "FULL LOOP" << std::endl;
            // }
            
            /* Make current as the right child of its inorder  
               predecessor */
            if (state.a->left->right->right == nullptr) {
                state.a->left->right->right = state.b;
                Annotated_Bst_Visualizer::make_image(state);
                state.b = state.b->left;
                Annotated_Bst_Visualizer::make_image(state);
            } 
            
            /* Revert the changes made in the 'if' part to restore  
               the original tree i.e., fix the right child 
               of predecessor */
            else{
                if (state.b && state.b->right){
                    state.a->left->right->right = state.b;
                    Annotated_Bst_Visualizer::make_image(state);
                    state.a->left->right->right = state.b->right;
                    Annotated_Bst_Visualizer::make_image(state);
                    move_a_proxy_pointer_all_the_way_left(state);
                    
                    
                    
                    //possible discrepancy 4
                    std::cout << state.b->val << "->" << state.a->left->right->right->val << std::endl;
                    if (state.b->val > state.a->left->right->right->val){
                        std::cout << "FOUND DISCREPENCY" << std::endl;
                        state.a->left->right->right = nullptr; //do what you would've done this iteration
                        state.a->left->right = state.b; //store discrepancy
                        state.b = state.b->right; //do what you would've done this iteration
                        Annotated_Bst_Visualizer::make_image(state);
                        break;
                    }
                    
                    
                    
                    
                }
                state.b = state.b->right;
                Annotated_Bst_Visualizer::make_image(state);
                state.a->left->right->right = nullptr;
                Annotated_Bst_Visualizer::make_image(state);
            }
        }
    }
    
}
▶

◀public:
static void find_the_inorder_predecessor_of_current_using_a_proxy(Annotated_Bst_State & state){
    /* Find the inorder predecessor of current */
    state.a->left->right = state.b;
    Annotated_Bst_Visualizer::make_image(state);
    state.a->left->right = state.b->left;
    Annotated_Bst_Visualizer::make_image(state);
    
    while (state.a->left->right->right != nullptr && state.a->left->right->right != state.b){
        state.a->left->right = state.a->left->right->right;
        Annotated_Bst_Visualizer::make_image(state);
    }
}
▶

◀public:
static void observe_a_prev_current_state(Annotated_Bst_State & state){
    if (state.b->val != state.a->left->right->right->val){
        std::cout << state.b->val << " " << state.a->left->right->right->val << std::endl;
    }
    else{
        std::cout << state.b->val << " " << state.b->right->val << std::endl;
    }
}
▶

◀public:
static void move_a_proxy_pointer_all_the_way_left(Annotated_Bst_State & state){
    if (state.a->left->right->right){
        if (state.a->left->right->right->left){
            state.a->left->right->right = state.a->left->right->right->left;
            Annotated_Bst_Visualizer::make_image(state);
        }
    }
}
▶



◀public:
static void perform_the_hickey_shuffle(Annotated_Bst_State & state){
    
    perform_the_hickey_shuffle_and_stay(state);
    state.a = state.b;
    Annotated_Bst_Visualizer::make_image(state);
}
▶

◀public:
static void perform_the_hickey_shuffle_and_stay(Annotated_Bst_State & state){
    
    //set the loop back
    move_a_all_the_way_right(state);
    state.a->right = state.b;
    Annotated_Bst_Visualizer::make_image(state);
    
    //no tail?
    //set the left pointer equal to itself
    if (!state.a->left){
        set_node_a_left_to_itself(state);
        Annotated_Bst_Visualizer::make_image(state);
    }
    
    //find the tail
    else{
        state.b = state.a;
        Annotated_Bst_Visualizer::make_image(state);
        
        while (state.a->left){
            
            state.a = state.a->left;
            Annotated_Bst_Visualizer::make_image(state);
            move_a_all_the_way_right(state);
        }
        
        state.a->right = state.b;
        Annotated_Bst_Visualizer::make_image(state);
        state.a->left = (BinaryNode<int> *)&(state.a->right);
        Annotated_Bst_Visualizer::make_image(state);
        
        state.b = state.b->right;
        Annotated_Bst_Visualizer::make_image(state);
    }
}
▶



//basic traversing
◀public:
static void move_a_all_the_way_right(Annotated_Bst_State & state){
    
    while (state.a->right){
        state.a = state.a->right;
        Annotated_Bst_Visualizer::make_image(state);
    }
}
▶
◀public:
static void move_b_all_the_way_left(Annotated_Bst_State & state){
    
    while (state.b->left){
        state.b = state.b->left;
        Annotated_Bst_Visualizer::make_image(state);
    }
}
▶

◀public:
static void move_b_to_the_leftest_double_null(Annotated_Bst_State & state){
    
    move_b_all_the_way_left(state);
    while (state.b->right){
        state.b = state.b->right;
        move_b_all_the_way_left(state);
    }
    
}
▶

◀public:
static void move_a_right(Annotated_Bst_State & state){
        state.a = state.a->right;
        Annotated_Bst_Visualizer::make_image(state);
}
▶

◀public:
static void move_a_right_right(Annotated_Bst_State & state){
        state.a = state.a->right;
        Annotated_Bst_Visualizer::make_image(state);
        state.a = state.a->right;
        Annotated_Bst_Visualizer::make_image(state);
}
▶

◀public:
static void set_b_to_a_right(Annotated_Bst_State & state){
        state.b = state.a;
        Annotated_Bst_Visualizer::make_image(state);
        state.b = state.b->right;
        Annotated_Bst_Visualizer::make_image(state);
}
▶

◀public:
static void set_b_to_a_right_right(Annotated_Bst_State & state){
        state.b = state.a;
        Annotated_Bst_Visualizer::make_image(state);
        state.b = state.b->right;
        Annotated_Bst_Visualizer::make_image(state);
        state.b = state.b->right;
        Annotated_Bst_Visualizer::make_image(state);
}
▶




//node hacking
◀public:
static void set_node_a_left_to_itself(Annotated_Bst_State & state){
    state.a->left = (BinaryNode<int> *)&(state.a->left);
}
▶
◀public:
static void set_node_b_left_to_itself(Annotated_Bst_State & state){
    state.b->left = (BinaryNode<int> *)&(state.b->left);
}
▶
◀public:
static void set_node_b_left_to_sibling(Annotated_Bst_State & state){
    state.b->left = (BinaryNode<int> *)&(state.b->right);
}
▶


