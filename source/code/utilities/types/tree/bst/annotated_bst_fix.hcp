class
❪iostream❫
❪string❫
❪utility❫
❪cstdlib❫
❪fstream❫
❪"code/utilities/types/tree/bst/annotated_bst_state.hpp"❫
❪"code/utilities/types/tree/tree_traversal.hpp"❫
❪"code/utilities/types/tree/tree_node_properties.hpp"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
❪"code/utilities/shell/lib"❫
❪"code/utilities/types/char/lib"❫
❪"code/utilities/filesystem/paths/lib"❫
❪"code/utilities/types/tree/bst/annotated_bst_visualizer"❫
⚯
⚞⚟

//maybe animate
//https://bl.ocks.org/magjac/4acffdb3afbc4f71b448a210b5060bca
// convert -loop 0 -delay 100 001.png -delay 20 *.png -delay 200 019.png animation.gif

◀public:
static void fix(Annotated_Bst_State & state){
    
    Annotated_Bst_Visualizer::clean_output_folder();
    
    //they both start at the root
    Annotated_Bst_Visualizer::make_image(state);
    state.b = state.a;
    Annotated_Bst_Visualizer::make_image(state);
    
    //set the loop back
    move_a_all_the_way_right(state);
    state.a->right = state.b;
    Annotated_Bst_Visualizer::make_image(state);
    
    //single HOP from ROOT implementation
    if (!state.a->left){
        
        Single_Hop_Implementation(state);
    }
    
    //double HOP from ROOT implementation
    //find the tail
    else{
        state.b = state.a;
        Annotated_Bst_Visualizer::make_image(state);
        
        while (state.a->left){
            
            state.a = state.a->left;
            Annotated_Bst_Visualizer::make_image(state);
            move_a_all_the_way_right(state);
        }
        
        state.a->right = state.b;
        Annotated_Bst_Visualizer::make_image(state);
        state.b = state.b->right;
        Annotated_Bst_Visualizer::make_image(state);
        
        Double_Hop_Implementation(state);
    }
}
▶

◀public:
static void Single_Hop_Implementation(Annotated_Bst_State & state){
    move_b_to_the_leftest_double_null(state);
    
    //a controls the new block indirectly
    state.a->left = state.b;
    Annotated_Bst_Visualizer::make_image(state);
    
    //take b back home
    set_b_to_a_right(state);
    
    modified_LR_morris_traversal_looking_for_discrepancy(state);
    
    //we didn't find the discrepancy, but there's gotta be one
    //but were only 1 hope away, so this doesn't make any sense
    if (!state.a->left->right){
    }
}
▶

◀public:
static void Double_Hop_Implementation(Annotated_Bst_State & state){
    move_b_to_the_leftest_double_null(state);
    
    //a controls the new block indirectly
    state.a->left = state.b;
    Annotated_Bst_Visualizer::make_image(state);
    
    //take b back home
    set_b_to_a_right_right(state);
    
    modified_LR_morris_traversal_looking_for_discrepancy(state);
    
    //we didn't find the discrepancy, but there's gotta be one
    //so we can fix it quick and cleanup
    if (!state.a->left->right){
        std::cout << "full traversal and no discrepancy was found" << std::endl;
        //TODO: fix tree when no discrepancy was found
    }
    else{
        
        //we found a discrepancy, but we still have to finish the morris traversal because the tree may still be threaded in places
        //and probably needs cleaned up since we'll need to do a reverse morris later.
        std::cout << "we found the discrepancy and need to finish the traversal" << std::endl;
        
    }
}
▶

◀public:
static void modified_LR_morris_traversal_looking_for_discrepancy(Annotated_Bst_State & state){
    
    //we've given A an additional storage location so it can participate indirectly
    //in a morris traversal
    if (state.b == nullptr){
        return; 
    }
    while (!proxy1_points_to_a(state)) {
        
        
        //the hack discrepancy climb
        if (state.b->left && (state.b->left == state.a->left)){
            std::cout << "hack climb" << std::endl;
            
            //possible discrepancy 1
            std::cout << state.b->left->val << "->" << state.b->val << std::endl;
            if (state.b->left->val > state.b->val){
                std::cout << "FOUND DISCREPENCY" << std::endl;
                set_proxy1_to_b_left(state); //store discrepancy
                state.b = state.b->right; //do what you would've done this iteration
                Annotated_Bst_Visualizer::make_image(state);
                break;
            }
            
            //possible discrepancy 2
            std::cout << state.b->val << "->" << state.b->right->val << std::endl;
            if (state.b->val > state.b->right->val){
                std::cout << "FOUND DISCREPENCY" << std::endl;
                set_proxy1_to_b_right(state); //store discrepancy
                state.b = state.b->right; //do what you would've done this iteration
                Annotated_Bst_Visualizer::make_image(state);
                break;
            }
            
            
            state.b = state.b->right;
            Annotated_Bst_Visualizer::make_image(state);
        }
        
        //the normal climb
        else if (state.b->left == nullptr) {
            
            //possible discrepancy 3
            std::cout << state.b->val << "->" << state.b->right->val << std::endl;
            if (state.b->val > state.b->right->val){
                std::cout << "FOUND DISCREPENCY" << std::endl;
                set_proxy1_to_b(state); //store discrepancy
                state.b = state.b->right; //do what you would've done this iteration
                Annotated_Bst_Visualizer::make_image(state);
                break;
            }
            
            state.b = state.b->right;
            Annotated_Bst_Visualizer::make_image(state);
        }
        else{
            
            find_the_inorder_predecessor_of_current_using_a_proxy(state);
            
            //we've reached the end with no discrepancies found
            if (proxy1_points_to_a(state)){
                std::cout << "full traversal and no discrepancy was found" << std::endl;
                set_proxy1_to_null(state);
                Annotated_Bst_Visualizer::make_image(state);
                break;
            }
            
            // if (state.b->left == state.a){
            //     std::cout << "FULL LOOP" << std::endl;
            // }
            
            /* Make current as the right child of its inorder  
               predecessor */
            if (proxy1_right_points_to_null(state)) {
                set_proxy1_right_to_b(state);
                Annotated_Bst_Visualizer::make_image(state);
                state.b = state.b->left;
                Annotated_Bst_Visualizer::make_image(state);
            } 
            
            /* Revert the changes made in the 'if' part to restore  
               the original tree i.e., fix the right child 
               of predecessor */
            else{
                if (state.b && state.b->right){
                    set_proxy1_right_to_b(state);
                    Annotated_Bst_Visualizer::make_image(state);
                    set_proxy1_right_to_b_right(state);
                    Annotated_Bst_Visualizer::make_image(state);
                    move_a_proxy_pointer_all_the_way_left(state);
                    
                    
                    
                    //possible discrepancy 4
                    std::cout << state.b->val << "->" << proxy1_right_val(state) << std::endl;
                    if (state.b->val > proxy1_right_val(state)){
                        std::cout << "FOUND DISCREPENCY" << std::endl;
                        set_proxy1_right_to_null(state); //do what you would've done this iteration
                        set_proxy1_to_b(state); //store discrepancy
                        state.b = state.b->right; //do what you would've done this iteration
                        Annotated_Bst_Visualizer::make_image(state);
                        break;
                    }
                }
                state.b = state.b->right;
                Annotated_Bst_Visualizer::make_image(state);
                set_proxy1_right_to_null(state);
                Annotated_Bst_Visualizer::make_image(state);
            }
        }
    }
    
}
▶



◀public:
static int proxy1_right_val(Annotated_Bst_State & state){
    return state.a->left->right->right->val;
}
▶
◀public:
static void set_proxy1_to_null(Annotated_Bst_State & state){
    state.a->left->right = nullptr;
}
▶
◀public:
static void set_proxy1_right_to_null(Annotated_Bst_State & state){
    state.a->left->right = nullptr;
}
▶
◀public:
static bool proxy1_points_to_a(Annotated_Bst_State & state){
    return state.a->left->right == state.a;
}
▶
◀public:
static bool proxy1_right_points_to_null(Annotated_Bst_State & state){
    return state.a->left->right->right == nullptr;
}
▶
◀public:
static void set_proxy1_to_b(Annotated_Bst_State & state){
    state.a->left->right = state.b;
}
▶
◀public:
static void set_proxy1_right_to_b(Annotated_Bst_State & state){
    state.a->left->right->right = state.b;
}
▶
◀public:
static void set_proxy1_to_b_left(Annotated_Bst_State & state){
    state.a->left->right = state.b->left;
}
▶
◀public:
static void set_proxy1_to_b_right(Annotated_Bst_State & state){
    state.a->left->right = state.b->right;
}
▶
◀public:
static void set_proxy1_right_to_b_right(Annotated_Bst_State & state){
    state.a->left->right->right = state.b->right;
}
▶


◀public:
static void continued_LR_morris_traversal_looking_for_discrepancy_or_end(Annotated_Bst_State & state){
}
▶

◀public:
static void find_the_inorder_predecessor_of_current_using_a_proxy(Annotated_Bst_State & state){
    /* Find the inorder predecessor of current */
    state.a->left->right = state.b;
    Annotated_Bst_Visualizer::make_image(state);
    state.a->left->right = state.b->left;
    Annotated_Bst_Visualizer::make_image(state);
    
    while (state.a->left->right->right != nullptr && state.a->left->right->right != state.b){
        state.a->left->right = state.a->left->right->right;
        Annotated_Bst_Visualizer::make_image(state);
    }
}
▶

◀public:
static void observe_a_prev_current_state(Annotated_Bst_State & state){
    if (state.b->val != state.a->left->right->right->val){
        std::cout << state.b->val << " " << state.a->left->right->right->val << std::endl;
    }
    else{
        std::cout << state.b->val << " " << state.b->right->val << std::endl;
    }
}
▶

◀public:
static void move_a_proxy_pointer_all_the_way_left(Annotated_Bst_State & state){
    if (state.a->left->right->right){
        if (state.a->left->right->right->left){
            state.a->left->right->right = state.a->left->right->right->left;
            Annotated_Bst_Visualizer::make_image(state);
        }
    }
}
▶



◀public:
static void perform_the_hickey_shuffle(Annotated_Bst_State & state){
    
    perform_the_hickey_shuffle_and_stay(state);
    state.a = state.b;
    Annotated_Bst_Visualizer::make_image(state);
}
▶

◀public:
static void perform_the_hickey_shuffle_and_stay(Annotated_Bst_State & state){
    
    //set the loop back
    move_a_all_the_way_right(state);
    state.a->right = state.b;
    Annotated_Bst_Visualizer::make_image(state);
    
    //no tail?
    //set the left pointer equal to itself
    if (!state.a->left){
        set_node_a_left_to_itself(state);
        Annotated_Bst_Visualizer::make_image(state);
    }
    
    //find the tail
    else{
        state.b = state.a;
        Annotated_Bst_Visualizer::make_image(state);
        
        while (state.a->left){
            
            state.a = state.a->left;
            Annotated_Bst_Visualizer::make_image(state);
            move_a_all_the_way_right(state);
        }
        
        state.a->right = state.b;
        Annotated_Bst_Visualizer::make_image(state);
        state.a->left = (BinaryNode<int> *)&(state.a->right);
        Annotated_Bst_Visualizer::make_image(state);
        
        state.b = state.b->right;
        Annotated_Bst_Visualizer::make_image(state);
    }
}
▶



//basic traversing
◀public:
static void move_a_all_the_way_right(Annotated_Bst_State & state){
    
    while (state.a->right){
        state.a = state.a->right;
        Annotated_Bst_Visualizer::make_image(state);
    }
}
▶
◀public:
static void move_b_all_the_way_left(Annotated_Bst_State & state){
    
    while (state.b->left){
        state.b = state.b->left;
        Annotated_Bst_Visualizer::make_image(state);
    }
}
▶

◀public:
static void move_b_to_the_leftest_double_null(Annotated_Bst_State & state){
    
    move_b_all_the_way_left(state);
    while (state.b->right){
        state.b = state.b->right;
        move_b_all_the_way_left(state);
    }
    
}
▶

◀public:
static void move_a_right(Annotated_Bst_State & state){
        state.a = state.a->right;
        Annotated_Bst_Visualizer::make_image(state);
}
▶

◀public:
static void move_a_right_right(Annotated_Bst_State & state){
        state.a = state.a->right;
        Annotated_Bst_Visualizer::make_image(state);
        state.a = state.a->right;
        Annotated_Bst_Visualizer::make_image(state);
}
▶

◀public:
static void set_b_to_a_right(Annotated_Bst_State & state){
        state.b = state.a;
        Annotated_Bst_Visualizer::make_image(state);
        state.b = state.b->right;
        Annotated_Bst_Visualizer::make_image(state);
}
▶

◀public:
static void set_b_to_a_right_right(Annotated_Bst_State & state){
        state.b = state.a;
        Annotated_Bst_Visualizer::make_image(state);
        state.b = state.b->right;
        Annotated_Bst_Visualizer::make_image(state);
        state.b = state.b->right;
        Annotated_Bst_Visualizer::make_image(state);
}
▶




//node hacking
◀public:
static void set_node_a_left_to_itself(Annotated_Bst_State & state){
    state.a->left = (BinaryNode<int> *)&(state.a->left);
}
▶
◀public:
static void set_node_b_left_to_itself(Annotated_Bst_State & state){
    state.b->left = (BinaryNode<int> *)&(state.b->left);
}
▶
◀public:
static void set_node_b_left_to_sibling(Annotated_Bst_State & state){
    state.b->left = (BinaryNode<int> *)&(state.b->right);
}
▶


