class
❪iostream❫
❪string❫
❪utility❫
❪cstdlib❫
❪fstream❫
❪"code/utilities/types/tree/bst/annotated_bst_state.hpp"❫
❪"code/utilities/types/tree/tree_traversal.hpp"❫
❪"code/utilities/types/tree/tree_node_properties.hpp"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
❪"code/utilities/shell/lib"❫
❪"code/utilities/types/char/lib"❫
⚯
⚞⚟

//maybe animate
//https://bl.ocks.org/magjac/4acffdb3afbc4f71b448a210b5060bca

◀public:
static void fix(Annotated_Bst_State & state){
    
    //they both start at the root
    make_image(state);
    state.b = state.a;
    make_image(state);
    
    perform_the_hickey_shuffle_and_stay(state);
    
    
    move_b_all_the_way_left(state);
    if (Tree_Node_Properties::left_node_points_to_itself(state.a)){
        set_node_b_left_to_itself(state);
        make_image(state);
    }
    else if (Tree_Node_Properties::left_node_points_to_its_sibling(state.a)){
        set_node_b_left_to_sibling(state);
        make_image(state);
    }
    state.a->left = state.b;
    make_image(state);
}
▶

◀public:
static void perform_the_hickey_shuffle(Annotated_Bst_State & state){
    
    perform_the_hickey_shuffle_and_stay(state);
    state.a = state.b;
    make_image(state);
}
▶

◀public:
static void perform_the_hickey_shuffle_and_stay(Annotated_Bst_State & state){
    
    //set the loop back
    move_a_all_the_way_right(state);
    state.a->right = state.b;
    make_image(state);
    
    //no tail?
    //set the left pointer equal to itself
    if (!state.a->left){
        set_node_a_left_to_itself(state);
        make_image(state);
    }
    
    //find the tail
    else{
        state.b = state.a;
        make_image(state);
        
        while (state.a->left){
            
            state.a = state.a->left;
            make_image(state);
            move_a_all_the_way_right(state);
        }
        
        state.a->right = state.b;
        make_image(state);
        state.a->left = (BinaryNode<int> *)&(state.a->right);
        make_image(state);
        
        state.b = state.b->right;
        make_image(state);
    }
}
▶



//basic traversing
◀public:
static void move_a_all_the_way_right(Annotated_Bst_State & state){
    
    while (state.a->right){
        state.a = state.a->right;
        make_image(state);
    }
}
▶
◀public:
static void move_b_all_the_way_left(Annotated_Bst_State & state){
    
    while (state.b->left){
        state.b = state.b->left;
        make_image(state);
    }
}
▶


//node hacking
◀public:
static void set_node_a_left_to_itself(Annotated_Bst_State & state){
    state.a->left = (BinaryNode<int> *)&(state.a->left);
}
▶
◀public:
static void set_node_b_left_to_itself(Annotated_Bst_State & state){
    state.b->left = (BinaryNode<int> *)&(state.b->left);
}
▶
◀public:
static void set_node_b_left_to_sibling(Annotated_Bst_State & state){
    state.b->left = (BinaryNode<int> *)&(state.b->right);
}
▶





























//visualizing
◀private:
static void make_image(Annotated_Bst_State & state){
    auto text = as_graphviz_v3(state);
    std::string file_name = "/home/laptop/Desktop/bst_run/" + std::to_string(state.current_photo);
    std::ofstream outfile(file_name);
    outfile << text;
    outfile.close();
    ++state.current_photo;
    
    std::string command;
    command = "dot ";
    command += file_name;
    command += " -Tpng -O";
    execute(command);
}
▶

◀private:
static std::string as_graphviz(Annotated_Bst_State const& state){
    std::string str;
    Append_With_Newline(str,"digraph BST {");
    Append_With_Newline(str,"node [fontname=\"Arial\"];");
    auto directions = Tree_Traversal::get_all_directed_relationships(state.root);
    for (auto p: directions){
        
        if (p.first && p.second){
            Append(str,std::to_string(p.first.value()));
            Append(str, " -> ");
            Append_With_Newline(str,std::to_string(p.second.value()));
        }
    }
    
    if (state.a){
        Append(str,"a");
        Append(str, " -> ");
        Append_With_Newline(str,std::to_string(state.a->val));
    }
    if (state.b){
        Append(str,"b");
        Append(str, " -> ");
        Append_With_Newline(str,std::to_string(state.b->val));
    }
    Append_With_Newline(str,"}");
    return str;
}
▶

◀private:
static std::string as_graphviz_v2(Annotated_Bst_State const& state){
    std::string str;
    Append_With_Newline(str,"digraph BST {");
    Append_With_Newline(str,"node [fontname=\"Arial\"];");
    for (auto const& node: state.all_nodes){
        if (node->left){
            Append(str,std::to_string(node->val));
            Append(str, " -> ");
            Append(str,std::to_string(node->left->val));
            Append_With_Newline(str," [color=\"red\"]");
        }
        if (node->right){
            Append(str,std::to_string(node->val));
            Append(str, " -> ");
            Append(str,std::to_string(node->right->val));
            Append_With_Newline(str," [color=\"blue\"]");
        }
    }
    
    
    if (state.a){
        Append(str,"a");
        Append(str, " -> ");
        Append_With_Newline(str,std::to_string(state.a->val));
    }
    if (state.b){
        Append(str,"b");
        Append(str, " -> ");
        Append_With_Newline(str,std::to_string(state.b->val));
    }
    Append_With_Newline(str,"}");
    return str;
}
▶

◀private:
static std::string as_graphviz_v3(Annotated_Bst_State const& state){
    std::string str;
    Append_With_Newline(str,"digraph BST {");
    Append_With_Newline(str,"node [fontname=\"Arial\", shape = record, height=.1];");
    
    //create nodes
    for (auto const& node: state.all_nodes){
        Append(str, "node");
        Append(str, std::to_string(node->val));
        Append(str, "[label = \"<f0> L|<f1> ");
        Append(str, std::to_string(node->val));
        Append_With_Newline(str, "|<f2> R\"];");
    }
    
    
    
    for (auto const& node: state.all_nodes){
        if (node->left){
            Append(str, "\"node");
            Append(str,std::to_string(node->val) + "\"");
            Append(str, ":f0");
            Append(str, " -> ");
            
            
            //special cases
            if (Tree_Node_Properties::left_node_points_to_its_sibling(node)){
                Append(str, "\"node");
                Append(str,std::to_string(node->val) + "\"");
                Append(str, ":f2");
            }
            else if (Tree_Node_Properties::left_node_points_to_itself(node)){
                Append(str, "\"node");
                Append(str,std::to_string(node->val) + "\"");
                Append(str, ":f0");
            }
            
            //normal case
            else{
                Append(str, "\"node");
                Append(str,std::to_string(node->left->val) + "\"");
                Append(str, ":f1");
            }
            Append_With_Newline(str," [color=\"red\"]");
        }
        if (node->right){
            Append(str, "\"node");
            Append(str,std::to_string(node->val) + "\"");
            Append(str, ":f2");
            Append(str, " -> ");
            Append(str, "\"node");
            Append(str,std::to_string(node->right->val) + "\"");
            Append(str, ":f1");
            Append_With_Newline(str," [color=\"blue\"]");
        }
    }
    
    
    if (state.a){
        Append(str,"a");
        Append(str, " -> ");
        Append(str,Get_Double_Quote());
        Append(str, "node");
        Append(str,std::to_string(state.a->val));
        Append_With_Newline(str,Get_Double_Quote());
    }
    if (state.b){
        Append(str,"b");
        Append(str, " -> ");
        Append(str,Get_Double_Quote());
        Append(str, "node");
        Append(str,std::to_string(state.b->val));
        Append_With_Newline(str,Get_Double_Quote());
    }
    Append_With_Newline(str,"}");
    return str;
}
▶