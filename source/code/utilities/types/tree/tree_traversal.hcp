class
❪iostream❫
❪string❫
❪utility❫
❪"code/utilities/types/tree/tree_node_properties.hpp"❫
⚯
⚞⚟

//core traversals
◀public:
template <typename T, typename Fun>
static void perform_preorder(T *root, Fun fun){
    
    if(root == nullptr) return;
    fun(root);
    perform_preorder(root->left,fun);
    perform_preorder(root->right,fun);
}
▶


◀public:
template <typename T, typename Fun>
static void perform_inorder(T *root, Fun fun){
    
    if(root == nullptr) return;
    perform_inorder(root->left,fun);
    fun(root);
    perform_inorder(root->right,fun);
}
▶

◀public:
template <typename T, typename Fun>
static void perform_inorder_with_previous(T *root, Fun fun){
    T *previous = nullptr;
    perform_inorder(root,[&](T* t){
        if (previous){
            std::pair<T*,T*> window{previous,t};
            fun(window);
        }
        previous = t;
    });
}
▶

◀public:
template <typename T, typename Fun>
static void perform_outorder(T *root, Fun fun){
    
    if(root == nullptr) return;
    perform_outorder(root->right,fun);
    fun(root);
    perform_outorder(root->left,fun);
}
▶

◀public:
template <typename T, typename Fun>
static void perform_outorder_with_previous(T *root, Fun fun){
    T *previous = nullptr;
    perform_outorder(root,[&](T* t){
        if (previous){
            std::pair<T*,T*> window{previous,t};
            fun(window);
        }
        previous = t;
    });
}
▶

◀public:
template <typename T, typename Fun>
static void perform_postorder(T *root, Fun fun){
    
    if(root == nullptr) return;
    perform_postorder(root->left,fun);
    perform_postorder(root->right,fun);
    fun(root);
}
▶


//bst traversal utilities
◀public:
template <typename T>
static void bst_inorder_throw_discrepancy(T * root){
    if(root == nullptr) return;
    if (root->left && root->val < root->left->val){
        std::cout << "{" << root->val << " " << root->left->val << "}" << std::endl;
        //if (Tree_Node_Properties::child_breaks_bst_constraint(root)){
        //    root = Tree_Node_Properties::find_invalid_child(root);
        //}
        root = root->left;
        throw root;
    }
    bst_inorder_throw_discrepancy(root->left);
    if (root->right && root->val < root->right->val){
        std::cout << "{" << root->val << " " << root->right->val << "}" << std::endl;
        //if (Tree_Node_Properties::child_breaks_bst_constraint(root)){
        //    root = Tree_Node_Properties::find_invalid_child(root);
        //}
        root = root->right;
        throw root;
    }
    bst_inorder_throw_discrepancy(root->right);
}
▶
◀public:
template <typename T>
static void bst_outorder_throw_discrepancy(T *root){
    if(root == nullptr) return;
    if (root->right && root->val > root->right->val){
        std::cout << "<" << root->val << " " << root->right->val << ">" << std::endl;
        root = root->right;
        //if (Tree_Node_Properties::child_breaks_bst_constraint(root)){
        //    root = Tree_Node_Properties::find_invalid_child(root);
        //}
        throw root;
    }
    bst_inorder_throw_discrepancy(root->right);
    if (root->left && root->val > root->left->val){
        std::cout << "<" << root->val << " " << root->left->val << ">" << std::endl;
        root = root->left;
        //if (Tree_Node_Properties::child_breaks_bst_constraint(root)){
        //    root = Tree_Node_Properties::find_invalid_child(root);
        //}
        throw root;
    }
    bst_inorder_throw_discrepancy(root->left);
}
▶


//utility traversals
◀public:
template <typename T>
static std::vector<T*> inorder_traversal_as_node_list(T *root){
    std::vector<T*> result;
    Tree_Traversal::perform_inorder(root,[&](T* t){
        result.emplace_back(t);
    });
    return result;
}
▶

◀public:
template <typename T>
static std::vector<decltype(T::val)> inorder_traversal_as_list(T *root){
    std::vector<decltype(T::val)> result;
    Tree_Traversal::perform_inorder(root,[&](T* t){
        result.emplace_back(t->val);
    });
    return result;
}
▶

◀public:
template <typename T>
static std::vector<T*> outorder_traversal_as_node_list(T *root){
    std::vector<T*> result;
    Tree_Traversal::perform_outorder(root,[&](T* t){
        result.emplace_back(t);
    });
    return result;
}
▶

◀public:
template <typename T>
static std::vector<decltype(T::val)> outorder_traversal_as_list(T *root){
    std::vector<decltype(T::val)> result;
    Tree_Traversal::perform_outorder(root,[&](T* t){
        result.emplace_back(t->val);
    });
    return result;
}
▶