class
❪iostream❫
❪string❫
❪utility❫
❪"code/utilities/types/tree/tree_node_properties.hpp"❫
⚯
⚞⚟


◀public:
template <typename T>
static void go_all_the_way_left(T* & node){
    if (node){
        if (node->left){
            node = node->left;
        }
    }
}
▶

//core traversals
◀public:
template <typename T, typename Fun>
static void morris_traversal(T *root, Fun fun){

    if (root == nullptr){
        return; 
    }
    
    T* current = nullptr;
    T* pre = nullptr; 
    current = root;
    
    while (current != nullptr) {
  
        if (current->left == nullptr) { 
            fun(current);
            std::cout << current->val << " " << current->right->val << std::endl;
            current = current->right; 
        }
        else {
            
            find_the_inorder_predecessor_of_current(pre,current);
  
            /* Make current as the right child of its inorder  
               predecessor */
            if (pre->right == nullptr) {
                pre->right = current;
                current = current->left;
            } 
  
            /* Revert the changes made in the 'if' part to restore  
               the original tree i.e., fix the right child 
               of predecessor */
            else {

                fun(current);
                
                if (current){
                    if (current->right){
                        pre->right = current->right;
                        go_all_the_way_left(pre->right);
                        
                        if (current->val != pre->right->val){
                            std::cout << current->val << " " << pre->right->val << std::endl;
                        }
                    }
                }
                
                current = current->right;
                pre->right = nullptr;

            }
        }
    }
} 
▶

◀public:
template <typename T>
static void find_the_inorder_predecessor_of_current(T* & pre, T* & current){
    /* Find the inorder predecessor of current */
    //state_check(current,pre);
    pre = current->left;
    //state_check(current,pre);
    while (pre->right != nullptr && pre->right != current)
        pre = pre->right;
    //state_check(current,pre);
    //std::cout << "----" << std::endl;
} 
▶



◀public:
template <typename T>
static void state_check(T* curr, T* pre){
    //Tree_Node_Properties::print_local_bst_constraint(curr);
    //Tree_Node_Properties::print_local_bst_constraint(pre);
    std::cout << "[" << Tree_Node_Properties::as_str(curr) << "]";
    std::cout << "{" << Tree_Node_Properties::left_as_str(curr) << "}";
    std::cout << "<" << Tree_Node_Properties::right_as_str(curr) << ">";
    std::cout << "[" << Tree_Node_Properties::as_str(pre) << "]";
    std::cout << "{" << Tree_Node_Properties::left_as_str(pre) << "}";
    std::cout << "<" << Tree_Node_Properties::right_as_str(pre) << ">";
    std::cout << std::endl;
}
▶

◀public:
template <typename T, typename Fun>
static void morris_traversal2(T *curr, T* pre, Fun fun){
  
    if (curr == nullptr){
        return; 
    }
    
    
    std::cout << "connect end to root" << std::endl;
    pre = curr;
    while (curr->right != nullptr){
        curr = curr->right;
    }
    curr->right = pre;
    curr->left = (T*)&(curr->left);
    curr = pre;
    
    
    std::cout << "start" << std::endl;
    state_check(curr,pre);
    
    //a full in order traversal (no stack or recursion)
    while (curr != nullptr) {
  
        if (curr->left == nullptr) { 
            
            fun(pre,curr,"reg");
            
            std::cout << "inorder good" << std::endl;
            state_check(curr,pre);
    
            curr = curr->right;
            
            state_check(curr,pre);
        } 
        else { 
  
            /* Find the inorder predecessor of curr */
            std::cout << "finding the bridge" << std::endl;
            // if (Tree_Node_Properties::left_node_points_to_itself(curr)){
            //     std::cout << "FULL TRAVERSAL DONE" << std::endl;
            //     curr->left = nullptr;
            //     pre = curr->right;
            //     curr->right = nullptr;
            //     curr = pre;
            //     state_check(curr,pre);
            //     break;
            // }
            state_check(curr,pre);
            
            pre = curr->left; 
            state_check(curr,pre);
            
            while (pre->right != nullptr && pre->right != curr){
                pre = pre->right;
                state_check(curr,pre);
            }
            std::cout << "found" << std::endl;
  
            /* Make curr as the right child of its inorder  
               predecessor */
            if (pre->right == nullptr) { 
                
                std::cout << "change curr" << std::endl;
                state_check(curr,pre);
                pre->right = curr;
                state_check(curr,pre);
                curr = curr->left; 
                state_check(curr,pre);
            } 
  
            /* Revert the changes made in the 'if' part to restore  
               the original tree i.e., fix the right child 
               of predecessor */
            else { 

                std::cout << "revert changes" << std::endl;
                state_check(curr,pre);
                pre->right = nullptr;
                state_check(curr,pre);
                fun(pre,curr,"fix");
                curr = curr->right; 
                state_check(curr,pre);
            }
        }
    }
    
    std::cout << "done" << std::endl;
    Tree_Node_Properties::print_local_bst_constraint(curr);
    Tree_Node_Properties::print_local_bst_constraint(pre);
    state_check(curr,pre);
    
    
} 
▶




◀public:
template <typename T, typename Fun>
static void perform_preorder(T *root, Fun fun){
    
    if(root == nullptr) return;
    fun(root);
    perform_preorder(root->left,fun);
    perform_preorder(root->right,fun);
}
▶


◀public:
template <typename T>
static T* set_to_earliest_inorder_nullptr(T *root){
    
    if(root == nullptr) return;
    while (root->left){
        root = root->left;
    }
}
▶

◀public:
template <typename T>
static T* set_to_earliest_outorder_nullptr(T *root){
    
    if(root == nullptr) return;
    while (root->right){
        root = root->right;
    }
}
▶


◀public:
template <typename T, typename Fun>
static void perform_inorder(T *root, Fun fun){
    
    if(root == nullptr) return;
    perform_inorder(root->left,fun);
    fun(root);
    perform_inorder(root->right,fun);
}
▶

◀public:
template <typename T>
static T* get_earliest_nullptr_inorder(T *root){
    
    if (root){
        if (!root->left){
            return root->left;
        }
    }
    return get_earliest_nullptr_inorder(root->left);
}
▶

◀public:
template <typename T>
static T* get_earliest_nullptr_outorder(T *root){
    
    if (root){
        if (!root->right){
            return root->right;
        }
    }
    return get_earliest_nullptr_outorder(root->right);
}
▶


◀public:
template <typename T, typename Fun>
static void perform_inorder_with_previous(T *root, Fun fun){
    T *previous = nullptr;
    perform_inorder(root,[&](T* t){
        if (previous){
            std::pair<T*,T*> window{previous,t};
            fun(window);
        }
        previous = t;
    });
}
▶

◀public:
template <typename T, typename Fun>
static void perform_inorder_with_previous(T *previous, T *root, Fun fun){
    perform_inorder(root,[&](T* t){
        if (previous){
            std::pair<T*,T*> window{previous,t};
            fun(window);
        }
        previous = t;
    });
}
▶

◀public:
template <typename T, typename Fun>
static void perform_outorder(T *root, Fun fun){
    
    if(root == nullptr) return;
    perform_outorder(root->right,fun);
    fun(root);
    perform_outorder(root->left,fun);
}
▶

◀public:
template <typename T, typename Fun>
static void perform_outorder_with_previous(T *root, Fun fun){
    T *previous = nullptr;
    perform_outorder(root,[&](T* t){
        if (previous){
            std::pair<T*,T*> window{previous,t};
            fun(window);
        }
        previous = t;
    });
}
▶

◀public:
template <typename T, typename Fun>
static void perform_outorder_with_previous(T *previous, T *root, Fun fun){
    perform_outorder(root,[&](T* t){
        if (previous){
            std::pair<T*,T*> window{previous,t};
            fun(window);
        }
        previous = t;
    });
}
▶

◀public:
template <typename T, typename Fun>
static void perform_postorder(T *root, Fun fun){
    
    if(root == nullptr) return;
    perform_postorder(root->left,fun);
    perform_postorder(root->right,fun);
    fun(root);
}
▶


//bst traversal utilities
◀public:
template <typename T>
static void bst_inorder_throw_discrepancy(T * root){
    if(root == nullptr) return;
    if (root->left && root->val < root->left->val){
        std::cout << "{" << root->val << "]" << root->left->val << "}" << std::endl;
        //if (Tree_Node_Properties::child_breaks_bst_constraint(root)){
        //    root = Tree_Node_Properties::find_invalid_child(root);
        //}
        root = root->left;
        throw root;
    }
    bst_inorder_throw_discrepancy(root->left);
    if (root->right && root->val < root->right->val){
        std::cout << "{" << root->val << "]" << root->right->val << "}" << std::endl;
        //if (Tree_Node_Properties::child_breaks_bst_constraint(root)){
        //    root = Tree_Node_Properties::find_invalid_child(root);
        //}
        root = root->right;
        throw root;
    }
    bst_inorder_throw_discrepancy(root->right);
}
▶
◀public:
template <typename T>
static void bst_outorder_throw_discrepancy(T *root){
    if(root == nullptr) return;
    if (root->right && root->val > root->right->val){
        std::cout << "<" << root->val << "]" << root->right->val << ">" << std::endl;
        root = root->right;
        //if (Tree_Node_Properties::child_breaks_bst_constraint(root)){
        //    root = Tree_Node_Properties::find_invalid_child(root);
        //}
        throw root;
    }
    bst_inorder_throw_discrepancy(root->right);
    if (root->left && root->val > root->left->val){
        std::cout << "<" << root->val << "]" << root->left->val << ">" << std::endl;
        root = root->left;
        //if (Tree_Node_Properties::child_breaks_bst_constraint(root)){
        //    root = Tree_Node_Properties::find_invalid_child(root);
        //}
        throw root;
    }
    bst_inorder_throw_discrepancy(root->left);
}
▶


//utility traversals
◀public:
template <typename T>
static std::vector<T*> inorder_traversal_as_node_list(T *root){
    std::vector<T*> result;
    Tree_Traversal::perform_inorder(root,[&](T* t){
        result.emplace_back(t);
    });
    return result;
}
▶

◀public:
template <typename T>
static std::vector<decltype(T::val)> inorder_traversal_as_list(T *root){
    std::vector<decltype(T::val)> result;
    Tree_Traversal::perform_inorder(root,[&](T* t){
        result.emplace_back(t->val);
    });
    return result;
}
▶

◀public:
template <typename T>
static std::vector<T*> outorder_traversal_as_node_list(T *root){
    std::vector<T*> result;
    Tree_Traversal::perform_outorder(root,[&](T* t){
        result.emplace_back(t);
    });
    return result;
}
▶

◀public:
template <typename T>
static std::vector<decltype(T::val)> outorder_traversal_as_list(T *root){
    std::vector<decltype(T::val)> result;
    Tree_Traversal::perform_outorder(root,[&](T* t){
        result.emplace_back(t->val);
    });
    return result;
}
▶


◀public:
template <typename T>
static std::vector<std::pair<std::optional<decltype(T::val)>,std::optional<decltype(T::val)>>> get_all_directed_relationships(T *root){
    auto all_nodes = inorder_traversal_as_node_list(root);
    
    std::vector<std::pair<std::optional<decltype(T::val)>,std::optional<decltype(T::val)>>> results;
    for (auto node: all_nodes){
        std::pair<std::optional<decltype(T::val)>,std::optional<decltype(T::val)>> temp;
        temp.first = node->val;
        
        //add left
        if (node->left){
            temp.second = node->left->val;
        }
        else{
            temp.second = std::nullopt;
        }
        results.emplace_back(temp);
        
        //add right
        if (node->right){
            temp.second = node->right->val;
        }
        else{
            temp.second = std::nullopt;
        }
        results.emplace_back(temp);
    }
    
    return results;
}


