class
❪iostream❫
❪string❫
❪utility❫
⚯
⚞⚟

//core traversals
◀public:
template <typename T, typename Fun>
static void perform_preorder(T *root, Fun fun){
    
    if(root == NULL) return;
    fun(root);
    perform_preorder(root->left,fun);
    perform_preorder(root->right,fun);
}
▶


◀public:
template <typename T, typename Fun>
static void perform_inorder(T *root, Fun fun){
    
    if(root == NULL) return;
    perform_inorder(root->left,fun);
    fun(root);
    perform_inorder(root->right,fun);
}
▶

◀public:
template <typename T, typename Fun>
static void perform_inorder_with_previous(T *root, Fun fun){
    T *previous = nullptr;
    perform_inorder(root,[&](T* t){
        if (previous){
            std::pair<T*,T*> window{previous,t};
            fun(window);
        }
        previous = t;
    });
}
▶

◀public:
template <typename T, typename Fun>
static void perform_outorder(T *root, Fun fun){
    
    if(root == NULL) return;
    perform_outorder(root->right,fun);
    fun(root);
    perform_outorder(root->left,fun);
}
▶

◀public:
template <typename T, typename Fun>
static void perform_postorder(T *root, Fun fun){
    
    if(root == NULL) return;
    perform_postorder(root->left,fun);
    perform_postorder(root->right,fun);
    fun(root);
}
▶


//bst traversal utilities
◀public:
template <typename T>
static bool bst_inorder_until_discrepancy(T *root){
    if(root == NULL) return true;
    if (bst_inorder_until_discrepancy(root->left)){
        if (root->val > root->right->val){ return false; }
        bst_inorder_until_discrepancy(root->right);
    }
    return true;
}
▶
◀public:
template <typename T>
static bool bst_outorder_until_discrepancy(T *root){
    if(root == NULL) return true;
    if (bst_outorder_until_discrepancy(root->right)){
        if (root->val < root->left->val){ return false; }
        bst_outorder_until_discrepancy(root->left);
    }
    return true;
}
▶


//utility traversals
◀public:
template <typename T>
static std::vector<T*> inorder_traversal_as_node_list(T *root){
    std::vector<T*> result;
    Tree_Traversal::perform_inorder(root,[&](T* t){
        result.emplace_back(t);
    });
    return result;
}
▶

◀public:
template <typename T>
static std::vector<decltype(T::val)> inorder_traversal_as_list(T *root){
    std::vector<decltype(T::val)> result;
    Tree_Traversal::perform_inorder(root,[&](T* t){
        result.emplace_back(t->val);
    });
    return result;
}
▶

◀public:
template <typename T>
static std::vector<T*> outorder_traversal_as_node_list(T *root){
    std::vector<T*> result;
    Tree_Traversal::perform_outorder(root,[&](T* t){
        result.emplace_back(t);
    });
    return result;
}
▶

◀public:
template <typename T>
static std::vector<decltype(T::val)> outorder_traversal_as_list(T *root){
    std::vector<decltype(T::val)> result;
    Tree_Traversal::perform_outorder(root,[&](T* t){
        result.emplace_back(t->val);
    });
    return result;
}
▶